-- @version 2.0.0021
-- @author LBX
-- @changelog
-- 2.0.0019:

--[[
   * ReaScript Name: Smart Knobs 2
   * Lua script for Cockos REAPER
   * Author: Leon Bradley (LBX)
   * Author URI: 
   * Licence: GPL v3
  ]]
  
  local lvar = {}
  local lupd = {}
  local settings = {}
  local paths = {}

  lvar.version = '2.0.0021'
  lvar.wintit = 'Smart Knobs 2'
  
  lvar.scriblen = {}
  lvar.scriblen[0] = 7
  lvar.scriblen[1] = 7
  lvar.scriblen[2] = 7
  lvar.scriblen[3] = 7
  
  lvar.virtualss_active = false
  
  lvar.checktracks = 0 --set to nil to disable
  lvar.checktracks_rrobin = 32
  
  function DBG(str,eol)
    if str==nil then str="nil" end
    eol = eol or '\n'
    reaper.ShowConsoleMsg(tostring(str)..eol)
  end        
  
  --lvar.debug = true
  lvar.encoder_host_delay = 0.2

  lvar.mirroridxs = {}
  lvar.mirrordevices = false
  lvar.mirrordev_1to2 = false
  lvar.mirrordev_3to4 = false
  
  lvar.AKLayerMode = 0
  lvar.assignmentdisplay_active = true
  
  lvar.tcactive = true
  lvar.disableSSplayback = false

  lvar.qfx_faders = 128
  lvar.qfx_banks = 16
  lvar.qfx_bank = 0
  lvar.qfx_data = {} --enabled/tracknum/fxnum/paramnum/tguid/fxguid.  Save in project ext state
  --short press on learn enables/disables, long press learns
  lvar.qfx_defaultcolor = 7
  
  lvar.faders = {}
  lvar.fadersidx = {}
  
  lvar.trackselectmode = false
  
  lvar.fxlearnmode = 1
  
  lvar.osc_banksize = 8

  lvar.propaot = false
  
  lvar.defeatitem_offset = 0.1 --offset for choosing item to defeat (if play position within offset of end of item - choose next item)
  
  lvar.fdata_sendcconrel = 0
  lvar.fdata_removedups = 1

  lvar.ss_override_sscolor = {}
  lvar.ss_override_name = {}
  lvar.ss_alwaysshowdispval = false
  
  lvar.finetune_active = false
  lvar.finetune_fader = {}
  lvar.cclatch = false
  
  lvar.pluginblacklist = {}
  lvar.selectfadermode = 0
  
  lvar.rec_mapactiveenvstofaders = true
  lvar.rec_mapactiveenvstofaders2 = false --saved state
  lvar.rec_automap_bankoffset = 0
  lvar.rec_automap_flip = false
  lvar.rec_automap_solo = true
  lvar.rec_automap_device = -1
  
  lvar.rec_automap_color_vol = 2
  lvar.rec_automap_color_pan = 3
  lvar.rec_automap_color_mute = 1
  lvar.rec_automap_color_plug = 4
  
  lvar.rr_defeat_active = true
  
  lvar.rrsettings = {}
  lvar.rrsettings.autoquantize = 0
  lvar.rrsettings.quantize_strength = 100
  lvar.rrsettings.autorestore = 0
  lvar.rrsettings.merge = 1
  lvar.rrsettings.extend = 1
  lvar.rrsettings.overdubnotes = 1
  lvar.rrsettings.timeselection = 0
  lvar.rrsettings.trackoffset = 0
  
  lvar.relmodes = {}
  lvar.relmodes[2] = true
  lvar.relmodes[3] = true
  lvar.relmodes[6] = true
  
  --CC's to mute in notes overwrite mode
  --lvar.special_cc = {}
  --lvar.special_cc[64] = true
  --CC's not to mute in notes overwrite mode
  lvar.exception_cc = {}
  lvar.exception_cc[0] = true --bank
  lvar.exception_cc[32] = true --bank 
  
  lvar.fontzoom = 1
  lvar.fontoffset = 0
  lvar.fontzoom2 = 1
  lvar.guizoom = 1
  lvar.guizoom2 = 2
  
  lvar.tags = {}
  lvar.tags.trackassoc = {}
  lvar.tags.tags = {}
  
  lvar.checkmidiports = false
  lvar.sysxinactive_dev = {}
  
  lvar.tobool = {}
  lvar.tobool[0] = false
  lvar.tobool[1] = true
  lvar.touchmode = 2
  
  lvar.stripperlink = false
  lvar.sk2data_setdata = nil
  lvar.sk2data_setdata_delaytime = 0.5
  lvar.sk2data_setdata_delayaffectsfeedback = true
  lvar.sk2setdata_num = 32
  
  lvar.ai = {cnt = 0}
  
  lvar.takeover = {bus = 0, channel = 1, active = -1, fader_to = {}, encoder_to = {}}  
  
  lvar.takeover_types = {}

  lvar.showcontrolname = false

  --Internal commands that allow continous data
  lvar.PI_Cont = {}
  lvar.PI_Cont[(8<<16)+3] = true
  lvar.PI_Cont[(8<<16)+4] = true
  lvar.PI_Cont[(8<<16)+5] = true
  lvar.PI_Cont[(17<<16)+1] = true
  lvar.PI_Cont[(17<<16)+2] = true
  lvar.PI_Cont[(17<<16)+3] = true
  for p = 1, lvar.qfx_faders do
    lvar.PI_Cont[(18<<16)+p] = true
  end  

  lvar.ss_color_override = {}
  lvar.ss_color_override_color = 1
  lvar.ss_color_override_enabled = false
  lvar.ss_color_override_nonautomatable = true
  lvar.ss_color_override_nonautomatable_color = 0
  
  lvar.recoffmode = 1
  lvar.rec_starttransportonfadertouch = false
  lvar.cc_starttransportonfadertouch = false
  
  lvar.enablegroupinputs = false
  
  lvar.envdata = {}
  lvar.env_autoshow_cnt = 4
  lvar.env_autoshow_bank = 0
  lvar.autoenv = false
  lvar.autoenv_mode = 0 --default
  lvar.autoenv_assslip = false
  lvar.env_laneheight = 80
  lvar.env_zoomh = 1
  lvar.env_indzoomh = {}
  
  lvar.env_spread = 0
  lvar.env_spread_limit = 0
  lvar.env_maxheight = 400
  lvar.env_mintrackheight = 0
  lvar.env_maxtrackheight = 0
  lvar.env_tralign = 0 --0=off, 1=top, 2 = mid
  
  lvar.overtemplate_active = false
  lvar.overtemplate = 1
  lvar.overtmp_cnt = 8
  lvar.overtemp_latchreturn = nil
  
  lvar.defaulttemplate_type = nil
  lvar.defaulttemplate_fn = 'default.smtemp'
  lvar.defaulttemplate_active = false
  
  lvar.midifilter_ccoffs = 0
  lvar.idx_cc = {}
  
  lvar.tracks = {inst_in = 0,
                 rr = 0,
                 skcc_in = 0,
                 out = 0,
                 tot = 16}
  
  lvar.sndinfo = {}
  lvar.sndinfo[0] = '<VOLENV'
  lvar.sndinfo[1] = '<PANENV'
  lvar.sndinfo[2] = '<MUTEENV'
  lvar.sndinfo[3] = 'D_VOL'
  lvar.sndinfo[4] = 'D_PAN'
  lvar.sndinfo[5] = 'B_MUTE'

  function InitColours()
    return {faderborder = '25 25 25',
                   fader = '55 55 55',
                   fader_inactive = '0 80 255',
                   faderbg = '35 35 35',
                   faderbg2 = '15 15 15',
                   ibox = '15 15 15',
                   iboxT = '205 205 205',
                   mainbg = '35 35 35',
                   buttcol = '25 25 25',
                   buttcollit = '205 205 205',
                   faderlit = '87 109 130',
                   faderlitcc = '220 148 52',
                   faderlitcc_chasefail = '180 108 12',
                   faderlittr = '185 86 132',
                   faderlitac = '250 200 52',
                   faderlitint = '0 195 167',
                   pnamelit = '107 129 150',
                   globalfader = '38 165 82',
                   globalfader_txt = '0 0 0',
                   permafader = '205 205 205',
                   permafader_txt = '0 0 0',
                   layerfader = '150 90 190',
                   layerfader_txt = '0 0 0',                   
                   mainfader = '64 64 64',
                   mainfader_txt = '0 0 0',                   
                   devctlname = '64 64 64',
                   devctlunassigned = '25 25 25',
                   devctlassigned = '25 25 25',
                   modebtnhl = '205 205 205',
                   faderunassigned = '255 42 0',
                   faderunassigned_txt = '0 0 0',
                   filterbox = '255 165 0'}
  end
  
  local colours = InitColours()
  
  local tab_automode = {'Trim/Read','Read','Touch','Write','Latch','Latch Preview'}
  local tab_amcol = {colours.iboxT,'128 128 128','128 128 128','128 128 128','128 128 128','160 128 255'}
  local tab_dtype = {['CC'] = 0, ['PITCH'] = 1, ['NOTE'] = 2, ['SPEC1'] = 100, ['SPEC2'] = 102, ['XCTLLED'] = 101, ['DUMMY'] = 999}
  local tab_mode = {'Plugin Mode','Instance Mode','Track Mode'}
  local tab_encres = {64,128,256,512,1024,2048,4096}
  local tab_aicodes = {}
  tab_aicodes[3] = {code = 'D_AMPLITUDE', mult = 2, add = 1, min = -1, max = 1}
  tab_aicodes[4] = {code = 'D_BASELINE', mult = 1, add = 0, min = 0, max = 1}
  tab_aicodes[5] = {code = 'D_PLAYRATE', mult = 10, add = 0, min = 0, max = 10}
  
  local tab_internal_troffs = {'Track offset -1',
                              'Track offset +1',
                              'Track offset -8',
                              'Track offset +8',
                              'Track offset -16',
                              'Track offset +16',
                              'Track offset -24',
                              'Track offset +24',
                              'Track offset -32',
                              'Track offset +32'}
  local tab_internal_troffs_vals = {-1, 1, -8, 8, -16, 16, -24, 24, -32, 32}
  local tab_internal_globtmp = {'Enable/disable global template',
                                '|Previous global template',
                                'Next global template',
                                '|Select global template 1',
                                'Select global template 2',
                                'Select global template 3',
                                'Select global template 4',
                                'Select global template 5',
                                'Select global template 6',
                                'Select global template 7',
                                'Select global template 8',
                                'Select global template 9',
                                'Select global template 10',
                                'Select global template 11',
                                'Select global template 12',
                                'Select global template 13',
                                'Select global template 14',
                                'Select global template 15',
                                'Select global template 16'}
  local tab_commonfuncs = {'Flip','|Select Track Mode','Select Plugin Instance Mode','Select Plugin Mode'}
  local tab_commonfuncs_f = {}
  
  local tab_xtouch_color_menu = {'Black','Red','Green','Yellow','Blue','Magenta','Cyan','White','Invert Top Line','Invert Bottom Line'}
  local tab_xtouch_colors = {}
  tab_xtouch_colors[0] = {v = 0, c = '0 0 0', tc = '205 205 205'}
  tab_xtouch_colors[1] = {v = 1, c = '255 0 0'}
  tab_xtouch_colors[2] = {v = 2, c = '0 255 0'}
  tab_xtouch_colors[3] = {v = 3, c = '255 216 0'}
  tab_xtouch_colors[4] = {v = 4, c = '0 38 255'}
  tab_xtouch_colors[5] = {v = 5, c = '255 0 220'}
  tab_xtouch_colors[6] = {v = 6, c = '0 255 255'}
  tab_xtouch_colors[7] = {v = 7, c = '255 255 255'}
  
  lvar.colordesc_l = {}
  lvar.colordesc_l[1] = {'Plugin parameter assignment','Left-click = box color','Right-click = text color'}
  lvar.colordesc_l[2] = {'CC assignment','Left-click = box color','Right-click = text color'}
  lvar.colordesc_l[3] = {'Track assignment','Left-click = box color','Right-click = text color'}
  lvar.colordesc_l[4] = {'Action assignment','Left-click = box color','Right-click = text color'}
  lvar.colordesc_l[5] = {'Internal assignment','Left-click = box color','Right-click = text color'}
  lvar.colordesc_l[6] = {'Main layer assignment','Left-click = box color','Right-click = text color'}
  lvar.colordesc_l[7] = {'Overlay layer assignment','Left-click = box color','Right-click = text color'}
  lvar.colordesc_l[8] = {'Global layer assignment','Left-click = box color','Right-click = text color'}
  lvar.colordesc_l[9] = {'Permanent layer assignment','Left-click = box color','Right-click = text color'}
  lvar.colordesc_l[10] = {'-','Left-click = box color','Right-click = text color'}
  lvar.colordesc_l[11] = {'Main background'}
  lvar.colordesc_l[12] = {'Btn on/off','Left-click = off color','Right-click = on color'}
  lvar.colordesc_l[13] = {'Unassigned device slot','Left-click = box color','Right-click = text color'}
  lvar.colordesc_l[14] = {'Assigned device slot'}
  lvar.colordesc_l[15] = {'Left-click = fader background','Right-click = fader border'}
  
  lvar.colordesc_r = {}
  lvar.colordesc_r[1] = {'Info box','Left-click = box color','Right-click = text color'}
  lvar.colordesc_r[2] = {'Automatable fader assignment', 'scribble strip color'}
  lvar.colordesc_r[3] = {'Non-automatable fader assignment', 'scribble strip color'}  
  
  --[[local tab_cvars = {}
  tab_cvars[1] = {onval = 1, onled = 1}
  tab_cvars[2] = {onval = 1, onled = 127}
  tab_cvars[3] = {onval = 1, onled = 127}
  tab_cvars[4] = {onval = 1, onled = 127}
  
  local cvar_t = {flip = 1, mode = 2}
  local cvar = {}
  cvar[cvar_t.flip] = 0
  cvar[cvar_t.mode] = 1]]
  
  local tab_filters = {}
  tab_filters[1] = 'Clear all filters|'
  tab_filters[2] = 'All assigned slots'
  tab_filters[3] = 'All unassigned slots|'
  tab_filters[4] = 'Plugin assignments'
  tab_filters[5] = 'CC assignments'
  tab_filters[6] = 'Track assignments'
  tab_filters[7] = 'Action assignments'
  tab_filters[8] = 'Internal assignments|'
  tab_filters[9] = 'Permanent assignments|'
  tab_filters[10] = '#Device 1'
  tab_filters[11] = '#Device 2'
  tab_filters[12] = '#Device 3'
  tab_filters[13] = '#Device 4|'
  
  lvar.restorelastfilter = true
  
  lvar.dv_filter_enabled = true
  lvar.dv_filter = {}
  --lvar.dv_filter['off'] = true
  --lvar.dv_filter['on'] = true
  --lvar.dv_filter[' off'] = true
  --lvar.dv_filter[' on'] = true
  lvar.dv_filter['  off'] = true
  lvar.dv_filter['  on'] = true
  
  lvar.trsendcnt = 8
  
  lvar.scrubactive = -1
  lvar.scrubflag = -1
  lvar.scrubtable = {-1,18,1,2}
  local tab_scrubnudge = {}
  tab_scrubnudge[0] = {desc = 'Scrub', val = -1, disp = ' scb'}
  tab_scrubnudge[1] = {desc = 'Frames', val = 18, disp = ' frm'}
  tab_scrubnudge[2] = {desc = 'Seconds', val = 1, disp = ' sec'}
  tab_scrubnudge[3] = {desc = 'Minutes', val = 1, disp = ' min'}
  tab_scrubnudge[4] = {desc = 'Beats', val = 2, disp = ' bts'}
  tab_scrubnudge[5] = {desc = 'Bars', val = 2, disp = ' brs'}
  tab_scrubnudge[6] = {desc = 'Markers', val = -2, disp = ' mrk'}
  tab_scrubnudge[7] = {desc = 'Items', val = -3, disp = ' itm'}
  tab_scrubnudge[8] = {desc = 'Grid', val = -4, disp = ' grd'}
  
  lvar.lanes_xtra = {}
  lvar.lanes_xtra.velbottom = false
  lvar.lanes_xtra.velshow = true
  
  lvar.lanes_xtra[1] = {}
  lvar.lanes_xtra[2] = {}
  lvar.lanes_xtra[3] = {}
  lvar.lanes_xtra[4] = {}
  
  lvar.loadalltemplates = false
  
  lvar.midieditor_cclanes = false
  lvar.midieditor_cclanes_max = 3
  lvar.midieditor_cclanes_fast = false
  lvar.midieditor_cclanes_offset = 0
  lvar.midieditor_cclanes_h = 50
  lvar.midieditor_cclanes_wrap = true
  
  lvar.midieditor_cclanes_showallfixed = false
  lvar.midieditor_cclanes_hideallauto = false
  lvar.midieditor_cclanes_solo = false
  lvar.midieditor_cclanes_sololane = 1
  lvar.midieditor_cclanes_solovel = false
  lvar.midieditor_cclanes_heightmulti = 1
  lvar.midieditor_cclanes_hmulti = {}
  lvar.midieditor_cclanes_hmulti[1] = 1
  lvar.midieditor_cclanes_hmulti[2] = 1
  lvar.midieditor_cclanes_hmulti[3] = 1
  lvar.midieditor_cclanes_hmulti[4] = 1
  
  lvar.lanes_ov_enable = true
  lvar.lanes_ov_tab = {}
  lvar.lanes_presets = {}
  
  lvar.lstfilt = {}
  lvar.lstfiltsel = {}
  lvar.userfilter = {}
  lvar.defaultfilter = 1
  
  lvar.fxsel_mode = 0
  lvar.fxsel_slot = 0
  lvar.fxsel_plugtype = 0
  
  local tab_btntype = {}
  tab_btntype[1] = {t='Single',v=0}
  tab_btntype[2] = {t='Hold/Repeat',v=5}
  tab_btntype[3] = {t='Toggle',v=4}  
  tab_btntype[4] = {t='Hold/Sustain',v=6}  
  
  local tab_trparams = {'Vol','Pan','Mute','Solo','Rec','FX Enabled','Selected','Width','Dual Pan L','Dual Pan R','Peak Meter','Peak Meter L','Peak Meter R',--[['Track Name']]''}
  local tab_trparams_code = {'D_VOL','D_PAN','B_MUTE','I_SOLO','I_RECARM','I_FXEN','I_SELECTED','D_WIDTH','D_DUALPANL','D_DUALPANR','X_PKMETER','X_PKMETERL','X_PKMETERR','X_TRACKNAME'}    
  local tab_trparams_envnames = {'Volume','Pan','Mute',nil,nil,nil,nil,'Width','Pan Left','Pan Right',nil,nil}
  local tab_trparams_envnames2 = {'<VOLENV','<PANENV','<MUTEENV'}
  local tab_trparams_envcreate = {41866,41868,41871,nil,nil,nil,nil,41870,nil,nil,nil,nil}
  
  local tab_trparams_func = {reaper.CSurf_OnVolumeChange, reaper.CSurf_OnPanChange, reaper.CSurf_OnMuteChange, nil, nil, nil, nil, nil --[[reaper.CSurf_OnWidthChange]]}
  local tab_trparams_funcget = {reaper.GetTrackUIVolPan, reaper.GetTrackUIVolPan, reaper.GetTrackUIMute}

  local tab_tr_envnames = {}
  tab_tr_envnames['Volume'] = 1
  tab_tr_envnames['Pan'] = 2
  tab_tr_envnames['Mute'] = 3
  tab_tr_envnames['Width'] = 8
  tab_tr_envnames['Pan Left'] = 9
  tab_tr_envnames['Pan Right'] = 10
  tab_tr_envnames['Send Volume'] = 1 << 4
  tab_tr_envnames['Send Pan'] = 2 << 4
  tab_tr_envnames['Send Mute'] = 3 << 4

  local tab_trsnds = {}
  local tab_trsnds_code = {reaper.GetTrackSendUIVolPan, reaper.GetTrackSendUIVolPan, reaper.GetTrackSendUIMute}
  local tab_trsnds_coderec = {reaper.SetTrackSendUIVol, reaper.SetTrackSendUIPan, 'B_MUTE'}
  
  local function DBGOut(txt)
    if lvar.debug then
      reaper.ShowConsoleMsg(tostring(txt)..'\n')
    end
  end
  
  function conv_onoff(b, v)
    if (v or 0) > 0 then
      return 'on'
    else
      return 'off'
    end
  end
  
  function frombool(b)
  
    local ret = 0
    if tostring(b) == 'true' then
      ret = 1
    end
    return ret
    
  end
  
  local tab_fxtypeconv = {}
  tab_fxtypeconv['dll'] = 'vst'
  
  local track_info = {}
  track_info['D_VOL'] = {btype = 0, states = 2, min = 0, max = 4, scaling = 12, conv = reaper.mkvolstr}
  track_info['D_PAN'] = {btype = 0, states = 3, min = -1, max = 1, conv = reaper.mkpanstr}
  track_info['B_MUTE'] = {btype = 4, states = 2, min = 0, max = 1, conv = conv_onoff, convval = frombool}
  track_info['I_SOLO'] = {btype = 4, states = 2, min = 0, max = 2, conv = conv_onoff}
  track_info['I_RECARM'] = {btype = 4, states = 2, min = 0, max = 1, conv = conv_onoff}
  track_info['I_FXEN'] = {btype = 4, states = 2, min = 0, max = 1, conv = conv_onoff}
  track_info['I_SELECTED'] = {btype = 4, states = 2, min = 0, max = 1, conv = conv_onoff}
  track_info['D_WIDTH'] = {btype = 0, states = 3, min = -1, max = 1, conv = reaper.mkpanstr}
  track_info['D_DUALPANL'] = {btype = 0, states = 3, min = -1, max = 1, conv = reaper.mkpanstr}
  track_info['D_DUALPANR'] = {btype = 0, states = 3, min = -1, max = 1, conv = reaper.mkpanstr}
  track_info['X_PKMETER'] = {mononly = true, btype = 0, states = 2, min = 0, max = 4, scaling = 12, conv = reaper.mkvolstr}
  track_info['X_PKMETERL'] = {mononly = true, btype = 0, states = 2, min = 0, max = 4, scaling = 12, conv = reaper.mkvolstr}
  track_info['X_PKMETERR'] = {mononly = true, btype = 0, states = 2, min = 0, max = 4, scaling = 12, conv = reaper.mkvolstr}
  track_info['X_TRACKNAME'] = {mononly = true, btype = 0, states = 1, min = 0, max = 1, scaling = 12}
  
  local tracksend_info = {}
  tracksend_info[1] = {btype = 0, states = 2, min = 0, max = 4, scaling = 12, conv = reaper.mkvolstr}
  tracksend_info[2] = {btype = 0, states = 2, min = -1, max = 1, conv = reaper.mkpanstr}
  tracksend_info[3] = {btype = 4, states = 2, min = 0, max = 1, conv = conv_onoff}
  
  local ptype_cnt = 6
  local ptype = {host = 1,
                 cc = 2,
                 track = 3,
                 action = 4,
                 internal = 5}
  local ptype_txt = {'PLUG',
                     'CC',
                     'TRK',
                     'ACT',
                     'INT'}
                     
  local ptype_info = {}
  ptype_info[1] = {idx = 'faderlit', tsz = -4, col = colours.faderlit, btntxt = '0 0 0'}
  ptype_info[2] = {idx = 'faderlitcc', tsz = -1, col = colours.faderlitcc, btntxt = '0 0 0'}
  ptype_info[3] = {idx = 'faderlittr', tsz = -1, col = colours.faderlittr, btntxt = '0 0 0'}
  ptype_info[4] = {idx = 'faderlitac', tsz = -1, col = colours.faderlitac, btntxt = '0 0 0'}
  ptype_info[5] = {idx = 'faderlitint', tsz = -1, col = colours.faderlitint, btntxt = '0 0 0'}
  --ptype_info[99] = {idx = 'faderlitsl', tsz = -1, col = colours.faderlitint, btntxt = '0 0 0'}
  
  local remote_funcs = {}
      
  local log10 = function(x) return math.log(x, 10) end
   
  lvar.sscolbox_w = 8
  
  lvar.bmp = {}
  lvar.bmp.msg = 1000
  lvar.bmp.overlay = 1001
  lvar.bmp.tags = 1002
  
  lvar.dummyfaders = 32
  
  local FFX = nil
  local ofxguid = nil
  local template = {dirty = {},
                    pos = {},
                    sft = {},
                    eft = {}}

  --local overtemplates = {}
  local overtemplate = {dirty = {},
                        pos = {},
                        sft = {},
                        eft = {}}
  
  local globtemplate = {dirty = {},
                        pos = {},
                        sft = {},
                        eft = {}}

  local permatemplate = {dirty = {},
                         pos = {},
                         sft = {},
                         eft = {}}

  local strippertemplate = {dirty = {},
                            pos = {},
                            sft = {},
                            eft = {}}

  local rectemplate = {dirty = {},
                        pos = {},
                        sft = {},
                        eft = {}}

  local totemplate = {dirty = {},
                      pos = {},
                      sft = {},
                      eft = {}}

  local tmptoplayer = {dirty = {},
                      pos = {},
                      sft = {},
                      eft = {}}

  lvar.remap = {ctl = {}, ctl2 = {}}
  lvar.remap_active = false
  
  groupind_tab = {'Flash on/off', 'Swipe Up', 'Swipe Up/Dn', 'Blink Up/Dn', 'OFF'}
  lvar.groupind = {}
  lvar.groupind[1] = {type = 0, on = 0.1, off = 0.1, rep = 4}
  lvar.groupind[2] = {type = 0, on = 4, off = 0.1, rep = -1}

  local control_offs = 0
  
  local fadedel_s = 0.2
  local fadedel_e = fadedel_s + 0.4      
  
  lvar.scrubtime = 0.5
  
  lupd.update_gfx = true
  lupd.resize_display = true
  
  lvar.display_overlay_active = false
  lvar.display_overlay_inputonly = true
  lvar.display_overlay = {}
  lvar.display_overlay_idx = {}
  lvar.display_overlay_hold = 1.5
  
  lvar.startup = true
  lvar.globmapcnt = 15
  lvar.globmapnames = {}
  lvar.globmapdata = {}
  
  lvar.trackoffsetfollowsselected = false
  
  lvar.readparams = nil
  lvar.mainfade_time = 0.5
  lvar.mainfade_active = true
  lvar.initstage = 1
  lvar.inittime = {0.5,0.5,1}
  
  --update_init = true
  
  lvar.selectedfader = -1
                        
  lvar.scalemode_table = {1/8,1/7,1/6,1/5,1/4,1/3,1/2,1,2,3,4,5,6,7,8}
  
  lvar.deffloattime = 2
  lvar.livemode = 0
  lvar.showsetup = nil
  lvar.showglobalmap = true
  
  lvar.trackoffset_visibleonly = 0
  lvar.track_internal = 0
  lvar.track_ofs = 0
  lvar.track_internal_min = 0
  
  lvar.reptimer = 0.1
  
  lvar.MIoffs = 0
  lvar.MOoffs = 0
  lvar.SetupOffs = 0

  lvar.midiinput_gen = {}
  lvar.midiinput_ctl = {}
  lvar.midioutput_ctl = {}
  lvar.midimap = {}
  lvar.fcount = 32
  lvar.fadervaluefb = true
  lvar.fbcconseek = true
  lvar.autochase = true
  lvar.maxchasetime = 500
  lvar.createsends = true
  lvar.save_highlight = false
  lvar.saveglob_highlight = false
  lvar.saveperm_highlight = false
  
  lvar.resetfaderpostoprintccvalue = false
  
  lvar.displayswitch_w = 0
  lvar.display_mini = false
  
  local butt_h = 26
  lvar.autofocus = true
  
  lvar.mode = 3
  lvar.scribble_value_time = 1
  
  local contexts = {sliderctl = 0,
                    sliderctl_h = 1,
                    setupdrag = 2,
                    vscrollb = 3}
  
  pi = 3.14159265359
  
  local control_cnt = 32
  local control_max = 512

  lvar.bstate_delreset = {}
  lvar.flip = 0
  lvar.trigdelaytime = 0.2 --0.3
  
  lvar.timecodedisplay = false
  lvar.timecodedisplayformat = 0
  
  lvar.sysx_buf_timer = 0
  lvar.sysx_buf_time = 0.05
  
  lvar.automodeswitch = 0
  lvar.ctlgroup_select = 0
  lvar.ctlgroup_scribblemode = 0
  lvar.dnfs_time = 0.2
  
  lvar.groupcnt = 0
  
  local LBX_CC_TRACK = nil
  local LBX_CC_TRACK_GUID = nil
  local LBX_CTL_TRACK = nil
  local LBX_CTL_TRACK_GUID = nil
  local LBX_RR_TRACK = nil
  local LBX_RR_TRACK_GUID = nil
  local LBX_IN_TRACK = nil
  local LBX_IN_TRACK_GUID = nil
  local LBX_INPUT_TRACKS = nil
  local LBX_INPUT_TRACK_GUID = nil
  local LBX_INPUTCC_TRACKS = nil
  local LBX_INPUTCC_TRACK_GUID = nil
  local LBX_OUT_TRACKS = nil
  local LBX_OUT_TRACK_GUID = nil
  
  -------------------------------------------------
  --GMEM FADERBOX4
    
  lvar.gm_fb = {}
  
  lvar.gm_fb.fader_cnt = 9999 --;
  lvar.gm_fb.fader_val = 0 --;
  lvar.gm_fb.fader_val2 = 1024 --;
  lvar.gm_fb.fader_change = 2048 --;
  lvar.gm_fb.fader_relative = 3072 --;
  lvar.gm_fb.fader_input = 4096
  
  lvar.gm_fb.forcefeedback = 15050 --; 1
  lvar.gm_fb.ftouch_in_cc = 200000 --; //16384
  lvar.gm_fb.ftouch_in_note = 216384 --; //16384
  lvar.gm_fb.ftouch_on = 233000 --; //1024
  lvar.gm_fb.ftouch_off = 235000 --; //1024
  lvar.gm_fb.fadertouch = 237000 --; //1024
  lvar.gm_fb.faderfb = 239000 --; //1024
  
  lvar.gm_fb.fset = 241000 --; //1024
  lvar.gm_fb.fset_trigger51 = 241025
  lvar.gm_fb.fbuttype = 243000 --; //1024
  lvar.gm_fb.fbutstates = 245000 --; //1024
  lvar.gm_fb.but_onval = 250050 --; //4
  lvar.gm_fb.but_onval_override = 250055 --; //1024
  
  lvar.gm_fb.faderled_on = 255000 --; //1024
  lvar.gm_fb.bstate = 257000 --; //1024
  lvar.gm_fb.ignorebstate = 256999 --; //1
  lvar.gm_fb.isfader = 258100 --; //1024
  
  lvar.gm_fb.fbutstates_array = 3000000 --; //32*1024 = 32768
  lvar.gm_fb.fbutstates_array_ext = 3040000 --; //32*1024 = 32768
  lvar.gm_fb.fbutstate = 3040100 --; //1024
  lvar.gm_fb.bsarraytransfer = 3080000 --32
  lvar.gm_fb.bsarraytransferext = 3080032 --32
  lvar.gm_fb.bsarraytransfersscolor = 3080064 --32
  
  lvar.butstates_mult = 32 
  
  lvar.gm_fb.fbuttype2 = 247000 --; //1024
  lvar.gm_fb.fencoderres = 249000 --; //1024
  
  lvar.gm_fb.directin_cc = 300000 --; //16384 
  lvar.gm_fb.directin_pitch = 316384 --; //16384 
  lvar.gm_fb.directin_note = 332768 --; //16384 
  
  lvar.gm_fb.faderstate = 10000 --; //1024
  lvar.gm_fb.fflash_cnt = 11024 --1
  lvar.gm_fb.fflash = 11025 --1024
  lvar.gm_fb.fflash_data = 13000 --   0=type 1=ontime 2=offtime 3=duration
  
  lvar.props = {}
  lvar.props.visible = 13100
  
  lvar.fflashidx_type = 0
  lvar.fflashidx_ontime = 1
  lvar.fflashidx_offtime = 2
  lvar.fflashidx_duration = 3
  lvar.fflashidx_reset = 4
  lvar.fflashidx_invert = 5
        
  
  --//CC->Controller
  lvar.gm_fb.fdata_in = 100000 --; //2048
  lvar.gm_fb.fdata_type = 103000 --; //1024
  lvar.gm_fb.fdata = 105000 --; //1024
  lvar.gm_fb.fdata2 = 107000 --; //1024
  lvar.gm_fb.fdata_bus = 109000 --; //1024
  
  lvar.gm_fb.special_val_conv = 150000 --
  
  lvar.gm_fb.pos_time = 175000
  lvar.gm_fb.pos_beats = 175100
  lvar.gm_fb.pos_ccs = 175200
  lvar.gm_fb.pos_active = 175300
  
  lvar.gm_fb.gswitch47 = 8000047
  lvar.gm_fb.gswitch48 = 8000048
  lvar.gm_fb.gswitch50 = 8000050
  lvar.gm_fb.gswitch59 = 8000059
  
  -------------------------------------------------

  lvar.gm_cc = {}
  
  lvar.gm_cc.fdata_in_cc = 1000000 --; //size 16384
  lvar.gm_cc.fdata_in_note=1016384 --; //size 16384
  lvar.gm_cc.fdata_in_pitch=1032768 --; //size 128
  lvar.gm_cc.fdata_fader=1150000 --;
  lvar.gm_cc.fdata_fadermode=1152000 --; //1024
  lvar.gm_cc.fdata_14bit=1154000 --; //1024
  lvar.gm_cc.fdata_polarity=1156000 --; //1024
  lvar.gm_cc.fdata_bmode=1158000 --; //1024
  lvar.gm_cc.fdata_fine=1160000 --; //1024
  lvar.gm_cc.fdata_fineval=1162000 --; //1024
  lvar.gm_cc.fdata_sendcconrel=260000 --; //1
  lvar.gm_cc.fdata_removedups=260001 --; //1
  
  --pass through notes + pitch messages on channel N - N = 1-16 or -1 = all channels, 0 = off
  lvar.gm_cc.fdata_notesthru = 1163025 --; //4
  
  lvar.fineamt = 1024
  lvar.fineamt_idx = 1163100
  lvar.enctouch = 1163110
    
  lvar.gm_cc.fbutstate = 3040100 --; //1024
  --lvar.gm_cc.fencoderres = 249000 --; //1024 -- set up via faderbox
  
  lvar.man_send = 1998998
  lvar.man_val = 1998999
  lvar.man_send2 = 1998996
  lvar.man_val2 = 1998997
  lvar.man_msg = 1998995
  
  -------------------------------------------------
  
  lvar.gm_sysx = {}
  
  lvar.gm_sysx.msg_ready = 1999997
  lvar.gm_sysx.msg_bus = 1999998
  lvar.gm_sysx.msg_cnt = 1999999
  lvar.gm_sysx.msg_len = 1999500
  lvar.gm_sysx.msg_lentot = 1999996
  lvar.gm_sysx.sysx_msg = 2000000

  lvar.gm_sysx.handshake_len = 2009999
  lvar.gm_sysx.handshake_msg = 2010000
  
  -------------------------------------------------
  
  lvar.gm_ccstamp = {}
  
  lvar.gm_ccstamp.active = 399999
  lvar.gm_ccstamp.cc_active = 400000
  lvar.gm_ccstamp.cc_val = 400128
  lvar.gm_ccstamp.defcc_val = 400256
  lvar.gm_ccstamp.cc_enabled = 400384
  
  lvar.ccstamp_active = 0
  
  -------------------------------------------------
  
  lvar.rrrec_data = {}
  lvar.rrrec_data.tracknum = 3049990
  lvar.rrrec_data.itemnum = 3049991
  lvar.rrrec_data.takenum = 3049992
  lvar.rrrec_data.slotinfo_cnt = 3049993
  lvar.rrrec_data.mutedindexes_cnt = 3049994
  lvar.rrrec_data.mutednotesindexes_cnt = 3049995
  lvar.rrrec_data.dataset = 3049998
  lvar.rrrec_data.resetdata = 3049999
  lvar.rrrec_data.slotinfo = 3050000 --500
  lvar.rrrec_data.slotinfo_pp = 3050500 --500
  lvar.rrrec_data.mutedindexes = 3051000 -- at least 49000
  lvar.rrrec_data.mutednotesindexes = 3100000 -- at least 2000

  lvar.rrrec_data.notes_played = 8388108 -- RRData area - Notes played into RR - used for triggering mutes
  lvar.rrrec_data.cc64_played = 8388109 -- RRData area - CC64 played into RR - used for triggering mutes
  lvar.rrrec_data.cc1_played = 8388110 -- RRData area - CC played into RR - used for triggering mutes
  lvar.rrrec_data.pb_played = 8388111 -- RRData area - PB played into RR - used for triggering mutes

  function ShowVSS(show)
    if show == nil then show = lvar.virtualss_active end
    
    if show then
      local win = reaper.JS_Window_Find('LBX_SK2_VirtualSS', true)
      if not win then
        local fn = paths.resource_path..'LBX_SK2_VirtualSS.lua'
        local commid = reaper.AddRemoveReaScript(true, 0, fn, true)
        --lvar.virtualSScommid = reaper.ReverseNamedCommandLookup(tonumber(commid))
        reaper.Main_OnCommand(commid,-1)
        TemplateChanged()
      end
    else
      local win = reaper.JS_Window_Find('LBX_SK2_VirtualSS', true)
      if win then
        reaper.JS_Window_Destroy(win)
      end
    end
  end

  function OpenManual()
    local manpath = paths.resource_path..'SK2 Manual.pdf'
    if reaper.file_exists(manpath) then
      if string.match(reaper.GetOS(), "Win") then
        manpath = string.gsub(manpath,'/','\\')
        reaper.ExecProcess('cmd.exe /C start "" "' .. manpath ..'"', 0)
        --os.execute('start "" "' .. manpath )
      elseif string.match(reaper.GetOS(), "OSX") or string.match(reaper.GetOS(), "macOS") then
        os.execute('open "" "' .. manpath ) 
      else --Linux
        os.execute('xdg-open ' .. manpath ) 
      end
    else
      reaper.MB('Sorry - Cannot find manual PDF','Error opening SK2 manual',0)
    end
  end
  
  -------------------------------------------------

  local function GetMW(v)
    local m = 1
    if v < 0 then m = -1 end
    v = math.max(math.floor(math.abs(v/120)),1)
    return v*m
  end
  
  function LoadLocation()
    if reaper.JS_Window_SetLong then
      local fn = paths.resource_path..'location.txt'
      if reaper.file_exists(fn) then
        local flines = io.lines
        local data = {}
        local match = string.match
        
        for line in flines(fn) do
          local idx, val = match(line,'^%[(.-)%](.*)') --decipher(line)
          if idx then
            data[idx] = val
          end
        end
        
        local x = tonumber(data['x'])
        local y = tonumber(data['y'])
        local w = tonumber(data['w'])
        local h = tonumber(data['h'])
        local frameless = tonumber(data['frameless'])
        local hide = tonumber(data['hide'])
        
        local win = reaper.JS_Window_Find(lvar.wintit, true)
        if win then
          if frameless == 1 then
            local style = reaper.JS_Window_GetLong(win, 'STYLE')
            if style then
              style = style & (0xFFFFFFFF - 0x00C40000)
              reaper.JS_Window_SetLong(win, "STYLE", style)
            end
          end
          if x and y and w and h then
            reaper.JS_Window_SetPosition(win, x, y, w, h)
          end
          if hide == 1 then
            reaper.JS_Window_Show(win, 'HIDE')
          end
        end
        return true
      end
    end
  end
    
  --[[function PType_SetCols()
    if #ptype_info > 0 then
      ptype_info[1].dimcol = colours.faderdim
      ptype_info[2].dimcol = colours.faderdimcc
      ptype_info[3].dimcol = colours.faderdimtr
      ptype_info[4].dimcol = colours.faderdimac
      ptype_info[5].dimcol = colours.faderdimint
    end
  end]]
  
  function GetAllTrackFXGUIDs()
    local guids = {}
    for t = 0, reaper.GetNumTracks()-1 do
      local track = GetTrack(t)
      for i = 0, reaper.TrackFX_GetCount(track)-1 do
        local guid = reaper.TrackFX_GetFXGUID(track, i)
        local tguid = reaper.GetTrackGUID(track)
        guids[guid] = {trn = t, tguid = tguid, fxn = i}
      end
    end
    return guids
  end
  
  --returns template, glob_flag
  local function GetTemplate(i, checki, ignore_to, ignore_toptmp)
    
    --[[if not ignore_toptmp and lvar.tmptoplayer_active and lvar.chanstrips.idx[i] then
      return tmptoplayer, 6
    elseif not ignore_to and totemplate.pos[i] then
      return totemplate, 5    
    elseif permatemplate.pos[i] then
      return permatemplate, 3
    elseif globtemplate.pos[i] and lvar.showglobalmap then
      return globtemplate, 2
    elseif lvar.overtemplate_active and template.layer and template.layer[lvar.overtemplate] and template.layer[lvar.overtemplate].pos[i] then
      return template.layer[lvar.overtemplate], 4
    elseif not checki or template.pos[i] then
      return template, 1
    end]]
    
    local p = lvar.currentglobalmap
    if not ignore_to and lvar.rec_mapactiveenvstofaders --[[and lvar.recmode == 1]] and rectemplate.pos[i] then
      return rectemplate, 8
    elseif not ignore_to and lvar.strippertemplate_active and strippertemplate.pos[i] then
      return strippertemplate, 7
    elseif not ignore_toptmp and lvar.tmptoplayer_active and lvar.chanstrips.idx[i] then
      return tmptoplayer, 6
    elseif not ignore_to and totemplate.pos[i] then
      return totemplate, 5  
    elseif permatemplate.pos[i] then
      return permatemplate, 3
    elseif (globtemplate.pos[i] or (lvar.globmapdata[p] and lvar.globmapdata[p].solo == 1)) and lvar.showglobalmap then
      return globtemplate, 2
    elseif lvar.overtemplate_active and template.layer and template.layer[lvar.overtemplate] and template.layer[lvar.overtemplate].pos[i] then
      return template.layer[lvar.overtemplate], 4
    elseif not checki or template.pos[i] then
      return template, 1
    end
    
  end

  local function GetTemplatePos(i, checki, ignore_to, ignore_toptmp)

    --[[if not ignore_toptmp and lvar.tmptoplayer_active and lvar.chanstrips.idx[i] then
      return tmptoplayer.pos[i], 6
    elseif not ignore_to and totemplate.pos[i] then
      return totemplate.pos[i], 5    
    elseif permatemplate.pos[i] then
      return permatemplate.pos[i], 3
    elseif globtemplate.pos[i] and lvar.showglobalmap then
      return globtemplate.pos[i], 2
    elseif lvar.overtemplate_active and template.layer and template.layer[lvar.overtemplate] and template.layer[lvar.overtemplate].pos[i] then
      return template.layer[lvar.overtemplate].pos[i], 4
    elseif not checki or template.pos[i] then
      return template.pos[i], 1
    end]]

    if not ignore_to and lvar.rec_mapactiveenvstofaders --[[and lvar.recmode == 1]] and rectemplate.pos[i] then
      return rectemplate.pos[i], 8
    elseif not ignore_to and lvar.strippertemplate_active and strippertemplate.pos[i] then
      return strippertemplate.pos[i], 7
    elseif not ignore_toptmp and lvar.tmptoplayer_active and lvar.chanstrips.idx[i] then
      return tmptoplayer.pos[i], 6
    elseif not ignore_to and totemplate.pos[i] then
      return totemplate.pos[i], 5    
    elseif permatemplate.pos[i] then
      return permatemplate.pos[i], 3
    elseif (globtemplate.pos[i] or (lvar.globmapdata[p] and lvar.globmapdata[p].solo == 1)) and lvar.showglobalmap then
      return globtemplate.pos[i], 2
    elseif lvar.overtemplate_active and template.layer and template.layer[lvar.overtemplate] and template.layer[lvar.overtemplate].pos[i] then
      return template.layer[lvar.overtemplate].pos[i], 4
    elseif not checki or template.pos[i] then
      return template.pos[i], 1
    end
    
  end
  
  function SetTrackSendTab()
  
    tab_trsnds = {}
    
    for s = 1, lvar.trsendcnt do
      tab_trsnds[(s-1)*3+1] = 'Send '..string.format('%i',s)..' Volume'
      tab_trsnds[(s-1)*3+2] = 'Send '..string.format('%i',s)..' Pan'
      tab_trsnds[(s-1)*3+3] = 'Send '..string.format('%i',s)..' Mute'      
    end
    
  end

  function GMFB_FFlashData(typ, on_time, off_time, duration, invert)
    local gmem = reaper.gmem_write
    gmem(lvar.gm_fb.fflash_data+lvar.fflashidx_type, typ)
    gmem(lvar.gm_fb.fflash_data+lvar.fflashidx_ontime, on_time)
    gmem(lvar.gm_fb.fflash_data+lvar.fflashidx_offtime, off_time)
    gmem(lvar.gm_fb.fflash_data+lvar.fflashidx_duration, duration)
    gmem(lvar.gm_fb.fflash_data+lvar.fflashidx_invert, invert or 0)
    if duration ~= -1 then
      if typ == 0 then
        lvar.fflash_duration = on_time * math.ceil(duration/2) + off_time * math.floor(duration/2)
      elseif typ == 1 then
        lvar.fflash_duration = 4*on_time*duration
      elseif typ == 2 then
        lvar.fflash_duration = 9*on_time*duration
      elseif typ == 3 then
        lvar.fflash_duration = 9*on_time*duration
      end
    else
      lvar.fflash_duration = -1
    end
  end
  
  function GMFB_ButStates_Reset()
    --local t = reaper.time_precise()
    local gmem = reaper.gmem_write
    for i = 0, 32*1024 do
      gmem(lvar.gm_fb.fbutstates_array+i, -1)
    end
    --DBG(reaper.time_precise()-t)
  end

  function GMFB_LEDOn_Reset()
    local gmem = reaper.gmem_write
    for i = 0, 1024 do
      gmem(lvar.gm_fb.faderled_on+i, 0)
    end
  end

  function GMFB_FaderChange_Reset()
    local gmem = reaper.gmem_write
    for i = 0, 1024 do
      gmem(lvar.gm_fb.fader_change+i, -1)
    end
  end
  
  function GMCC_ButState_Reset()
    local gmem = reaper.gmem_write
    for i = 0, 1023 do
      gmem(lvar.gm_cc.fbutstate+i, 0)
    end
  end
    
  
  function GMCCSTAMP_SetActive(active)
    local gmem = reaper.gmem_write
    gmem(lvar.gm_ccstamp.active, active)
    lvar.ccstamp_active = active
  end
  
  function GMCCSTAMP_SetCCs()
    local gmem = reaper.gmem_write
    --DBG('RESET')
    for i = 0, 127 do
      gmem(lvar.gm_ccstamp.cc_val+i, -1)
      gmem(lvar.gm_ccstamp.defcc_val+i, -1)
    end
  end

  function GMCCSTAMP_Reset()
    local gmem = reaper.gmem_write
    for i = 0, 127 do
      gmem(lvar.gm_ccstamp.cc_active+i, -1)
    end
  end

  function GMCCSTAMP_ResetEnabled()
    --enable all
    local gmem = reaper.gmem_write
    for i = 0, 127 do
      gmem(lvar.gm_ccstamp.cc_enabled+i, 1)
    end
  end
  
  function GMCCSTAMP_SetCCVal(cc, val)
    local gmem = reaper.gmem_write
    gmem(lvar.gm_ccstamp.cc_val+cc, val)
  end

  function GMCCSTAMP_SetCCActive(cc, val)
    local gmem = reaper.gmem_write
    --DBG(cc..'   '..tostring(val))
    gmem(lvar.gm_ccstamp.cc_active+cc, 1)
    --DBG(cc..'  '..tostring(val)..'   '..lvar.gm_ccstamp.cc_val+cc)
    if val then  
      gmem(lvar.gm_ccstamp.cc_val+cc, val)
    end
  end
  
  function GMFB_fflash_reset()
    local gmem = reaper.gmem_write
    for i = 0, 1023 do
      gmem(lvar.gm_fb.fflash + i,-1)
    end  
  end
  
  --f = zero based
  function GMFB_touchfader(f, v)
    local gmem = reaper.gmem_write
    gmem(lvar.gm_fb.fadertouch + f,v)
  end

  function GMFB_memset_37()
    local gmem = reaper.gmem_write
    for i = 0, 16383 do
      gmem(lvar.gm_fb.ftouch_in_cc + i,-1)
      gmem(lvar.gm_fb.ftouch_in_note + i,-1)
      gmem(lvar.gm_fb.directin_cc + i,-1)
      gmem(lvar.gm_fb.directin_pitch + i,-1)
      gmem(lvar.gm_fb.directin_note + i,-1)
    end
    for i = 0, 1023 do
      gmem(lvar.gm_fb.ftouch_on + i,-1)
      gmem(lvar.gm_fb.ftouch_off + i,-1)
      gmem(lvar.gm_fb.fdata_type + i,-1)
      gmem(lvar.gm_fb.fdata + i,-1)
      gmem(lvar.gm_fb.fdata_bus + i,-1)
      gmem(lvar.gm_fb.fbuttype2 + i,0)
      gmem(lvar.gm_fb.isfader + i, 0) 
      gmem(lvar.gm_fb.but_onval_override + i, -1)
    end
    for i = 0, 3 do
      gmem(lvar.gm_fb.but_onval + i,127)
    end
  end

  function GMFB_memset_39()
    local gmem = reaper.gmem_write
    for i = 0, 2047 do
      gmem(lvar.gm_fb.fdata_in + i,-1)
    end
    for i = 0, 1023 do
      gmem(lvar.gm_fb.fdata2 + i,-1)
      gmem(lvar.gm_fb.fadertouch + i,0)
      gmem(lvar.gm_fb.fbuttype + i,-1)
      gmem(lvar.gm_fb.fbutstates + i,-1)
      gmem(lvar.gm_fb.fencoderres + i,-1)
    end
  end

  function GMCC_memset_37()
    local gmem = reaper.gmem_write
    for i = 0, 16383 do
      gmem(lvar.gm_cc.fdata_in_cc + i,-1)
      gmem(lvar.gm_cc.fdata_in_note + i,-1)
    end
    for i = 0, 128 do
      gmem(lvar.gm_cc.fdata_in_pitch + i,-1)
    end    
    for i = 0, 1023 do
      gmem(lvar.gm_cc.fdata_fadermode + i,0)
    end
  end

  function GMCC_memset_39()
    local gmem = reaper.gmem_write

    for i = 0, 1023 do
      gmem(lvar.gm_cc.fdata_fader + i,-1)
      gmem(lvar.gm_cc.fdata_14bit + i,0)
      gmem(lvar.gm_cc.fdata_polarity + i,0)
      gmem(lvar.gm_cc.fdata_bmode + i,0)
      gmem(lvar.gm_cc.fdata_fine + i,0)
      gmem(lvar.gm_cc.fdata_fineval + i,-1)
    end  
  end
  
  ------------------------------------------- --
  -- Pickle.lua
  -- A table serialization utility for lua
  -- Steve Dekorte, http://www.dekorte.com, Apr 2000
  -- (updated for Lua 5.3 by me)
  -- Freeware
  ----------------------------------------------
  
  function pickle(t)
  return Pickle:clone():pickle_(t)
  end
  
  Pickle = {
  clone = function (t) local nt={}; for i, v in pairs(t) do nt[i]=v end return nt end
  }
  
  function Pickle:pickle_(root)
  if type(root) ~= "table" then
  error("can only pickle tables, not ".. type(root).."s")
  end
  self._tableToRef = {}
  self._refToTable = {}
  local savecount = 0
  self:ref_(root)
  local s = ""
  
  while #self._refToTable > savecount do
  savecount = savecount + 1
  local t = self._refToTable[savecount]
  s = s.."{\n"
  
  for i, v in pairs(t) do
  s = string.format("%s[%s]=%s,\n", s, self:value_(i), self:value_(v))
  end
  s = s.."},\n"
  
  end
  return string.format("{%s}", s)
  end
  
  function Pickle:value_(v)
  local vtype = type(v)
  if vtype == "string" then return string.format("%q", v)
  elseif vtype == "number" then return v
  elseif vtype == "boolean" then return tostring(v)
  elseif vtype == "table" then return "{"..self:ref_(v).."}"
  else error("pickle a "..type(v).." is not supported")
  end
  end
  
  function Pickle:ref_(t)
  local ref = self._tableToRef[t]
  if not ref then
  if t == self then error("can't pickle the pickle class") end
  table.insert(self._refToTable, t)
  ref = #self._refToTable
  self._tableToRef[t] = ref
  end
  return ref
  end
  
  ----------------------------------------------
  -- unpickle
  ----------------------------------------------
  
  function unpickle(s)
  if s == nil or s == '' then return end
  if type(s) ~= "string" then
  error("can't unpickle a "..type(s)..", only strings")
  end
  local gentables = load("return "..s)
  if gentables then
    local tables = gentables()
  
    if tables then
      for tnum = 1, #tables do
      local t = tables[tnum]
      local tcopy = {}; for i, v in pairs(t) do tcopy[i] = v end
      for i, v in pairs(tcopy) do
      local ni, nv
      if type(i) == "table" then ni = tables[i[1]] else ni = i end
      if type(v) == "table" then nv = tables[v[1]] else nv = v end
      t[i] = nil
      t[ni] = nv
      end
      end
      return tables[1]
    end
  else
    --error
  end
  end
  
  ------------------------------------------------------------
  
  local function round(num, idp)
    --if tonumber(num) == nil then return num end    
    local mult = 10^(idp or 0)
    return math.floor(num * mult + 0.5) / mult
  end
  
  local function CheckAIGUID()
    local track = GetTrack(LBX_AI_TRACK)
    if track and reaper.GetTrackGUID(track) == LBX_AI_TRACK_GUID then
      CTAIMISSING = nil
      return true, track
    else
      LBX_AI_TRACK = nil
      --local track = GetCCTrack()
      local track = GetAITrack()
      lvar.getfound = true
      if track then CTAIMISSING = nil else CTAIMISSING = true end
      return false, track
    end 
  end
  
  local function SetFaderBoxVal(i, v, track)
  
    if LBX_CTL_TRACK then
   
      local gmem = reaper.gmem_write
      gmem(lvar.gm_fb.fader_val + i-1, v)
      gmem(lvar.gm_fb.fader_val2 + i-1, v)
    end
      
  end
  
  function Internal_VisibleTracks()
  
    local param = 'B_SHOWINTCP'
    if lvar.trackoffset_visibleonly == 2 then
      param = 'B_SHOWINMIXER'
    end

    local tab = {}
    if LBX_FOL_TRACK then
      local ttrn
      if lvar.trackoffsetfollowsselected then
        ttrn = lvar.track_ofs
        if lvar.track_ofs < LBX_FOL_TRACK and ttrn >= LBX_FOL_TRACK then
          ttrn = ttrn + lvar.ctltracks.count
        end 
      else
        ttrn = lvar.track_internal
        if ttrn >= LBX_FOL_TRACK then
          ttrn = ttrn + lvar.ctltracks.count
        end 
      end
      local trn = ttrn
      local tc = reaper.CountTracks(0)
      local tend
      for t = 1, 32 do
        local track = GetTrack(trn)
        if track then
          local vis = reaper.GetMediaTrackInfo_Value(track, param)
          --DBG(trn..' ** '..tostring(vis))
          while vis == 0 and trn < tc do
            trn = trn + 1
            if trn >= LBX_FOL_TRACK then
              trn = trn + lvar.ctltracks.count
            end
            if trn < tc then
              track = GetTrack(trn)
              vis = reaper.GetMediaTrackInfo_Value(track, param)
            end
          end
        end
        
        if trn > tc then
          tend = t
          break
        else
          tab[t] = trn
        end
        trn = trn + 1
        if trn >= LBX_FOL_TRACK and trn <= LBX_FOL_TRACK + lvar.ctltracks.count then
          trn = LBX_FOL_TRACK + lvar.ctltracks.count --trn + lvar.ctltracks.count
        end 
      end
      --[[if tend and tend <= 32 then
        for t = tend, 32 do
          tab[t] = tc+1
        end
      end]]
    end
    return tab
  
  end
  
  local function Internal_GetTrack(trn, tmppos)
    local ttrn, trackD
    if trn then
      if trn <= -1 then
        if trn == -1 then
          trackD = reaper.GetSelectedTrack2(0, 0, true)
          if trackD then
            ttrn = reaper.GetMediaTrackInfo_Value(trackD, 'IP_TRACKNUMBER')
          end
        elseif trn == -2 then
          if lvar.trackoffset_visibleonly > 0 then
            ttrn = lvar.tracks_vis[tmppos.troff+1] or 999999
          else
            if lvar.trackoffsetfollowsselected then
              ttrn = lvar.track_ofs + tmppos.troff            
              if lvar.track_ofs < LBX_FOL_TRACK and ttrn >= LBX_FOL_TRACK then
                ttrn = ttrn + lvar.ctltracks.count
              end 
            else
              ttrn = lvar.track_internal + tmppos.troff
              if ttrn >= LBX_FOL_TRACK then
                ttrn = ttrn + lvar.ctltracks.count
              end 
            end
          end
          trackD = GetTrack(ttrn)
        end
      else
        trackD = GetTrack(trn)
        ttrn = trn
      end
    end
    return ttrn, trackD
  end
  
  local function Internal_GetTrack2(tmppos)
    local ttrn
    if LBX_FOL_TRACK then
      if lvar.trackoffset_visibleonly > 0 then
        ttrn = lvar.tracks_vis[tmppos.troff+1] or 999999
      else
        if lvar.trackoffsetfollowsselected then
          ttrn = lvar.track_ofs + tmppos.troff
          if lvar.track_ofs < LBX_FOL_TRACK and ttrn >= LBX_FOL_TRACK then                  
            ttrn = ttrn + lvar.ctltracks.count
          end                               
        else
          ttrn = lvar.track_internal + tmppos.troff 
          if ttrn >= LBX_FOL_TRACK then                
            ttrn = ttrn + lvar.ctltracks.count
          end 
        end
      end
    end
    return ttrn
  end
    
  local function normalize(min, max, val)
    if min and max and val then
      return (val - min)/(max - min)
    else
      return 0
    end
  end
  
  local function A_ReadParamVals(upd_fb,upd_fb2,force)
    --DBGOut('ReadParamVals')
    
      local txt = ''
      if not LBX_CTL_TRACK then return end
      --prevent constant updating when quickly scrolling through tracks
      --DBG(lvar.readparams)
      if lvar.sk2data_setdata_delayaffectsfeedback and lvar.mode == 3 and reaper.time_precise() < (lvar.sk2data_setdata_delay or 0) then return end
      
      local rt = reaper.time_precise()
      local ffxtrack, ffxtake
      if FFX then
        ffxtrack = GetTrack(FFX.trn)
        ffxtake = FFX.take
        if recmode == 0 then
          if (ffxtrack and FFX.trguid ~= reaper.GetTrackGUID(ffxtrack)) or not ffxtrack then
            local ret
            FFX, ret = GetFocusedFX(true, FFX)
            if ret == 1 and FFX then
              ffxtrack = GetTrack(FFX.trn)
            elseif ret == 2 and FFX then
              ffxtrack = GetTrack(FFX.trn)
            end
          end 
        end
      end
      
      --if track and FFX then
      local ctltrack = GetTrack(LBX_CTL_TRACK)
  
      if ctltrack then  
  
        local blast
        local gmem_rd = reaper.gmem_read
        local gmem = reaper.gmem_write
        local lvar = lvar
        
        --useful way to disable feedback when track in read mode...
        
        --[[if not lvar.readparams then
          gmem(lvar.gm_fb.forcefeedback,1)
        end]] --do after readparams?
        
        for i = 1, lvar.fcount do
          --gmem(lvar.gm_fb.fset+(i-1),-1)
          local bchange
          
          local tmp, gflag, dispval, fv_force
          
          tmp, gflag = GetTemplate(i)
          local tmppos = tmp.pos[i]
          
          if tmppos --[[and gmem_rd(lvar.gm_fb.fadertouch+i-1) == 0]] then
            
            local dispval, ret
            
            if tmppos.ptype == ptype.host and (ffxtrack or ffxtake or tmppos.globalhost == 1) 
               then
  
              local fxnum 
              if FFX then
                fxnum = FFX.fxnum
              end
              local pnum = tmppos.pnum
              
              --[[local ok = true
              if tmppos.globalhost == 1 then
                if (tmppos.ptrack or -99) ~= -99 then
                  ffxtrack = GetTrack(tmppos.ptrack)
                  if ffxtrack and reaper.GetTrackGUID(ffxtrack) == tmppos.ptrguid and 
                     reaper.TrackFX_GetFXGUID(ffxtrack, tmppos.pfxnum) == tmppos.pfxguid then
                    fxnum = tmppos.pfxnum
                  else
                    ok = false
                    --find FX
                  end
                else
                  ok = false
                end
              end]]
              
              local ok = true
              if tmppos.globalhost == 1 then
                ffxtake = nil
                if (tmppos.ptrack or -99) == -100 then
                  --missing fx
                  ok = false
                else
                  if (tmppos.ptrack or -99) ~= -99 then
                    ffxtrack = GetTrack(tmppos.ptrack)
                    
                    if ffxtrack and (tmppos.ptrack == 0 or reaper.GetTrackGUID(ffxtrack) == tmppos.ptrguid) and 
                       reaper.TrackFX_GetFXGUID(ffxtrack, tmppos.pfxnum) == tmppos.pfxguid then
                      fxnum = tmppos.pfxnum
                    else
                      ok = false
                      --find FX
                      local trn, trguid, fxnum_ = FindFX(ffxtrack, tmppos.ptrguid, tmppos.pfxguid)
                      if trguid then
                        tmppos.ptrack = trn
                        tmppos.ptrguid = trguid
                        tmppos.pfxnum = fxnum_
                        ffxtrack = GetTrack(trn)
                        fxnum = fxnum_
                        ok = true
                      else
                        tmppos.ptrack = trn -- -100
                        tmppos.pfxnum = fxnum_ -- -1
                      end
                    end
                  else
                    ok = false
                  end
                end
                
              elseif tmppos.globalhost == 2 then
                ffxtake = nil
                ffxtrack = reaper.GetSelectedTrack2(0, 0, true)
                if ((tmppos.ptrack or -99) == -100 and lvar.readparams) 
                   and ffxtrack == lvar.ofxtrack then
                  --missing fx
                  ok = false
                  
                else
                  if (tmppos.ptrack or -99) ~= -99 then
                    --ffxtrack = reaper.GetSelectedTrack2(0, 0, true)
                    if ffxtrack and reaper.TrackFX_GetFXGUID(ffxtrack, tmppos.pfxnum) == tmppos.pfxguid then
                    --[[if (tmppos.ptrack == 0 or reaper.GetTrackGUID(ffxtrack) == tmppos.ptrguid) and 
                       reaper.TrackFX_GetFXGUID(ffxtrack, tmppos.pfxnum) == tmppos.pfxguid then]]
                      fxnum = tmppos.pfxnum
                    else
                      ok = false
                      --find FX
                      --local track = GetTrack(FFX.trn)
                      --DBG('HHH'..tmppos.pfxguid)
                      local trn, trguid, fxnum_, fxguid_ = FindFX2(ffxtrack, tmppos.pfxmodule, tmppos.pfxguid)
                      if trguid then
                        tmppos.ptrack = trn
                        tmppos.ptrguid = trguid
                        tmppos.pfxnum = fxnum_
                        tmppos.pfxguid = fxguid_
                        ffxtrack = GetTrack(trn)
                        fxnum = fxnum_
                        ok = true
                      else
                        tmppos.ptrack = trn -- -100
                        tmppos.pfxnum = fxnum_ -- -1
                      end
                    end
                  else
                    ok = false
                  end
                end
                if not ok then
                  --Plug not found on selected track
                  if tmppos.val ~= -1 or not lvar.readparams then

                    tmppos.val = -1
                    tmp.dirty[i] = true
                    lupd.update_faderbar = true

                    if upd_fb == true or not lvar.readparams then 
                      SetFaderBoxVal(i, 0)
                    end
                    local tn = '<No FX>'--..(tmppos.tmpname or tmppos.name or tmppos.pname)
                    if tmppos.fxslot_name ~= tn then
                      tmppos.fxslot_name = tn
                      tmppos.tmpname = tmppos.name
                      tmppos.name = tn
                    end
                    
                    tmppos.dispval = ' '
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      dispval = tmppos.dispval
                    end
                  end
                  
                elseif tmppos.fxslot_name then
                  tmppos.fxslot_name = nil
                  tmppos.name = tmppos.tmpname
                  if lvar.stripperlink then
                    reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', tmppos.name or tmppos.pname, false)
                  end
                  tmppos.tmpname = nil
                  tmppos.dispval = ' '
                  if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                    dispval = tmppos.dispval
                  end
                end
              end
              
              --[[if not ok then
                DBG(i..'  NOT OK'..tmppos.ptrack)
              end]]
              
              --local val = round(reaper.TrackFX_GetParamNormalized(ffxtrack, fxnum, pnum),5)
              if ok then
                --[[if tmppos.globalhost == 2 then
                DBG(ffxtrack)
                end]]
                
                local GetParamNormalized, GetFormattedParamValue, GetParamName, pointer
                if not ffxtake then
                  GetParamName = reaper.TrackFX_GetParamName
                  GetParamNormalized = reaper.TrackFX_GetParamNormalized
                  GetFormattedParamValue = reaper.TrackFX_GetFormattedParamValue
                  pointer = ffxtrack
                else
                  GetParamName = reaper.TakeFX_GetParamName
                  GetParamNormalized = reaper.TakeFX_GetParamNormalized
                  GetFormattedParamValue = reaper.TakeFX_GetFormattedParamValue
                  pointer = ffxtake
                end
                if pointer then
                  _, tmppos.host_pname = GetParamName(pointer, fxnum, pnum)
                  if ctl_template.fader[i].lmode ~= 4 then
                    if tmppos.polarity ~= 1 then
                      local val = GetParamNormalized(pointer, fxnum, pnum) * 16383
                      local ret, dv = GetFormattedParamValue(pointer, fxnum, pnum, '')
                      if tmppos.val ~= val or dv ~= tmppos.dispval or not lvar.readparams then
                        tmppos.val = val
                        tmp.dirty[i] = true
                        lupd.update_faderbar = true
                        
                        if upd_fb == true or not lvar.readparams then
                          --if reaper.GetPlayState() == 0 or lvar.fbcconseek == false then
                            local min,max = tmppos.min or 0, tmppos.max or 1
                            local val2 = val/16383
                            val2 = math.min(math.max((val2-min)/(max-min),0),1)*16383
                          
                            if ctl_template.fader[i].lmode ~= 0 then
                              if reaper.time_precise() > (tmppos.lasttweaked or -1)+lvar.encoder_host_delay then
                                SetFaderBoxVal(i, val2)
                              end
                            else
                              SetFaderBoxVal(i, val2)
                            end
                          --end
                        end
                        
                        tmppos.dispval = dv
                        if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                          dispval = dv
                        end
                      end
                    else
                      local val = 16383 - (GetParamNormalized(pointer, fxnum, pnum) * 16383)
                      local ret, dv = GetFormattedParamValue(pointer, fxnum, pnum, '')
                      if tmppos.val ~= val or dv ~= tmppos.dispval or not lvar.readparams then
                        tmppos.val = val
                        tmp.dirty[i] = true
                        lupd.update_faderbar = true
    
                        if upd_fb == true or not lvar.readparams then
                          --if reaper.GetPlayState() == 0 or lvar.fbcconseek == false then
                            local min,max = tmppos.min or 0, tmppos.max or 1
                            local val2 = (16383-val)/16383
                            val2 = 16383-(math.min(math.max((val2-min)/(max-min),0),1)*16383)
                          
                            if ctl_template.fader[i].lmode ~= 0 then
                              if reaper.time_precise() > (tmppos.lasttweaked or -1)+lvar.encoder_host_delay then
                                SetFaderBoxVal(i, val2)
                              end
                            else
                              SetFaderBoxVal(i, val2)
                            end
                          --end
                        end
    
                        tmppos.dispval = dv
                        if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                          dispval = dv
                        end
                      end
                    end
                  else
                    --button
                    --local val = reaper.TrackFX_GetParamNormalized(ffxtrack, fxnum, pnum)
                    local val = GetParamNormalized(pointer, fxnum, pnum)
                    --DBG(i..'  '..val..'  '..fxnum..'  '..pnum)
                    --if val ~= tmppos.bstate or not lvar.readparams then
                    if val ~= tmppos.oldval or not lvar.readparams then
                      tmppos.oldval = val
                      bchange = val
                      
                      tmppos.bstate = val
                      gmem(lvar.gm_fb.bstate+(i-1), val)
    
                      --local vval = round(val,5)
                      local vval = math.ceil(tonumber(val*100000))/100000
  
                      local donotupdatess
                      --DBG(i..'  '..tostring(tmppos.bpos)..'  '..vval)
                      if tmppos.butstates_arrayidx and tmppos.butstates_arrayidx[vval] then
                        tmppos.bpos = tmppos.butstates_arrayidx[vval]
                        if tmppos.buttype == 0 or (tmppos.buttype == 4 and tmppos.bpos > 1) and tmppos.actionmon == 1 then
                          gmem(lvar.gm_fb.bstate+(i-1), 1)
                          val = 1
                        elseif tmppos.actionmon == 0 or tmppos.buttype == 4 then
                          gmem(lvar.gm_fb.bstate+(i-1), 0)
                          val = 0
                          bchange = 0
                          donotupdatess = true
                        end
                      else--if tmppos.buttype == 0 then
                        gmem(lvar.gm_fb.bstate+(i-1), 0)
                        tmppos.bpos = 1
                        val = 0
                        bchange = 0
                        donotupdatess = true
                      end
                      
                      --Send feedback
                      if upd_fb == true or not lvar.readparams then
                        --[[if tmppos.buttype == 0 then
                          val = 0
                        end]]
                        gmem(lvar.gm_fb.fset+(i-1),math.floor(val*127)|16384)
                        blast = true
                        
                        --local ret, dv = reaper.TrackFX_GetFormattedParamValue(ffxtrack, fxnum, pnum, '')
                        local ret, dv = GetFormattedParamValue(pointer, fxnum, pnum, '')
                        tmppos.dispval = dv
                        
                        if not donotupdatess and (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb and rt >= (tmppos.donotflashscribble or 0) then
                          dispval = dv
                        end
                        
                      end
                    end
                  end
                end
              end
              
            elseif tmppos.ptype == ptype.cc then
              
              if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                if ctl_template.fader[i].lmode == 4 then
                  local changev = gmem_rd(lvar.gm_fb.fader_change+(i-1))
                  if changev ~= -1 then 
                    --local dispval = tmppos.val or -1
                    --local dispval
                    if tmppos.cc14bit == 1 then
                      dispval = changev
                      if tmppos.polarity == 1 then
                        dispval = 16383-dispval
                      end
                    else
                      dispval = changev -->> 7
                      if tmppos.polarity == 1 then
                        dispval = 127-dispval
                      end
                    end
                    --DBG(dispval)
                    tmppos.bpos = tmppos.butstates_arrayidx[dispval] or 1
  
                    local val
                    if tmppos.bpos == 1 then
                      val = 0
                    else
                      val = 1
                    end
                    bchange = val
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384)
                    blast = true
                    
                    dispval = string.format('%i',dispval)
                    tmppos.dispval = dispval
                    
                    --Scribble_FlashVal(i,string.format('%i',dispval))
                    tmppos.oval = tmppos.val
                    --DBG('x'..tostring(tmppos.val))
                    gmem(lvar.gm_fb.fader_change+(i-1),-1)
                  end
                else
                  local changev = gmem_rd(lvar.gm_fb.fader_change+(i-1))
  
                  if tmppos.val ~= tmppos.oval or changev ~= -1 then 
  
                    dispval = tmppos.val or -1
                    if changev ~= -1 then
                    
                      if tmppos.cc14bit == 1 then
                        dispval = changev
                        if tmppos.polarity == 1 then
                          dispval = 16383-dispval
                        end
                      else
                        dispval = changev >> 7
                        if tmppos.polarity == 1 then
                          dispval = 127-dispval
                        end
                      end
                      
                      dispval = string.format('%i',dispval)
                      tmppos.dispval = dispval
                      tmppos.oval = tmppos.val --ermmm - should this be above previous statement?
                       
                      gmem(lvar.gm_fb.fader_change+(i-1),-1) --!!! this line causes jumpy slider - but needed to prevent always processing this block
  
                      if not settings.liveccfb then
                        if upd_fb2 == true or not lvar.readparams then
                          SetFaderBoxVal(i, changev or 0)
                        end
                        
                        gmem(lvar.gm_fb.fset+(i-1),math.floor((math.min(changev,16383)/16383)*127)|16384)
                        --NEED TO TELL FADERBOX VALUE CHANGED ???
                        blast = true
                      end
                      
                    elseif dispval ~= -1 then
                      if tmppos.cc14bit == 1 then
                        dispval = round(dispval,0)
                        if tmppos.polarity == 1 then
                          if lvar.finetune_fader[i] ~= 1 then
                            dispval = 16383-dispval
                          end
                        end
                      else
                        dispval = round((dispval/16383)*127,0)
                        if tmppos.polarity == 1 then
                          if lvar.finetune_fader[i] ~= 1 then
                            dispval = 127-dispval
                          end
                        end
                      end
                      dispval = string.format('%i',dispval)
                      tmppos.dispval = dispval
                      tmppos.oval = tmppos.val 
                    end
                  end
                end
              end
            
            elseif tmppos.ptype == ptype.track then
  
              local trn = tmppos.track
              local track, ttrn
              if trn then
                if trn <= -1 then
                  if trn == -1 then
                    track = reaper.GetSelectedTrack2(0,0,true)
                    if track then
                      ttrn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
                    end
                  elseif trn == -2 then
                    ttrn = Internal_GetTrack2(tmppos) 
                    track = GetTrack(ttrn)
                  end
                else
                  ttrn = trn
                  track = GetTrack(trn)
                  if trn ~= 0 and track and tmppos.trguid and reaper.GetTrackGUID(track) ~= tmppos.trguid then
                    track = reaper.BR_GetMediaTrackByGUID(0, tmppos.trguid)
                    if track then
                      tmppos.track = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
                      ttrn = tmppos.track
                      if tmppos.trparam ~= -1 then
                        tmppos.pname = GenTrackPName(i)
                      elseif tmppos.trsend ~= -1 then
                        --tmppos.pname = GenTrackSName(i, ttrn, track)                      
                      end
                      tmp.dirty[i] = true
                      lupd.update_faderbar = true
                      --mark as need to save? --hmmm this triggers too easily - don't mark as saved required
                      if gflag == 2 then
                        --lvar.saveglob_highlight = true
                      elseif gflag == 1 or gflag == 4 then
                        --lvar.save_highlight = true
                      end
                      lupd.update_header = true
                    end
                  end
                end
              end
              --if track then
              if not track then
                tmppos.dispval = ''
              end
  
              if tmppos.trparam ~= -1 then
                local parcode = tab_trparams_code[tmppos.trparam]
                
                if parcode then
                --DBG(i..'  '..parcode)
                  if parcode == 'X_PKMETER' then
                  
                    if track then
                      local pk_l = normalize(-60,0,F_limit((20*log10(reaper.Track_GetPeakInfo(track, 0))),-60,0))
                      local pk_r = normalize(-60,0,F_limit((20*log10(reaper.Track_GetPeakInfo(track, 1))),-60,0))
                      --DBG(pk_l..'  '..pk_r)
                      --local val = round((pk_l+pk_r)/2 * 16383,0)
                      local val = round(math.max(pk_l,pk_r) * 16383,0)
                      if tmppos.val ~= val or not lvar.readparams then
                        tmppos.val = val or 0
                        tmp.dirty[i] = true
                        lupd.update_faderbar = true
                        if upd_fb2 == true or not lvar.readparams then
                          SetFaderBoxVal(i, val or 0)
                        end
                      end
                    else
                      local val = 0
                      if tmppos.val ~= val or not lvar.readparams then
                        tmppos.val = val or 0
                        tmp.dirty[i] = true
                        lupd.update_faderbar = true
                        if upd_fb2 == true or not lvar.readparams then
                          SetFaderBoxVal(i, val or 0)
                        end
                      end
                    end
  
                  elseif parcode == 'X_PKMETERL' then
                  
                    if track then
                      local pk_l = normalize(-60,0,F_limit((20*log10(reaper.Track_GetPeakInfo(track, 0))),-60,0))
                      local val = round(pk_l * 16383,0)
                      if tmppos.val ~= val or not lvar.readparams then
                        tmppos.val = val or 0
                        tmp.dirty[i] = true
                        lupd.update_faderbar = true
                        if upd_fb2 == true or not lvar.readparams then
                          SetFaderBoxVal(i, val or 0)
                        end
                      end
                    else
                      local val = 0
                      if tmppos.val ~= val or not lvar.readparams then
                        tmppos.val = val or 0
                        tmp.dirty[i] = true
                        lupd.update_faderbar = true
                        if upd_fb2 == true or not lvar.readparams then
                          SetFaderBoxVal(i, val or 0)
                        end
                      end
                    end
  
                  elseif parcode == 'X_PKMETERR' then
                  
                    if track then
                      local pk_r = normalize(-60,0,F_limit((20*log10(reaper.Track_GetPeakInfo(track, 1))),-60,0))
                      local val = round(pk_r * 16383,0)
                      if tmppos.val ~= val or not lvar.readparams then
                        tmppos.val = val or 0
                        tmp.dirty[i] = true
                        lupd.update_faderbar = true
                        if upd_fb2 == true or not lvar.readparams then
                          SetFaderBoxVal(i, val or 0)
                        end
                      end
                    else
                      local val = 0
                      if tmppos.val ~= val or not lvar.readparams then
                        tmppos.val = val or 0
                        tmp.dirty[i] = true
                        lupd.update_faderbar = true
                        if upd_fb2 == true or not lvar.readparams then
                          SetFaderBoxVal(i, val or 0)
                        end
                      end
                    end
                  
                  elseif parcode == 'X_TRACKNAME' then
  
                    if track then
  
                      tmppos.val = 1
                      local _, tn = reaper.GetTrackName(track)
                      if tn and tmppos.scribov ~= tn then
                        if lvar.stripperlink then
                        --DBG(tn)
                          reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', tn, false)
                        end
                        tmppos.scribov = tn
                        --tmppos.dispval = tn
                      end
                      --tmp.dirty[i] = true
                      
                    else
                      if lvar.stripperlink then
                        reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', ' ', false)
                      end
                    end
                  
                  elseif ctl_template.fader[i].lmode ~= 4 then
                  
                    if tmppos.polarity ~= 1 then
                      
                      local val, denormal = 0, 0
                      if track then
                        if tab_trparams_funcget[tmppos.trparam] then
                          local r, v1, v2 = tab_trparams_funcget[tmppos.trparam](track)
                          local v
                          if parcode == 'D_PAN' then
                            v = v2
                          else
                            v = v1
                          end
                          val, denormal = normalizetrackparam(v, parcode) 
                          val = val * 16383
                        else
                          val, denormal = normalizetrackparam(reaper.GetMediaTrackInfo_Value(track,parcode), parcode) 
                          val = val * 16383
                        end
                      end
                      
                      if tmppos.oldval ~= val or not lvar.readparams then
                        tmppos.val = val
                        tmppos.oldval = val
                        tmp.dirty[i] = true
                        lupd.update_faderbar = true
                        
                        if upd_fb == true or not lvar.readparams then
                          local min,max = tmppos.min or 0, tmppos.max or 1
                          local val2 = val/16383
                          val2 = math.min(math.max((val2-min)/(max-min),0),1)*16383
                        
                          SetFaderBoxVal(i, val2, nil, xxxflag)

                          local convstr = track_info[parcode].conv
                          if convstr and track then
                            tmppos.dispval = convstr('', denormal)
                            if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                              dispval = tmppos.dispval
                            end
                          end

                        end
                        
                      end
                      
                    else
                    
                      local val, denormal = 0, 0
                      if track then
                        if tab_trparams_funcget[tmppos.trparam] then
                          local r, v1, v2 = tab_trparams_funcget[tmppos.trparam](track)
                          local v
                          if parcode == 'D_PAN' then
                            v = v2
                          else
                            v = v1
                          end
                          val, denormal = normalizetrackparam(v, parcode) 
                          val = 16383 - (val * 16383)
                        else
                          val, denormal = normalizetrackparam(reaper.GetMediaTrackInfo_Value(track,parcode), parcode) 
                          val = 16383 - (val * 16383)
                        end
                      end

                      if tmppos.oldval ~= val or dv ~= tmppos.dispval or not lvar.readparams then
                        tmppos.val = val
                        tmppos.oldval = val
                        tmp.dirty[i] = true
                        lupd.update_faderbar = true
    
                        if upd_fb == true or not lvar.readparams then
                          local min,max = tmppos.min or 0, tmppos.max or 1
                          local val2 = (16383-val)/16383
                          val2 = 16383-(math.min(math.max((val2-min)/(max-min),0),1)*16383)
                        
                          SetFaderBoxVal(i, val2)
  
                          local convstr = track_info[parcode].conv
                          if convstr and track then
                            tmppos.dispval = convstr('', denormal)
                            if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                              dispval = tmppos.dispval
                            end
                          end

                        end
                        
                      end
                    end
                  
                  elseif ctl_template.fader[i].lmode == 4 then
                  
                    --button
                    local val = 0
                    if track then
                      if tab_trparams_funcget[tmppos.trparam] then
                        local r, v1, v2 = tab_trparams_funcget[tmppos.trparam](track)
                        local v
                        if track_info[parcode].convval then
                          v =  track_info[parcode].convval(v1)
                        else
                          v = v1
                        end
                        val, denormal = normalizetrackparam(v, parcode) 
                        val = val * 16383
                      else
                        val = normalizetrackparam(reaper.GetMediaTrackInfo_Value(track,parcode), parcode) * 16383
                      end
                    end
                    
                    if val ~= tmppos.oldval or not lvar.readparams then
                      tmppos.oldval = val
                      bchange = val
                      
                      tmppos.bstate = val
                      gmem(lvar.gm_fb.bstate+(i-1), val)
    
                      local vval = val/16383 --math.ceil(tonumber(val*100000))/100000
                      local donotupdatess
                      if tmppos.butstates_arrayidx and tmppos.butstates_arrayidx[vval] then
                        tmppos.bpos = tmppos.butstates_arrayidx[vval]
                        if tmppos.buttype == 0 or (tmppos.buttype == 4 and tmppos.bpos > 1) and tmppos.actionmon == 1 then
                          gmem(lvar.gm_fb.bstate+(i-1), 1)
                          val = 1
                        elseif tmppos.actionmon == 0 or tmppos.buttype == 4 then
                          gmem(lvar.gm_fb.bstate+(i-1), 0)
                          val = 0
                          bchange = 0
                          donotupdatess = true
                        end
                      else--if tmppos.buttype == 0 then
                        gmem(lvar.gm_fb.bstate+(i-1), 0)
                        tmppos.bpos = 1
                        val = 0
                        bchange = 0
                        donotupdatess = true
                      end
                      
                      --Send feedback
                      if upd_fb == true or not lvar.readparams then
                        gmem(lvar.gm_fb.fset+(i-1),math.floor(val*127)|16384)
                        blast = true
                        
                        local convstr = track_info[parcode].conv
                        if convstr and track then
                          tmppos.dispval = convstr('', denormal)
                          if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                            dispval = tmppos.dispval
                          end
                        end
                      end
                    end
                  end                  
                end
                
              elseif tmppos.trsend ~= -1 then
                local val = 0
                if track then
                  local val2 = 0
                  local snd_type = ((tmppos.trsend-1) % 3) + 1
                  local si = math.floor((tmppos.trsend-1) / 3)
                  local scnt = reaper.GetTrackNumSends(track,0)
                  
                  local guid = reaper.GetTrackGUID(track)
                  if not tab_SendIdx or not tab_SendIdx[guid] or tab_SendIdx[guid].count ~= scnt then
                    GetSendIdxTable(ttrn)
                    --ensure sends updated during playback
                    gmem(lvar.gm_fb.forcefeedback,1) 
                  end
                  local snd_idx 
                  if tab_SendIdx and tab_SendIdx[guid] and tab_SendIdx[guid][si] then
                    snd_idx = tab_SendIdx[guid][si].idx
                  end
                  
                  local func, retval, a, b
                  if snd_idx then
                    func = tab_trsnds_code[snd_type]
                    retval, a, b = func(track, snd_idx)
                  end
                  
                  if retval then
                    if snd_type == 1 then
                      --vol
                      val = normalizetracksend(a,snd_type) * 16383
                      val2 = a
                    elseif snd_type == 2 then
                      --pan
                      val = normalizetracksend(b,snd_type) * 16383
                      val2 = b
                    elseif snd_type == 3 then
                      --mute
                      if a then
                        a = 1
                      else
                        a = 0
                      end
                      val = a * 16383
                      val2 = a
                    end
                  end
                  
                  
                  
                  if --[[snd_type == 3]] ctl_template.fader[i].lmode == 4 then
                    if val ~= tmppos.oldval or not lvar.readparams then
                      tmppos.oldval = val
                      bchange = val
                      
                      tmppos.bstate = val
                      gmem(lvar.gm_fb.bstate+(i-1), val)
    
                      local vval = val/16383 --math.ceil(tonumber(val*100000))/100000
                      local donotupdatess
                      if tmppos.butstates_arrayidx and tmppos.butstates_arrayidx[vval] then
                        tmppos.bpos = tmppos.butstates_arrayidx[vval]
                        if tmppos.buttype == 0 or (tmppos.buttype == 4 and tmppos.bpos > 1) and tmppos.actionmon == 1 then
                          gmem(lvar.gm_fb.bstate+(i-1), 1)
                          val = 1
                        elseif tmppos.actionmon == 0 or tmppos.buttype == 4 then
                          gmem(lvar.gm_fb.bstate+(i-1), 0)
                          val = 0
                          bchange = 0
                          donotupdatess = true
                        end
                      else--if tmppos.buttype == 0 then
                        gmem(lvar.gm_fb.bstate+(i-1), 0)
                        tmppos.bpos = 1
                        val = 0
                        bchange = 0
                        donotupdatess = true
                      end
                      
                      --Send feedback
                      if upd_fb == true or not lvar.readparams then
                        gmem(lvar.gm_fb.fset+(i-1),math.floor(val*127)|16384)
                        blast = true
                        
                        local convstr = tracksend_info[snd_type].conv
                        if convstr and track then
                          tmppos.dispval = convstr('', val2)
                          if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb and rt >= (tmppos.donotflashscribble or 0)  then
                            dispval = tmppos.dispval
                          end
                        end
                      end
                      
                      
                      
                      --[[bchange = val2
                      tmppos.bstate = val                    
                      gmem(lvar.gm_fb.bstate+(i-1), val)
  
                      --Send feedback
                      if upd_fb == true or not lvar.readparams then
                        gmem(lvar.gm_fb.fset+(i-1),math.floor((math.min(val,16383)/16383)*127)|16384)
                        --NEED TO TELL FADERBOX VALUE CHANGED ???
                        blast = true
                      end
                      
                      if val > 0 then
                        tmppos.valind = true
                      else
                        tmppos.valind = false
                      end
                      tmp.dirty[i] = true
                      lupd.update_fader = true
                    
                      local convstr = tracksend_info[snd_type].conv
                      if convstr and track then
                        tmppos.dispval = convstr('', a)
                        if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb and rt >= (tmppos.donotflashscribble or 0)  then
                          dispval = tmppos.dispval
                        end
                      end]]
                      
                    end
                  else
                    if tmppos.polarity == 1 then  
                      val = 16383-val
                    end
                    if tmppos.val ~= val or not lvar.readparams then
                      tmppos.val = val
                      tmp.dirty[i] = true
                      
                      lupd.update_faderbar = true
                      if upd_fb2 == true or not lvar.readparams then
                        SetFaderBoxVal(i, val)
                      end
  
                      local convstr = tracksend_info[snd_type].conv
                      if convstr and track then
                        tmppos.dispval = convstr('', val2)
                        if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                          dispval = tmppos.dispval
                        end
                      end
                    end
                  end
                end
              end
              
            elseif tmppos.ptype == ptype.action then
            
              if tmppos.actionmon == 1 and tmppos.actionid ~= -1 then
                local actid = tonumber(tmppos.actionid)
                local val
                if actid and actid ~= -1 then
                  val = reaper.GetToggleCommandStateEx(0, actid)
                else
                  val = reaper.GetToggleCommandStateEx(0, reaper.NamedCommandLookup(tmppos.actionid))                
                end
                if val ~= -1 then
                  if --[[val ~=]] tmppos.bstate == 1 or val ~= tmppos.oldval or not lvar.readparams then
                    bchange = val
                    
                    tmppos.oldval = val
                    tmppos.bstate = 0 -- val
                    gmem(lvar.gm_fb.bstate+(i-1), val)
                    
                    --send feedback
                    if tmppos.ledon ~= 1 then
                      gmem(lvar.gm_fb.fset+(i-1),math.floor(val*127)|16384)
                      blast = true
                    end
                    
                    if val == 1 then
                      tmppos.valind = true
                    else
                      tmppos.valind = false
                    end
                    tmp.dirty[i] = true
                    lupd.update_fader = true
                  end  
                else
                  if tmppos.bstate ~= 0 then
                    tmppos.bstate = 0
                    gmem(lvar.gm_fb.bstate+(i-1), 0)
                    
                    gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                    blast = true
                  end
                end
                
         
              else
            
                tmppos.bstate = 0
                gmem(lvar.gm_fb.bstate+(i-1), 0)
                
              end
            
            --------------------------
            ---- INTERNAL SECTION ----
            --------------------------
            
            elseif tmppos.ptype == ptype.internal then
            --DBG(i..'  '..tmp.pos[i].code..'  '..tmp.pos[i].codeval..'  '..tmp.pos[i].actionmon)
  
              local val, bpval--, dispval
              --[[if ctl_template.fader[i].lmode == 4 then
                if i == 66 then
               
                tmppos.bpos = tmppos.butstates_arrayidx[dispval] or 1
                end
              end]]
              if tmppos.code == -1 then
                --Dummy (Stripper Overlay) set fader to 0
                if lvar.stripperlink then
                  if reaper.GetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_DVAL') ~= ' ' then
                    reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_DVAL', ' ', false)
                  end
                end
                if upd_fb == true then
                  local val = gmem_rd(i-1)
                  if val ~= 0 or not lvar.readparams then
                    SetFaderBoxVal(i, 0)
                    gmem(lvar.gm_fb.fset+(i-1),0)
                    blast = true
                  end
                end
                
              elseif tmppos.code == 1 then
  
                if tmppos.bstate ~= 0 then
                  tmppos.bstate = 0
                  gmem(lvar.gm_fb.bstate+(i-1), 0)
                  
                  gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                  blast = true
                  
                  tmppos.bpos = 1
                  
                end
                 
              elseif tmppos.actionmon == 1 and tmppos.code == 2 and tmppos.codeval then
                val = 0
                if tmppos.codeval == 1 then
                  if lvar.showglobalmap then
                    val = 1
                  else
                    val = 0
                  end
                  
                elseif tmppos.codeval > 3 then
                  if lvar.currentglobalmap == tmppos.codeval-3 and lvar.showglobalmap then
                    val = 1
                  else
                    val = 0
                  end
                end
                
                if tmppos.polarity == 1 then
                  val = 1-val
                end
  
                if (val ~= tmppos.bstate or not lvar.readparams or not lvar.readparams2) then
                  bchange = val
                  tmppos.bstate = val
                  gmem(lvar.gm_fb.bstate+(i-1), val)
                  
                  tmppos.bpos = val+1
                  --send feedback
  
                  gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                  blast = true                  
  
                  if val == 1 then
                    tmppos.valind = true
                  else
                    tmppos.valind = false
                  end
                  tmp.dirty[i] = true
                  lupd.update_fader = true
                  
                  tmppos.dispval = ''
                  
                  bpval = val
                  
                end  
            
              elseif tmppos.actionmon == 1 and tmppos.code == 3 and tmppos.codeval then
              
                local butstyle
                val, butstyle = tab_commonfuncs_f[tmppos.codeval](tmp, i)
                if (--[[val ~= ]]tmppos.bstate == 1 or val ~= tmppos.oldval or not lvar.readparams --[[or not lvar.readparams2]] ) then
                  bchange = val
                  tmppos.bstate = 0
                  tmppos.oldval = val
                  gmem(lvar.gm_fb.bstate+(i-1), val)
                  if val == 1 then
                    tmppos.valind = true
                  else
                    tmppos.valind = false
                  end
                  tmp.dirty[i] = true
                  lupd.update_fader = true
  
                  --[[if ctl_template.fader[i].ssnum and lvar.readparams and lvar.fadervaluefb then
                    
                    dispval = conv_onoff(nil, val)
                    
                  end ]]
                  bpval = val
                  
                  --send feedback
                  tmppos.dispval = ' '
                  if tmppos.codeval == 5 then
                    
                    local devbus = ctl_template.fader[i].devbus
                    if lvar.tc_display[devbus] and lvar.tc_display[devbus].led then
                      if lvar.tc_display[devbus].led[lvar.timecodedisplayformat] then
  
                        local note = lvar.tc_display[devbus].led[lvar.timecodedisplayformat].note
                        local on = lvar.tc_display[devbus].led[lvar.timecodedisplayformat].on
                        SendMIDIDirect(i, 0, note, on)
                        --SendNoteDirect(devbus, 0, note, on)
                      end
                      if lvar.tc_display[devbus].led[1-lvar.timecodedisplayformat] then
                        local note = lvar.tc_display[devbus].led[1-lvar.timecodedisplayformat].note
                        local off = lvar.tc_display[devbus].led[1-lvar.timecodedisplayformat].off
                        SendMIDIDirect(i, 0, note, off)
                        --SendNoteDirect(devbus, 0, note, off)
                      end
                    end
                  --elseif tmppos.codeval == 11 then
                    
                  
                    
                  else
                    gmem(lvar.gm_fb.fset+(i-1),butstyle|16384)
                    blast = true
                  end
                end  
              
              elseif tmppos.actionmon == 1 and tmppos.code == 4 then
                
                val = 0                
                if tmppos.codeval == 1 or tmppos.codeval == 2 then
  
                elseif tmppos.codeval == 3 then
  
                  if lvar.filtidx then
                    val = 1
                  else
                    val = 0
                  end
  
                else
  
                  if lvar.userfilter.select == tmppos.codeval -3 and lvar.filtidx then
                    val = 1
                  else
                    val = 0
                  end
  
                end
                
                if (--[[val ~=]] tmppos.bstate == 1 or val ~= tmppos.oldval or not lvar.readparams --[[or not lvar.readparams2]] ) then
                  bchange = val
                  tmppos.oldval = val
                  tmppos.bstate = 0
                  gmem(lvar.gm_fb.bstate+(i-1), val)
                  
                  --send feedback
                
                  gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                  blast = true                  
                  
                  bpval = val
                  
                  if val == 1 then
                    tmppos.valind = true
                  else
                    tmppos.valind = false
                  end
                  tmp.dirty[i] = true
                  lupd.update_fader = true
                  
                end  
                
              elseif tmppos.actionmon == 1 and tmppos.code == 5 then
              
                if tmppos.codeval == 6 then
  
                  val = tmppos.bpos or 1
  
                  if (val ~= tmppos.bstate or not lvar.readparams --[[or not lvar.readparams2]]) then
  
                    tmppos.bstate = val
                    gmem(lvar.gm_fb.bstate+(i-1), val)
                    
                    if lvar.scrubactive == i then
                      tmppos.valind = true
                      val = 1
                    else
                      tmppos.valind = false
                      val = 0                    
                    end
                  
                    if not tmppos.bpos then
                      tmppos.bpos = 1
                      if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                        vv = tmppos.butstates_array[tmppos.bpos]
                        vv2 = tmppos.butstates_array_ext[tmppos.bpos]
                      end
                      
                      tmppos.internal_val = vv
                      tmppos.internal_val2 = vv2
                      
                      SetScrubNudge(tmppos, i)
                    end
                  
                    local v
                    if (tmppos.bpos or 1) == 1 then
                      v = 0
                    else
                      v = 1
                    end
                    bchange = v
                    
                    gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  
                    tmp.dirty[i] = true
                    lupd.update_fader = true
                    
                    if lvar.scrubactive == i then
                      local p = tmppos.butstates_array_ext[tmppos.bpos] or 1
                      if tmppos.internal_val then
                        dispval = (tmppos.internal_val or '') .. tab_scrubnudge[p].disp
                        tmppos.dispval = dispval
                      end
                    end
                  end
                  
                elseif tmppos.codeval >= 2 then
                
                  if lvar.scrubactive == -1 and lvar.scrubtable[tmppos.codeval-1] == lvar.scrubflag then
                    val = tmppos.bpos or 1
    
                    if (val ~= tmppos.bstate or not lvar.readparams --[[or not lvar.readparams2]]) then
                      bchange = val-1
                      
                      tmppos.bstate = val
                      gmem(lvar.gm_fb.bstate+(i-1), val)
                      
                      --send feedback
                      --if val > 1 then
                        tmppos.valind = true
                        val = 1
                      --else
                      --  tmppos.valind = false
                      --  val = 0
                      --end
                    
                      gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    
                      tmp.dirty[i] = true
                      lupd.update_fader = true
                      
                      dispval = tmppos.internal_val
                      tmppos.dispval = dispval
                      
                    end  
                  else
                    val = 0
                    if (val ~= tmppos.bstate or not lvar.readparams --[[or not lvar.readparams2]]) then
  
                      tmppos.bstate = 0
                      tmppos.bpos = 0
                      gmem(lvar.gm_fb.bstate+(i-1), 0)
  
                      --send feedback
                      --[[if val > 1 then
                        tmppos.valind = true
                        val = 1
                      else]]
                        tmppos.valind = false
                        val = 0
                      --end
                    
                      gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    
                      tmp.dirty[i] = true
                      lupd.update_fader = true
                      
                    end                  
                  end
                
                end
              
              elseif tmppos.actionmon == 1 and tmppos.code == 6 then
              
                local slot = tmppos.codeval
                local track, trnm = GetCCLanesTrack()
                if trnm and lvar.lanes_xtra[trnm] and tmppos.codeval <= 4 and lvar.lanes_xtra[trnm][slot] and lvar.lanes_xtra[trnm][slot].tabidx then
                  
                  if lvar.lanes_xtra[trnm][slot] and lvar.lanes_xtra[trnm][slot].show then
                    tmppos.valind = true
                    val = 1
                  else
                    tmppos.valind = false
                    val = 0
                  end
  
                  if lvar.lanes_xtra[trnm][slot] and lvar.lanes_xtra[trnm][slot].tabidx then
                    local dv = lvar.cclanes[lvar.lanes_xtra[trnm][slot].tabidx].txt
                    if dv ~= tmppos.scribov then
                      tmppos.scribov = dv
                      tmp.dirty[i] = true
                      lupd.update_fader = true 
                    end
                  end
                  
                  if val ~= tmppos.oldval or not lvar.readparams then
                    bchange = val
                    
                    tmppos.oldval = val
                    tmppos.bstate = val
                    --tmppos.checkval = val
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)
                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  
                    bpval = val
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    if lvar.lanes_xtra[trnm][slot] and lvar.lanes_xtra[trnm][slot].tabidx then
                      tmppos.dispval = conv_onoff(nil, val)
                      if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                        
                        dispval = tmppos.dispval
                        
                      end                   
                    else
                      
                      gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                    
                    end
                  end
                
                elseif tmppos.codeval == 7 then
                  
                  if lvar.lanes_xtra.velshow then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
  
                  if val ~= tmppos.bstate or lvar.lanes_xtra.velshow ~= tmppos.oldval or not lvar.readparams then
                    bchange = val
                    tmppos.oldval = lvar.lanes_xtra.velshow
                    tmppos.bstate = val
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  
                    bpval = val
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = conv_onoff(nil, val)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
  
                elseif tmppos.codeval == 8 then
                
                  if lvar.midieditor_cclanes_showallfixed then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
  
                  if val ~= tmppos.bstate or lvar.midieditor_cclanes_showallfixed ~= tmppos.oldval or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = val
                    tmppos.oldval = lvar.midieditor_cclanes_showallfixed
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                    
                    bpval = val
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = conv_onoff(nil, val)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
  
                elseif tmppos.codeval == 9 then
                
                  
                  if lvar.midieditor_cclanes_hideallauto then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
  
                  if val ~= tmppos.bstate or lvar.midieditor_cclanes_hideallauto ~= tmppos.oldval or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = val
                    tmppos.oldval = lvar.midieditor_cclanes_hideallauto
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                    
                    bpval = val
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = conv_onoff(nil, val)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
  
                elseif tmppos.codeval == 10 then
                
                  if lvar.midieditor_cclanes_solo then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
  
                  if val ~= tmppos.bstate or lvar.midieditor_cclanes_solo ~= tmppos.oldval or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = val
                    tmppos.oldval = lvar.midieditor_cclanes_solo
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                    
                    bpval = val
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = conv_onoff(nil, val)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
  
                elseif tmppos.codeval >= 11 and tmppos.codeval <= 18 then
                
                  local ccass = tmppos.codeval - 10
                  if lvar.midieditor_cclanes_solo and lvar.midieditor_cclanes_solo_assign == ccass 
                     and not lvar.midieditor_cclanes_solovel then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
                   
                  --tmppos.bstate = gmem_rd(lvar.gm_fb.bstate+(i-1))
                  if tmppos.bstate == 1 or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = 0
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  
                    bpval = val
                    
                    --tmppos.bpos = tmppos.butstates_arrayidx[val] or 1
                  
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = conv_onoff(nil, val)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
  
                elseif tmppos.codeval >= 19 and tmppos.codeval <= 22 then
                
                  
                  local ccass = tmppos.codeval - 18
                  if lvar.midieditor_cclanes_solo and not lvar.midieditor_cclanes_solovel and not lvar.midieditor_cclanes_solo_assign 
                     and lvar.midieditor_cclanes_sololane == ccass then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
  
                  if tmppos.bstate == 1 or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = 0
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                    
                    bpval = val
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = conv_onoff(nil, val)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
  
                elseif tmppos.codeval == 23 then
                
                  
                  if lvar.midieditor_cclanes_solo and lvar.midieditor_cclanes_solovel then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
  
                  if tmppos.bstate == 1 or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = 0
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                    
                    bpval = val
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = conv_onoff(nil, val)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
  
                elseif tmppos.codeval == 24 then
                
                  local v2 = lvar.midieditor_cclanes_heightmulti
                  if lvar.midieditor_cclanes_heightmulti ~= 1 then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
  
                  if tmppos.bstate == 1 or v2 ~= tmppos.oldval or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = 0
                    tmppos.oldval = v2
  
                    bpval = v2*100
                    --[[if not tmppos.bpos then
                      tmppos.bpos = tmppos.butstates_arrayidx[v2*100] or 1
                    end]]
                   
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true        
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = string.format('%i',lvar.midieditor_cclanes_heightmulti * 100)..'%' 
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
  
                elseif tmppos.codeval >= 25 and tmppos.codeval <= 28 then
                
                  local l = tmppos.codeval - 24
                  local v2 = lvar.midieditor_cclanes_hmulti[l]
                  if --[[(tmppos.bpos or 1) ~= 1]] lvar.midieditor_cclanes_hmulti[l] ~= 1 then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
  
                  if tmppos.bstate == 1 or v2 ~= tmppos.oldval or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = 0
                    tmppos.oldval = v2
  
                    bpval = v2*100
                    --[[if not tmppos.bpos then
                      tmppos.bpos = tmppos.butstates_arrayidx[v2*100] or 1
                    end]]
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = string.format('%i',lvar.midieditor_cclanes_hmulti[l] * 100)..'%' 
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
                  
                elseif trnm and tmppos.codeval >= 31 and tmppos.codeval <= 38 then
                
                  if lvar.lanes_presets[trnm] then
                     
                    local p = tmppos.codeval - 30
                    if lvar.lanes_presets[trnm].select == p then
                      val = 1
                      tmppos.valind = true
                    else
                      val = 0
                      tmppos.valind = false
                    end
  
                    if tmppos.bstate == 1 or lvar.lanes_presets[trnm].select ~= tmppos.oldval or not lvar.readparams then
                      bchange = val
                      tmppos.bstate = 0
                      tmppos.oldval = lvar.lanes_presets[trnm].select
  
                      --[[if not tmppos.bpos then
                        tmppos.bpos = tmppos.butstates_arrayidx[val] or 1
                      end]]
                      
                      gmem(lvar.gm_fb.bstate+(i-1), val)                    
                      gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    
                      bpval = val
                      
                      tmp.dirty[i] = true
                      lupd.update_fader = true 
                      
                      tmppos.dispval = conv_onoff(nil, val)
                      if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                        
                        if val == 1 then
                          dispval = tmppos.dispval
                        end
                        
                      end                   
                    end
                  else
                    if tmppos.bstate == 1 then
                      gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                      blast = true
                    end
                    tmppos.bstate = 0
                    gmem(lvar.gm_fb.bstate+(i-1), 0)                
                    
                  end
                
                elseif tmppos.codeval == 39 then
                                
                  
                  if lvar.midieditor_cclanes then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
  
                  if tmppos.bstate == 1 or lvar.midieditor_cclanes ~= tmppos.oldval or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = 0
                    tmppos.oldval = lvar.midieditor_cclanes
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  
                    bpval = val
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = conv_onoff(nil, val)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
  
                elseif tmppos.codeval == 40 then
                                
                  
                  if lvar.lanes_ov_enable then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
  
                  if tmppos.bstate == 1 or lvar.lanes_ov_enable ~= tmppos.oldval or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = 0
                    tmppos.oldval = lvar.lanes_ov_enable
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  
                    bpval = val
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = conv_onoff(nil, val)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
                                                  
                elseif (tmppos.codeval >= 5 and tmppos.codeval <= 6) 
                    or (tmppos.codeval >= 29 and tmppos.codeval <= 30) then
  
                  if tmppos.bstate == 1 then
                    gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                    blast = true
                  end
                  
                  tmppos.bstate = 0
                  gmem(lvar.gm_fb.bstate+(i-1), 0)
  
                elseif tmppos.bstate == 1 then
                  
                  tmppos.bstate = 0
                  gmem(lvar.gm_fb.bstate+(i-1), 0)
                  
                  val = 0
  
                  gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                  blast = true                  
                  
                  tmp.dirty[i] = true
                  lupd.update_fader = true
                end
              
              elseif tmppos.actionmon == 1 and tmppos.code == 7 then
              
                if (tmppos.codeval <= 12) then 
                
                  local layer = tmppos.codeval
                  if layer == lvar.overtemplate and lvar.overtemplate_active then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
                  
                  if tmppos.polarity == 1 then
                    val = 1-val
                    tmppos.valind = not tmppos.valind
                  end
                  
                  if tmppos.valind ~= tmppos.oldval or tmppos.bstate ~= 0 or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = 0
                    tmppos.oldval = tmppos.valind
                  --DBG(val..'  '..tostring(tmppos.valind))
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                    
                    bpval = val
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true
                    
                    if tmp.layer and tmp.layer[layer] and tmp.layer[layer].name and lvar.stripperlink then
                      reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', tmp.layer[layer].name or '', false)
                    end
                    
                    local vv = val            
                    if tmppos.polarity == 1 then
                      vv = 1-vv
                    end
                    tmppos.dispval = conv_onoff(nil, vv)

                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) --[[and lvar.readparams]] and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      fv_force = true
                    end                   
                  end
                                  
                elseif tmppos.codeval == 13 then
                
                  if tmppos.bstate == 1 then
                    gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                    blast = true                                    
                  end
                  
                  tmppos.bstate = 0
                  gmem(lvar.gm_fb.bstate+(i-1), 0)                
  
                elseif tmppos.codeval >= 14 and tmppos.codeval <= 15 then
                
                  if tmppos.bstate == 1 then
                    gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                    blast = true                                    
                  end
                  
                  tmppos.bstate = 0
                  gmem(lvar.gm_fb.bstate+(i-1), 0)                
                
                elseif tmppos.codeval >= 16 and tmppos.codeval <= 27 then 
                
                  local layer = tmppos.codeval-15
                  if lvar.overtemp_latchreturn and layer == lvar.overtemplate and lvar.overtemplate_active then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
                
                  if tmppos.polarity == 1 then
                    val = 1-val
                  end
                  
                  if val ~= tmppos.bstate or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = val
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                    
                    bpval = val
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true
                    
                    local vv = val            
                    if tmppos.polarity == 1 then
                      vv = 1-vv
                    end
                    tmppos.dispval = conv_onoff(nil, vv)
                    
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) --[[and lvar.readparams]] and lvar.fadervaluefb then
                
                      dispval = tmppos.dispval
                      fv_force = true
                    end                   
                  end
                  
                end
              
              --[[elseif tmppos.actionmon == 1 and tmppos.code == 8 then
  
                if tmppos.codeval <= 2 then 
              
                
                end
                ]]
              elseif tmppos.code == 8 and tmppos.codeval >= 3 and tmppos.codeval <= 5 then 
  
                local env = reaper.GetSelectedEnvelope(0)
                if env then
                  local sel = GetSelectedAI(env, true)
                  if #sel > 0 then
                    local cd = tmppos.codeval
                    local v = reaper.GetSetAutomationItemInfo(env,sel[1].idx,tab_aicodes[cd].code,0,false)
                    val = round(((v+tab_aicodes[cd].add)/tab_aicodes[cd].mult)*16383)
                    if val ~= tmppos.val or not lvar.readparams then
                      --if upd_fb2 == true or not lvar.readparams then
                        tmppos.val = val
                        tmp.dirty[i] = true
                        lupd.update_fader = true
                        
                        --gmem(lvar.gm_fb.fset+(i-1),val|16384)
                        SetFaderBoxVal(i, val)
                        --gmem(lvar.gm_fb.fader_val + i-1, val)
                        --gmem(lvar.gm_fb.fader_val2 + i-1, val)
                      --end
                    end               
  
                  else
                    if tmppos.val ~= 0 then
                      tmppos.val = 0
                      SetFaderBoxVal(i, 0)
                      
                      gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value                
                      blast = true                  
                    end
                  end
                else
                  if tmppos.val ~= 0 then
                    tmppos.val = 0
                    SetFaderBoxVal(i, 0)
                    
                    gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value                
                    blast = true                  
                  end
                end
              
              elseif tmppos.code == 9 then 
                
                local v = lvar.takeover.active
                
                if v ~= tmppos.codeval then
                  val = 0
                else
                  val = 1
                end
                if val ~= tmppos.bstate or not lvar.readparams then
                  bchange = val
                  tmppos.bstate = val
                  
                  gmem(lvar.gm_fb.bstate+(i-1), val)                    
                  gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                  blast = true                  
                  
                  bpval = val
                  
                  tmp.dirty[i] = true
                  lupd.update_fader = true
                  
                  tmppos.dispval = conv_onoff(nil, val)
                  if (ctl_template.fader[i].ssnum or tmppos.ss_override) and tmppos.flashss --[[and lvar.readparams]] and lvar.fadervaluefb then
                    
                    tmppos.flashss = nil
                    dispval = tmppos.dispval
                    fv_force = true
                    
                  end                   
                  --InsertTakeoverAssignments()
  
                end                
                
              elseif tmppos.code == 10 then 
              
                local v = LBX_CTL_TRACK_AM
                
                if v ~= tmppos.codeval-1 then
                  val = 0
                else
                  val = 1
                end
                if val ~= tmppos.bstate or not lvar.readparams then
                  bchange = val
                  tmppos.bstate = val
                  
                  gmem(lvar.gm_fb.bstate+(i-1), val)                    
                  gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                  blast = true                  
                
                  bpval = val
                  
                  tmp.dirty[i] = true
                  lupd.update_fader = true
                  
                  tmppos.dispval = conv_onoff(nil, val)
                  if (ctl_template.fader[i].ssnum or tmppos.ss_override) and tmppos.flashss --[[and lvar.readparams]] and lvar.fadervaluefb then
                    
                    tmppos.flashss = nil
                    dispval = tmppos.dispval
                    fv_force = true
                    
                  end                   
                  --InsertTakeoverAssignments()
  
                end                
              
              
              elseif tmppos.code == 11 then 
              
                if tmppos.codeval == 1 then 
                  
                  if lvar.autoenv then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
                  
                  if val ~= tmppos.oldval or tmppos.bstate ~= 0 or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = 0
                    tmppos.oldval = val
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  
                    bpval = val
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = conv_onoff(nil, val)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
                    
                elseif tmppos.codeval >= 2 and tmppos.codeval < 4 then 
  
                  if tmppos.bstate ~= 0 then
                  
                    tmppos.bstate = 0
                    gmem(lvar.gm_fb.bstate+(i-1), 0)
                  
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= 0 then
                      gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                  end
  
                elseif tmppos.codeval == 4 then 
  
                  local v2 = lvar.env_zoomh or 1
                  if v2 ~= 1 then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
                  
                  if tmppos.bstate == 1 or v2 ~= tmppos.oldval or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = 0
                    tmppos.oldval = v2
                  
                    bpval = v2*100
                    --[[if not tmppos.bpos then
                      tmppos.bpos = tmppos.butstates_arrayidx[v2*100] or 1
                    end]]
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = string.format('%i',v2 * 100)..'%' 
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
                  
  
                elseif tmppos.codeval >= 5 and tmppos.codeval < 9 then 
                  --env height multipliers
                  
                  local l = tmppos.codeval - 4
                  local v2 = lvar.env_indzoomh[l] or 1
                  if --[[(tmppos.bpos or 1) ~= 1]] v2 ~= 1 then
                    val = 1
                    tmppos.valind = true
                  else
                    val = 0
                    tmppos.valind = false
                  end
                  
                  if tmppos.bstate == 1 or v2 ~= tmppos.oldval or not lvar.readparams then
                    bchange = val
                    tmppos.bstate = 0
                    tmppos.oldval = v2
                  
                    bpval = v2*100
                    --[[if not tmppos.bpos then
                      tmppos.bpos = tmppos.butstates_arrayidx[v2*100] or 1
                    end]]
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)                    
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  
                    tmp.dirty[i] = true
                    lupd.update_fader = true 
                    
                    tmppos.dispval = string.format('%i',v2 * 100)..'%' 
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
                  
                elseif tmppos.codeval == 9 then 
  
                  if tmppos.bstate ~= 0 or lvar.env_spread ~= lvar.env_spread_old then
                    tmppos.bstate = 0
                    lvar.env_spread_old = lvar.env_spread
                    
                    local v = lvar.env_spread
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                    
                    bpval = v
                  
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                  end
                
                elseif tmppos.codeval >= 10 and tmppos.codeval <= 17 then 
  
                  local slot = tmppos.codeval - 9
                  if tmppos.bstate ~= 0 or lvar.autoenv_solo ~= lvar.autoenv_solo_old then
                    tmppos.bstate = 0
                    local v
                    if lvar.autoenv_solo == slot then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                    
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                  end
  
                elseif tmppos.codeval >= 18 and tmppos.codeval <= 19 then 
                
                  if tmppos.bstate ~= 0 then
                    tmppos.bstate = 0
                    gmem(lvar.gm_fb.bstate+(i-1), 0)
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= 0 then
                      gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                  end
                
                elseif tmppos.codeval == 20 then 
                
                  if tmppos.bstate ~= 0 or lvar.autoenv_solo ~= lvar.autoenv_solo_old then
                    tmppos.bstate = 0
                    lvar.autoenv_solo_old = lvar.autoenv_solo
                    
                    local v
                    if lvar.autoenv_solo then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                  
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                  end
                  
                end
                  
              elseif tmppos.code == 12 then 
                
                if tmppos.codeval == 1 then 
                                
                  if tmppos.bstate ~= 0 or lvar.tags.show ~= lvar.tags.showold then
                    tmppos.bstate = 0
                    lvar.tags.showold = lvar.tags.show
                    
                    local v
                    if lvar.tags.show then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                    
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                  end
                elseif tmppos.codeval >= 2 and tmppos.codeval <= 33 then 
                  
                  local slot = tmppos.codeval-1
                  if tmppos.bstate ~= 0 or lvar.tagslots.show ~= tmppos.showold then
                    tmppos.bstate = 0
                    tmppos.showold = lvar.tagslots.show
                    tmppos.scribov = lvar.tagslots[slot].name
                    
                    local v
                    if lvar.tagslots.show == slot then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                    
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                  end
                end
                
              elseif tmppos.code == 13 then 
                
                if tmppos.codeval == 1 then 
  
                  if tmppos.bstate ~= 0 or lvar.rrsettings.autoquantize ~= lvar.rrsettings.autoquantize_old then
                    tmppos.bstate = 0
                    lvar.rrsettings.autoquantize_old = lvar.rrsettings.autoquantize
                    
                    local v
                    if lvar.rrsettings.autoquantize == 1 then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                  
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true
                    
                    
                    tmppos.dispval = conv_onoff(nil, v)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
                  
                elseif tmppos.codeval == 2 then 
                  
                  local v2 = lvar.rrsettings.quantize_strength or 100
                  if tmppos.bstate ~= 0 or v2 ~= tmppos.oldval or not lvar.readparams then
                    tmppos.bstate = 0
                    tmppos.oldval = v2
  
                    if not tmppos.bpos then
                      tmppos.bpos = tmppos.butstates_arrayidx[v2] or 1
                      tmppos.internal_val = tmppos.butstates_array[tmppos.bpos]
                    end
                    local val
                    if tmppos.bpos == 1 then
                      val = 0
                    else
                      val = 1
                    end
                    
                    gmem(lvar.gm_fb.bstate+(i-1), val)
                    
                    bchange = val
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true  
                    
                    tmppos.dispval = tmppos.internal_val
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                    
                  end
                  
                elseif tmppos.codeval == 3 then 
                
                  if tmppos.bstate ~= 0 then
                    tmppos.bstate = 0
                    gmem(lvar.gm_fb.bstate+(i-1), 0)
                  
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= 0 then
                      gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                    
                    tmppos.dispval = ''
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = ''
                      
                    end                   
                  end
                  
                elseif tmppos.codeval == 4 then 
                
                  if tmppos.bstate ~= 0 or lvar.cc_starttransportonfadertouch ~= tmppos.oldval then
                    tmppos.oldval = lvar.cc_starttransportonfadertouch
                    tmppos.bstate = 0
                    
                    local v
                    if lvar.cc_starttransportonfadertouch then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                    
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                    
                    tmppos.dispval = conv_onoff(nil, v)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
                  
                end
                
              elseif tmppos.code == 14 then 
                
                if tmppos.codeval == 1 then 
  
                  if tmppos.bstate ~= 0 or lvar.finetune_active ~= lvar.finetune_active_old then
                    tmppos.bstate = 0
                    lvar.finetune_active_old = lvar.finetune_active
                    
                    local v
                    if lvar.finetune_active == true then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                  
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                    
                    tmp.dirty[i] = true
                    lupd.update_fader = true
                    
                    tmppos.dispval = conv_onoff(nil, v)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
                  
                elseif tmppos.codeval == 2 then 
                
                  local v2 = lvar.fineamt
                  if tmppos.bstate ~= 0 or v2 ~= tmppos.oldval or not lvar.readparams then
                    tmppos.bstate = 0
                    tmppos.oldval = v2
                    --gmem(lvar.gm_fb.bstate+(i-1), 0)
  
                    if not tmppos.bpos and tmppos.butstates_arrayidx then
                      tmppos.bpos = tmppos.butstates_arrayidx[v2/128] or 1
                    end
                    local val
                    if tmppos.bpos == 1 then
                      val = 0
                    else
                      val = 1
                    end
                    gmem(lvar.gm_fb.bstate+(i-1), val)
                    
                    bchange = val
                    gmem(lvar.gm_fb.fset+(i-1),(val*127)|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  
                    --[[if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= 0 then
                      gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end]]
                    
                    tmppos.dispval = string.format('%i',lvar.fineamt/128) --tmppos.internal_val
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                    
                  end
                
                end
              
              elseif tmppos.code == 15 then --FX Selection
              
                if tmppos.codeval == 1 then
                  if tmppos.bstate ~= 0 or lvar.fxsel_mode ~= tmppos.oldval or not lvar.readparams then
                    tmppos.oldval = lvar.fxsel_mode
                    tmppos.bstate = 0
                    
                    local v
                    if lvar.fxsel_mode == 0 then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                    
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                    
                    tmppos.dispval = conv_onoff(nil, v)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
                
                elseif tmppos.codeval >= 2 and tmppos.codeval <= 17 then
                
                  local slot = tmppos.codeval-2
                  local fxsel_slot = lvar.fxsel_slot
                  if lvar.fxsel_mode == 0 then
                    fxsel_slot = -1
                  end
  
                  local dv
                  if lvar.fxsel_trn then
                    local track = GetTrack(lvar.fxsel_trn)
                    if track then
                      _, dv = reaper.TrackFX_GetFXName(track,slot,'')
                      tmppos.fxslot_name = dv
                      
                    end
                  end     
                  --DBG('XXX '..lvar.fxsel_slot..'  '..lvar.fxsel_mode)
                  if tmppos.bstate ~= 0 or fxsel_slot ~= tmppos.oldval or (dv and dv ~= tmppos.ofxslot_name) then
                    tmppos.oldval = fxsel_slot
                    tmppos.bstate = 0
                    tmppos.ofxslot_name = dv
                    
                    local v
                    if fxsel_slot == slot then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                    
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                    
                    --if dv then
                      if lvar.stripperlink then
                        reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', dv or '', false)
                      end
                      --DBG(i..'  '..tostring(dv))
                    --end
                    
                    tmppos.dispval = ''
                    if v == 1 and (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
                
                elseif tmppos.codeval >= 20 and tmppos.codeval <= 21 then
                
                  if tmppos.bstate ~= 0 then
                    tmppos.bstate = 0
                    gmem(lvar.gm_fb.bstate+(i-1), 0)
                  
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= 0 then
                      gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                    
                    --tmppos.dispval = ''
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval --''
                      
                    end                   
                  end
                  
                elseif tmppos.codeval == 22 then
  
                  if tmppos.bstate ~= 0 or lvar.fxsel_plugtype ~= tmppos.oldval or not lvar.readparams then
                    tmppos.oldval = lvar.fxsel_plugtype
                    tmppos.bstate = 0
                    
                    local v
                    if lvar.fxsel_plugtype == 1 then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                    
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                    
                    tmppos.dispval = conv_onoff(nil, v)
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
                  
                end
                
              elseif tmppos.code == 16 and lvar.stripperlink then --SK2 Data
                if tmppos.codeval == 1 then
                  --Focused Track/Plugin
                  if FFX then
                    if lvar.mode == 3 then
                      local trname = string.format('%i',FFX.trn)..': '..FFX.trname
                      if trname == '' then
                        trname = ' '
                      end
                      reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', trname, false)
                    else
                      local fxname = string.format('%i',(FFX.fxnum or -1)+1)..': '..FFX.fxname
                      if fxname == '' then
                        fxname = ' '
                      end
                      reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', fxname, false)
                    end
                    tmppos.dispval = ' '
                  else
                    if lvar.mode == 3 then
                      reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', '< No Track >', false)
                    else
                      reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', '< No FX >', false)
                    end
                  end
                  
                elseif tmppos.codeval == 2 then
                  --Save layout
                  if tmppos.bstate ~= 0 or lvar.save_highlight ~= tmppos.oldval or not lvar.readparams then
                  
                    tmppos.oldval = lvar.save_highlight
                    tmppos.bstate = 0
                    
                    local v
                    if lvar.save_highlight == true then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
  
                    if FFX and lvar.mode == 3 and lvar.tags.trackassoc[FFX.trname] then
                      reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', 'Save Tag', false)
                    else
                      reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', 'Save Map', false)
                    end
                    
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                    
                    tmppos.dispval = ''
                    
                  end
                  
                elseif tmppos.codeval == 3 then
                  --Save layout
                  if tmppos.bstate ~= 0 or lvar.saveglob_highlight ~= tmppos.oldval or not lvar.readparams then
                  
                    tmppos.oldval = lvar.saveglob_highlight
                    tmppos.bstate = 0
                    
                    local v
                    if lvar.saveglob_highlight == true then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                    
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                    
                    tmppos.dispval = ''
                    
                  end
                elseif tmppos.codeval == 4 then
                  local tc = lvar.fdisp2 or ''
                  reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', tc, false)
                end
              
              elseif tmppos.code == 17 then

                if tmppos.codeval == 1 then
                  local track = reaper.GetSelectedTrack2(0,0,false)
                  if track then
                    local v = reaper.GetMediaTrackInfo_Value(track, 'I_HEIGHTOVERRIDE')
                    local val = F_limit(math.floor((v/1024) * 16383),0,16383)
                    if tmppos.polarity == 1 then
                      val = 16383-val
                    end
                    if val ~= tmppos.val or not lvar.readparams then
                      tmppos.val = val
                      tmp.dirty[i] = true
                      lupd.update_fader = true
                      
                      SetFaderBoxVal(i, val)
                    end               
  
                  else
                    if tmppos.val ~= 0 then
                      tmppos.val = 0
                      SetFaderBoxVal(i, 0)
                      
                      gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value                
                      blast = true                  
                    end
                  end

                elseif tmppos.codeval == 2 then
                
                  if reaper.time_precise() > (lvar.envvistimer1 or 0) then
                    --restrict updates - env visibility check is CPU intensive (although chunk pretty quick)
                    lvar.envvistimer1 = reaper.time_precise() + 0.1
                    
                    local track = reaper.GetSelectedTrack2(0,0,true)
                    if track then
                      local ecnt = reaper.CountTrackEnvelopes(track)-1
                      local env
                      for eidx = 0, ecnt do
                        env = reaper.GetTrackEnvelope(track, eidx)
                        if IsEnvVisible(env) then
                          break
                        end
                      end
  
                      if env then
                        local v = reaper.GetEnvelopeInfo_Value(env, 'I_TCPH')
                        local val = F_limit(math.floor((v/1024) * 16383),0,16383)
                        if tmppos.polarity == 1 then
                          val = 16383-val
                        end
                        --DBG(tostring(val)..'  '..tostring(tmppos.val))
                        if val ~= tmppos.val or not lvar.readparams then
  
                          tmppos.val = val
                          tmp.dirty[i] = true
                          lupd.update_fader = true
                          
                          SetFaderBoxVal(i, val)
                        end               
                    
                      else
                        if tmppos.val ~= 0 then
                          tmppos.val = 0
                          SetFaderBoxVal(i, 0)
                          
                          gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value                
                          blast = true                  
                        end
                      end
                    else
                      if tmppos.val ~= 0 then
                        tmppos.val = 0
                        SetFaderBoxVal(i, 0)
                        
                        gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value                
                        blast = true                  
                      end
                    end
                  end
                  
                elseif tmppos.codeval == 3 then
                  local track = reaper.GetSelectedTrack2(0, 0, true)
                  if track then
                    local env = reaper.GetSelectedEnvelope(0) --or reaper.GetTrackEnvelope(track, 0)
                    if env then
                      local v = reaper.GetEnvelopeInfo_Value(env, 'I_TCPH')
                      local val = F_limit(math.floor((v/1024) * 16383),0,16383)
                      if tmppos.polarity == 1 then
                        val = 16383-val
                      end
                      if val ~= tmppos.val or not lvar.readparams then
  
                        tmppos.val = val
                        tmp.dirty[i] = true
                        lupd.update_fader = true
                        
                        SetFaderBoxVal(i, val)
                      end               
                  
                    else
                      if tmppos.val ~= 0 then
                        tmppos.val = 0
                        SetFaderBoxVal(i, 0)
                        
                        gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value                
                        blast = true                  
                      end
                    end
                  end
                end
                
              elseif tmppos.code == 18 then
                --DBG(tmppos.codeval)
                if tmppos.codeval <= lvar.qfx_faders then

                  local idx = tmppos.codeval
                  
                  local qfx = lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx]
                  
                  if qfx then
                  
                    if qfx.sscolor and tmppos.sscolor ~= qfx.sscolor then
                      tmppos.sscolor = qfx.sscolor
                      reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_SSCOLOR', tmppos.sscolor or '', false)
                      reaper.SetExtState('SK2DATA_ASSIGN', 'DIRTY', 1, true)
                      dispval =  tab_xtouch_color_menu[qfx.sscolor+1]
                    end
                    local track, trnum, fxnum = QFX_FindFX(qfx)
                    if track and qfx.enabled == 1 then
                      local pname = qfx.pname
                      local pnum = qfx.pnum
                      local ffxtake
                      
                      local txt, txt2 = '', ''
                      if qfx.mode == 1 then
                        txt = '*'
                      end
                      if idx == (lvar.qfx_lasttouched or -1) then
                        txt2 = '> '
                      end
                      local nm = txt2..txt..pname
                      if nm ~= tmppos.name then
                        tmppos.name = nm
                        dispval = ' '
                      end
                      
                      if lvar.stripperlink then
                        reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', tmppos.name, false)
                      end
                      
                      local GetParamNormalized, GetFormattedParamValue, pointer
                      if not ffxtake then
                        GetParamNormalized = reaper.TrackFX_GetParamNormalized
                        GetFormattedParamValue = reaper.TrackFX_GetFormattedParamValue
                        pointer = track
                      else
                        GetParamNormalized = reaper.TakeFX_GetParamNormalized
                        GetFormattedParamValue = reaper.TakeFX_GetFormattedParamValue
                        pointer = ffxtake
                      end
                      
                      if ctl_template.fader[i].lmode ~= 4 then
                        if tmppos.polarity ~= 1 then
                          local val = GetParamNormalized(pointer, fxnum, pnum) * 16383
                          local ret, dv = GetFormattedParamValue(pointer, fxnum, pnum, '')
                          if tmppos.val ~= val or dv ~= tmppos.dispval or not lvar.readparams then
                            tmppos.val = val
                            tmp.dirty[i] = true
                            lupd.update_faderbar = true
                            
                            if upd_fb == true or not lvar.readparams then
                              local min,max = qfx.min or tmppos.min or 0, qfx.max or tmppos.max or 1
                              local val2 = val/16383
                              val2 = math.min(math.max((val2-min)/(max-min),0),1)*16383
                            
                              SetFaderBoxVal(i, val2)
                            end
                            
                            tmppos.dispval = dv
                            if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                              dispval = dv
                            end
                          end
                        else
                          local val = 16383 - (GetParamNormalized(pointer, fxnum, pnum) * 16383)
                          local ret, dv = GetFormattedParamValue(pointer, fxnum, pnum, '')
                          if tmppos.val ~= val or dv ~= tmppos.dispval or not lvar.readparams then
                            tmppos.val = val
                            tmp.dirty[i] = true
                            lupd.update_faderbar = true
        
                            if upd_fb == true or not lvar.readparams then
                              local min,max = qfx.min or tmppos.min or 0, qfx.max or tmppos.max or 1
                              local val2 = (16383-val)/16383
                              val2 = 16383-(math.min(math.max((val2-min)/(max-min),0),1)*16383)
                            
                              SetFaderBoxVal(i, val2)
                            end
        
                            tmppos.dispval = dv
                            if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                              dispval = dv
                            end
                          end
                        end
                      else
                        --button
                        --local val = reaper.TrackFX_GetParamNormalized(ffxtrack, fxnum, pnum)
                        local val = GetParamNormalized(pointer, fxnum, pnum)
                        --DBG(i..'  '..val..'  '..fxnum..'  '..pnum)
                        --if val ~= tmppos.bstate or not lvar.readparams then
                        if val ~= tmppos.oldval or not lvar.readparams then
                          tmppos.oldval = val
                          bchange = val
                          
                          tmppos.bstate = val
                          gmem(lvar.gm_fb.bstate+(i-1), val)
        
                          --local vval = round(val,6)
                          local vval = math.ceil(tonumber(val*100000))/100000
                          
                          local donotupdatess
                          --DBG(i..'  '..tostring(tmppos.bpos)..'  '..vval)
                          if tmppos.butstates_arrayidx and tmppos.butstates_arrayidx[vval] then
                            tmppos.bpos = tmppos.butstates_arrayidx[vval]
                            if tmppos.buttype == 0 or (tmppos.buttype == 4 and tmppos.bpos > 1) and tmppos.actionmon == 1 then
                              gmem(lvar.gm_fb.bstate+(i-1), 1)
                              val = 1
                            elseif tmppos.actionmon == 0 or tmppos.buttype == 4 then
                              gmem(lvar.gm_fb.bstate+(i-1), 0)
                              val = 0
                              bchange = 0
                              donotupdatess = true
                            end
                          else--if tmppos.buttype == 0 then
                            gmem(lvar.gm_fb.bstate+(i-1), 0)
                            tmppos.bpos = 1
                            val = 0
                            bchange = 0
                            donotupdatess = true
                          end
                          
                          --Send feedback
                          if upd_fb == true or not lvar.readparams then
                            --[[if tmppos.buttype == 0 then
                              val = 0
                            end]]
                            gmem(lvar.gm_fb.fset+(i-1),math.floor(val*127)|16384)
                            blast = true
                            
                            --local ret, dv = reaper.TrackFX_GetFormattedParamValue(ffxtrack, fxnum, pnum, '')
                            local ret, dv = GetFormattedParamValue(pointer, fxnum, pnum, '')
                            tmppos.dispval = dv
                            if not donotupdatess and (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb and rt >= (tmppos.donotflashscribble or 0) then
                              dispval = dv
                            end
                            
                          end
                        end
                      end
                    else
                      if tmppos.val ~= 0 or not lvar.readparams then
                        tmppos.val = 0
                        tmppos.name = 'Missing Plugin'

                        if lvar.stripperlink then
                          reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', tmppos.name, false)
                        end
                        SetFaderBoxVal(i, 0)
                        
                        tmppos.dispval = ' '
                        if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                          dispval = ' '
                        end
                        gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value                
                        blast = true
                      end
                    end
                    
                  else
                    local txt2 = 'QFX'
                    if idx == (lvar.qfx_lasttouched or -1) then
                      txt2 = '> QFX '
                    end
                    --local nm = txt2..'< QFX >'
                    if txt2 ~= tmppos.name then
                      tmppos.name = txt2
                      dispval = ' '
                    end

                    if tmppos.val ~= 0 or not lvar.readparams then
                      tmppos.val = 0
                      if lvar.stripperlink then
                        if tmppos.sscolor ~= lvar.qfx_defaultcolor then
                          tmppos.sscolor = lvar.qfx_defaultcolor
                          reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_SSCOLOR', tmppos.sscolor or '', false)
                          reaper.SetExtState('SK2DATA_ASSIGN', 'DIRTY', 1, true)
                        end
                        tmppos.sscolor = lvar.qfx_defaultcolor
                        reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', tmppos.name, false)
                      end
                      SetFaderBoxVal(i, 0)
                      
                      tmppos.dispval = '-'
                      if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                        dispval = ' '
                      end
                      gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value                
                      blast = true                  
                    end
                  end
                
                elseif tmppos.codeval <= 1024+lvar.qfx_faders then
                  
                  local idx = tmppos.codeval - 1024
                  local qfx = lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx]
                  if tmppos.bstate ~= 0 or qfx ~= tmppos.oldval or not lvar.readparams then
                    tmppos.oldval = qfx
                    tmppos.bstate = 0
                    
                    local v
                    if qfx then
                      v = 1
                    else
                      v = 0
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                    
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                    
                    tmppos.dispval = ''
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end

                elseif tmppos.codeval >= 3073 and tmppos.codeval <= 3073+lvar.qfx_faders then
                  --qfx mode
                  local idx = tmppos.codeval - 3072
                  local qfx = lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx] or {}
                  if tmppos.bstate ~= 0 or (qfx and qfx.mode ~= tmppos.oldval) or not lvar.readparams then
                    tmppos.oldval = qfx.mode
                    tmppos.bstate = 0
                    
                    local v, dv
                    if qfx.mode == 1 then
                      v = 1
                      dv = 'track'
                    else
                      v = 0
                      dv = 'global'
                    end
                    bchange = v
                    gmem(lvar.gm_fb.bstate+(i-1), v)
                    
                    bpval = v
                    
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= v then
                      gmem(lvar.gm_fb.fset+(i-1),(v*127)|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                    
                    tmppos.dispval = dv
                    if (ctl_template.fader[i].ssnum or tmppos.ss_override) and lvar.readparams and lvar.fadervaluefb then
                      
                      dispval = tmppos.dispval
                      
                    end                   
                  end
              
                else
                  if tmppos.bstate ~= 0 then
                    tmppos.bstate = 0
                    gmem(lvar.gm_fb.bstate+(i-1), 0)
                  
                    if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= 0 then
                      gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                      blast = true                  
                    end
                  end
                
                end
              
              elseif tmppos.code == 19 then --Write Fader
                if tmppos.bstate ~= 0 then
                  tmppos.bstate = 0
                  gmem(lvar.gm_fb.bstate+(i-1), 0)
               
                  if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= 0 then
                    gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  end
                end
                
              elseif tmppos.code == 20 then --Reset Fader/Encoder
                if tmppos.bstate ~= 0 then
                  tmppos.bstate = 0
                  gmem(lvar.gm_fb.bstate+(i-1), 0)
               
                  if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= 0 then
                    gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  end
                end
              
              else
              
                if tmppos.bstate ~= 0 then
                  tmppos.bstate = 0
                  gmem(lvar.gm_fb.bstate+(i-1), 0)
                
                  if gmem_rd(lvar.gm_fb.fset+(i-1)) ~= 0 then
                    gmem(lvar.gm_fb.fset+(i-1),0|16384) --Set 15th bit to prevent updating fader value
                    blast = true                  
                  end
                end
             
              end
              
              if bpval then
                tmppos.bpos = (tmppos.butstates_arrayidx or {})[bpval] or 1
                --DBG(i..' --- '..tmppos.bpos)
              end
              --[[if not lvar.readparams then
              DBG(i..' C '..tmppos.code..' CV '..tmppos.codeval..' VAL '..tostring(val)..'       N '..(tmppos.pname or tmppos.name)..'  '..tmppos.actionmon)
              end]]
            end
            
            if bchange or not lvar.readparams then
              if tmppos.butstates_array_name then
                local dv = tmppos.butstates_array_name[tmppos.bpos or 1]
                if dv then
                  tmppos.dispval = dv
                end
              else
              
              end
            end
            if bchange and bchange > 0 then
              --color
              if tmppos.ss_override_sscolor == 1 then
                local ss = ctl_template.fader[i].ssnum
                if tmppos.ss_override then
                  ss = lvar.ssnumidx[tmppos.ss_override]
                end
                if ss then
                  if not lvar.ss_override_sscolor[ss] then
                    lvar.ss_override_sscolor[ss] = {idx = {}}
                  end
                  local idx
                  if not lvar.ss_override_sscolor[ss].idx[i] then
                    idx = #lvar.ss_override_sscolor[ss]+1
                  else
                    idx = lvar.ss_override_sscolor[ss].idx[i]
                  end
                  
                  local sscolor = tmppos.sscolor
                  if tmppos.butstates > 2 then
                    if (tmppos.bpos or 1) > 1 then
                      if tmppos.butstates_array_sscolor[tmppos.bpos] ~= -1 then
                        sscolor = tmppos.butstates_array_sscolor[tmppos.bpos] or sscolor
                      end
                    end
                  end
  
                  --if tmppos.bpos > 1 then
                  --DBG(i..'  '..idx..'  '..tmppos.bpos)
                  lvar.ss_override_sscolor[ss][idx] = {tmpidx = i, col = sscolor}
                  lvar.ss_override_sscolor[ss].idx[i] = idx
                  --end
                end
              end
              --name
              if tmppos.ss_override_name == 1 then
                local ss = ctl_template.fader[i].ssnum
                if tmppos.ss_override then
                  ss = lvar.ssnumidx[tmppos.ss_override]
                end
                if ss then
                  if not lvar.ss_override_name[ss] then
                    lvar.ss_override_name[ss] = {idx = {}}
                  end
                  local idx
                  if not lvar.ss_override_name[ss].idx[i] then
                    idx = #lvar.ss_override_name[ss]+1
                  else
                    idx = lvar.ss_override_name[ss].idx[i]
                  end
                  
                  local ssname = tmppos.name or tmppos.pname
                  if tmppos.butstates > 2 then
                    if (tmppos.bpos or 1) > 1 then
                      ssname = tmppos.butstates_array_name[tmppos.bpos] or ssname
                    end
                  end
  
                  lvar.ss_override_name[ss][idx] = {tmpidx = i, col = ssname}
                  lvar.ss_override_name[ss].idx[i] = idx
                end
              end
              
            elseif bchange == 0 then
              --color
              
              if tmppos.ss_override_sscolor == 1 then
                local ss = ctl_template.fader[i].ssnum
                if tmppos.ss_override then
                  ss = lvar.ssnumidx[tmppos.ss_override]
                end
                if ss then
                  if lvar.ss_override_sscolor[ss] then
                    local idx = lvar.ss_override_sscolor[ss].idx[i]
                    if idx then
                      dispval = tmppos.dispval --force reflash
                      local tab = {}
                      local tab_idx = {}
                      local cnt = 1
                      for i = 1, #lvar.ss_override_sscolor[ss] do
                        if i ~= idx then
                          tab[cnt] = lvar.ss_override_sscolor[ss][i]
                          tab_idx[tab[cnt].tmpidx] = cnt
                          cnt = cnt + 1
                        end
                      end
                      lvar.ss_override_sscolor[ss] = tab
                      lvar.ss_override_sscolor[ss].idx = tab_idx
                    end
                  end
                end
              end
              --name
              if tmppos.ss_override_name == 1 then
                local ss = ctl_template.fader[i].ssnum
                if tmppos.ss_override then
                  ss = lvar.ssnumidx[tmppos.ss_override]
                end
                if ss then
                  if lvar.ss_override_name[ss] then
                    local idx = lvar.ss_override_name[ss].idx[i]
                    if idx then
                      dispval = tmppos.dispval --force reflash
                      local tab = {}
                      local tab_idx = {}
                      local cnt = 1
                      for i = 1, #lvar.ss_override_name[ss] do
                        if i ~= idx then
                          tab[cnt] = lvar.ss_override_name[ss][i]
                          tab_idx[tab[cnt].tmpidx] = cnt
                          cnt = cnt + 1
                        end
                      end
                      lvar.ss_override_name[ss] = tab
                      lvar.ss_override_name[ss].idx = tab_idx
                    end
                  end
                end
              end
              
            end  
           
            --[[if not lvar.readparams and tmppos.dispval then
              DBG(i..'  '..tmppos.dispval)
            end]]
  
            --Shared/linked assignments - make B link light match A link
            local fset = gmem_rd(lvar.gm_fb.fset+(i-1))
            if fset ~= -1 then
              tmppos.fset = fset & 16383
            end
            if tmppos.linkB then
              local fset = tmppos.fset --gmem_rd(lvar.gm_fb.fset+(i-1)) 
              local idx = lvar.ctlmapidx[tmppos.linkB]
              if idx then
                local fsetA = tmp.pos[idx].fset --gmem_rd(lvar.gm_fb.fset+(idx-1)) --tmp.pos[idx].fset 
                if fsetA and fset ~= fsetA then
                  gmem(lvar.gm_fb.fset+(i-1),fsetA|16384)
                  tmppos.fset = fsetA
                  --DBG(fset..'  '..fsetA)
                  blast = true
                end
              end
            end
  
            if tmppos.dispval and lvar.stripperlink --[[or tmppos.dispval ~= tmppos.odispval]] then
              --tmppos.odispval = tmppos.dispval
              
              reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_DVAL', tmppos.dispval or ' ', false)
              if (tmppos.fxslot_name or '') ~= '' then
                reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', tmppos.fxslot_name, false)
              end
              
              local ssc = tmppos.sscolor
              if ctl_template.fader[i] and ctl_template.fader[i].lmode == 4 and tmppos.butstates_array_sscolor then
                if (tmppos.butstates_array_sscolor[tmppos.bpos or -1] or -1) ~= -1 then
                  if tmppos.bpos > 1 then
                    ssc = tmppos.butstates_array_sscolor[tmppos.bpos or -1]
                  end
                end
              end
              reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_SSCOLOR', ssc or '', false)
            end
            
            --FLASH SCRIBBLE STRIP
            --[[if i == 315 then
              DBG(i..'  '..tostring(dispval))
            end]]
            if ctl_template.fader[i] and (ctl_template.fader[i].ssnum or tmppos.ss_override) and (lvar.readparams or fv_force) and dispval and tmppos.valtime ~= -2 then
              --DBG(i..'  '..dispval)
              Scribble_FlashVal(i,dispval)
            end
           
          else
            if lvar.stripperlink then
              if reaper.GetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_DVAL') ~= ' ' then
                reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_DVAL', ' ', false)
              end
            end
            if upd_fb == true then
              local val = gmem_rd(i-1)
              if val ~= 0 then
                SetFaderBoxVal(i, 0)
                gmem(lvar.gm_fb.fset+(i-1),0)
                blast = true
              end
            end
          end
          
        end
        if blast then
          --local fbfxn = 0
          --DBG('blast')
          --reaper.TrackFX_SetParam(ctltrack, 0, 58, 1)
          local gmem = reaper.gmem_write
          gmem(lvar.gm_fb.gswitch59, 1)
          blast = nil
        end
        
        if not lvar.readparams then
          SendScribbleData()
          --if not lvar.readparams then
            gmem(lvar.gm_fb.forcefeedback,1)
          --end
          
        end
        
        lvar.ofxtrack = reaper.GetSelectedTrack2(0, 0, true)
        lvar.readparams = true
        lvar.readparams2 = true
      end
    
    --[[else
      local ctltrack = GetTrack(LBX_CTL_TRACK)
      if ctltrack then  
      
      end
      
    end]]
  if txt ~= '' then
    DBG(txt)
  end
  
  --DBGOut('exit func: ReadParamVals')
  
  end
  
  function SetUpHandshake(dev, hstab)
    if LBX_SYSX_OUT[dev] then
      local gmem = reaper.gmem_write
      for i = 1, #hstab do
        gmem(lvar.gm_sysx.handshake_msg + (i-1), hstab[i])
      end 
      gmem(lvar.gm_sysx.handshake_len, #hstab)
      local track = GetTrack(LBX_SYSX_OUT[dev])
      if track then
        reaper.TrackFX_SetParam(track,0,5,1)
      end
    end
  end  
  
  function SetUpCCStampData()

    GMCCSTAMP_SetActive(lvar.ccstamp_active)
    GMCCSTAMP_Reset()
    if lvar.ccstamp_active == 1 then
      local scope = {}

      local gmem = reaper.gmem_read  
      for ii = 1, lvar.fcount do
        local tmp, scope_val
        tmp, scope_val = GetTemplate(ii)
        
        if tmp.pos[ii] and tmp.pos[ii].ptype == ptype.cc then
          --Set up cc default val
          if tmp.pos[ii].ccnum then
            if scope_val > (scope[tmp.pos[ii].ccnum] or 0) then
              scope[tmp.pos[ii].ccnum] = scope_val
              --DBG(ii..'  '..tmp.pos[ii].ccnum)
              if tmp.pos[ii].cc14bit == 1 and tmp.pos[ii].ccnum < 32 then
                local msb = ((tmp.pos[ii].defcc_val or gmem(lvar.gm_ccstamp.defcc_val+tmp.pos[ii].ccnum)) >> 7)
                local lsb = ((tmp.pos[ii].defcc_val or gmem(lvar.gm_ccstamp.defcc_val+tmp.pos[ii].ccnum)) & 127)
                GMCCSTAMP_SetCCActive(tmp.pos[ii].ccnum, msb)
                GMCCSTAMP_SetCCActive(tmp.pos[ii].ccnum+32, lsb)                
              else
                GMCCSTAMP_SetCCActive(tmp.pos[ii].ccnum, tmp.pos[ii].defcc_val or gmem(lvar.gm_ccstamp.defcc_val+tmp.pos[ii].ccnum))
              end
            end
          end
        end
      end
    end    
  end
  
  function TriggerCCStamp()
    local skcctrack = GetTrack(LBX_CC_TRACK)
    if skcctrack then
      reaper.TrackFX_SetParam(skcctrack, 0, 15, 1)
    end
  end
  
  function ResetFBOvals()
   local track = GetTrack(LBX_CTL_TRACK)
   if track then
     reaper.TrackFX_SetParam(track, 0, 61, 1)
   end
 end
 
  function StampSelectedItems()

    reaper.Undo_BeginBlock()

    local selcnt = reaper.CountSelectedMediaItems(0)
    local gmem = reaper.gmem_read
    if selcnt > 0 and mouse.shift then
      for sel = 0, selcnt-1 do
       
        local item = reaper.GetSelectedMediaItem(0, sel)
        if item then
          local itemid = reaper.GetMediaItemInfo_Value(item,'IP_ITEMNUMBER')
          local item_pos = reaper.GetMediaItemInfo_Value(item, "D_POSITION")
          local item_len = reaper.GetMediaItemInfo_Value(item, "D_LENGTH")
          local take = reaper.GetActiveTake(item)
          local item_start = reaper.MIDI_GetPPQPosFromProjTime(take, item_pos)
          local item_end = reaper.MIDI_GetPPQPosFromProjTime(take, item_pos + item_len)
 
          for i = 0, 127 do
            if gmem(lvar.gm_ccstamp.cc_active+i) == 1 and gmem(lvar.gm_ccstamp.cc_enabled+i) == 1 then
              local v = gmem(lvar.gm_ccstamp.cc_val+i)
              if v >= 0 and v <= 127 then
                --DBG('inserting cc '..i..' val '..v)
                reaper.MIDI_InsertCC(take, false, false, item_start, 0xB0, 0, i, v)
              end
            end
          end
          local track = reaper.GetMediaItemTrack(item)
          if track then
            reaper.MarkTrackItemsDirty(track,item)
          end
        end
           
      end 
    elseif not mouse.shift then
      --No items - create for selected tracks
      local selcnt = reaper.CountSelectedTracks(0)
      for sel = 0, selcnt-1 do
        local track = reaper.GetSelectedTrack(0, sel)
        local trn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
        if not lvar.ctltracks[trn] then
          --valid track
          local spos = reaper.GetCursorPosition() 
          local timesig_num, timesig_denom, bpm = reaper.TimeMap_GetTimeSigAtTime(0, spos)
          local bar = (60/bpm)*timesig_num
          local item = reaper.CreateNewMIDIItemInProj(track, spos, spos+bar)
          local itemid = reaper.GetMediaItemInfo_Value(item,'IP_ITEMNUMBER')
          local item_pos = reaper.GetMediaItemInfo_Value(item, "D_POSITION")
          local item_len = reaper.GetMediaItemInfo_Value(item, "D_LENGTH")
          local take = reaper.GetActiveTake(item)
          local item_start = reaper.MIDI_GetPPQPosFromProjTime(take, item_pos)
          local item_end = reaper.MIDI_GetPPQPosFromProjTime(take, item_pos + item_len)
  
          for i = 0, 127 do
            if gmem(lvar.gm_ccstamp.cc_active+i) == 1 and gmem(lvar.gm_ccstamp.cc_enabled+i) == 1 then
              local v = gmem(lvar.gm_ccstamp.cc_val+i)
              if v >= 0 and v <= 127 then
                reaper.MIDI_InsertCC(take, false, false, item_start, 0xB0, 0, i, v)
              end
            end
          end
          reaper.UpdateArrange()
          
          local track = reaper.GetMediaItemTrack(item)
          if track then
            reaper.MarkTrackItemsDirty(track,item)
          end
        end
      end
      
      --Host & track
      for f = 1, lvar.fcount do
        local tmp = GetTemplatePos(f, true)
        if tmp and (tmp.ptype == ptype.host or tmp.ptype == ptype.track) then
          if (tmp.printval or -1) ~= -1 then
            WriteFaderValuesToTracks(nil, tmp, f, tmp.printval)
          end
        end
      end
      
    end
    
    reaper.Undo_EndBlock('Print Values', -1)
  end
  
  function RemoteSetUp()
    remote_funcs['SK2_MODE_TOGGLE'] = Remote_ModeToggle
    remote_funcs['SK2_MODE_PLUGIN'] = Remote_ModeSet
    remote_funcs['SK2_MODE_INSTANCE'] = Remote_ModeSet
    remote_funcs['SK2_MODE_TRACK'] = Remote_ModeSet
    remote_funcs['SK2_ASSIGN_SWAP'] = Remote_AssignSwap
    remote_funcs['SK2_SET_STRIPPER_LAYER'] = Remote_SetStripperLayer
    remote_funcs['SK2_ENABLE_STRIPPER_LAYER'] = Remote_SetStripperLayer_Enable
    remote_funcs['SK2_LEARNFX'] = Remote_LearnFX
    remote_funcs['SK2_SET_GLOBALLAYOUT'] = Remote_GlobalLayout
    remote_funcs['SK2_TOGGLE_GLOBALLAYOUT'] = Remote_GlobalLayoutToggle
    remote_funcs['SK2_NEXTLAYER'] = Remote_NextLayer
    remote_funcs['SK2_PREVLAYER'] = Remote_PrevLayer
  end
  
  function Assign_GetDefaultGlobalHost_Tab(ptype, globalhost, trn, tguid, fxn, fxguid, pnum, pname, sscolor, fxmodule)
    local tab = {ptype = ptype,
                 cc = false,
                 cc14bit = 0,
                 ccchan = -1,
                 ccnum = -1,                            
                 
                 pnum = pnum,
                 ptrack = trn,
                 ptrguid = tguid,
                 pfxnum = fxn,
                 pfxguid = fxguid,
                 pfxmodule = fxmodule,
                 globalhost = globalhost,

                 pname = pname,
                 name = pname,
                 track = trn,
                 trguid = tguid,
                 troff = -1,
                 trparam = -1,
                 trsend = -1,
                 actionmon = 1,
                 actionid = -1,
                 code = -1,
                 codeval = 0,
                 buttype = 4,
                 butstates = 2,
                 defcc_val = nil,
                 sscolor = sscolor or 7,
                 ledon = nil,
                 exauto = false,
                 polarity = 0,
                 valtime = nil,
                 min = 0,
                 max = 1,
                 linkA = nil,
                 linkA_linkonly = nil,
                 linkB = nil,
                 linkA_mode = 1,
                 linkB_mode = 1,
                 ss_override = nil,
                 ss_override_sscolor = 0,
                 ss_override_name = 0,
                 butstates_array = {0,1},
                 butstates_array_ext = {0,0},
                 butstates_array_sscolor = {},
                 butstates_array_name = {},
                 lmode_ov = nil}
    return tab
  end

  function Assign_GetDefaultTrack_Tab(ptype, trn, tguid, trparam, trsend, pname, sscolor)
    local tab = {ptype = ptype,
                 cc = false,
                 cc14bit = 0,
                 ccchan = -1,
                 ccnum = -1,                            
                 
                 pnum = nil,
                 ptrack = nil,
                 ptrguid = nil,
                 pfxnum = nil,
                 pfxguid = nil,
                 globalhost = 0,
  
                 pname = pname,
                 name = pname,
                 track = trn,
                 trguid = tguid,
                 troff = -1,
                 trparam = trparam,
                 trsend = trsend,
                 actionmon = 1,
                 actionid = -1,
                 code = -1,
                 codeval = 0,
                 buttype = 4,
                 butstates = 2,
                 defcc_val = nil,
                 sscolor = sscolor or 7,
                 ledon = nil,
                 exauto = false,
                 polarity = 0,
                 valtime = nil,
                 min = 0,
                 max = 1,
                 linkA = nil,
                 linkA_linkonly = nil,
                 linkB = nil,
                 linkA_mode = 1,
                 linkB_mode = 1,
                 ss_override = nil,
                 ss_override_sscolor = 0,
                 ss_override_name = 0,
                 butstates_array = {0,1},
                 butstates_array_ext = {0,0},
                 butstates_array_sscolor = {},
                 butstates_array_name = {},
                 lmode_ov = nil}
    return tab
  end

  function Assign_GetDefaultInternal_Tab(ptype, code, codeval, butstates, butstates_array, butstates_array_ext, pname, sscolor)
    local tab = {ptype = ptype,
                 cc = false,
                 cc14bit = 0,
                 ccchan = -1,
                 ccnum = -1,                            
                 
                 pnum = nil,
                 ptrack = nil,
                 ptrguid = nil,
                 pfxnum = nil,
                 pfxguid = nil,
                 globalhost = 0,
  
                 pname = pname,
                 name = pname,
                 track = nil,
                 trguid = nil,
                 troff = -1,
                 trparam = nil,
                 trsend = nil,
                 actionmon = 1,
                 actionid = -1,
                 code = code,
                 codeval = codeval,
                 buttype = 4,
                 butstates = butstates,
                 defcc_val = nil,
                 sscolor = sscolor or 7,
                 ledon = nil,
                 exauto = false,
                 polarity = 0,
                 valtime = nil,
                 min = 0,
                 max = 1,
                 linkA = nil,
                 linkA_linkonly = nil,
                 linkB = nil,
                 linkA_mode = 1,
                 linkB_mode = 1,
                 ss_override = nil,
                 ss_override_sscolor = 0,
                 ss_override_name = 0,
                 butstates_array = butstates_array,
                 butstates_array_ext = butstates_array_ext,
                 butstates_array_sscolor = {},
                 butstates_array_name = {},
                 lmode_ov = nil}
    return tab
  end
  
  function Remote_GlobalLayoutToggle(_, data)
  
    lvar.showglobalmap = not lvar.showglobalmap
    TemplateChanged()
    --BState_DelReset(i)
    lupd.update_gfx = true
  
  end

  function Remote_NextLayer(_, data)
  
    if lvar.showglobalmap then
      lvar.readparams = nil
      local p = lvar.currentglobalmap + 1
      if p > 16 then p = 1 end
      local fn
      if p == 1 then
        fn = paths.globtemplate_path..LBX_DEFGLOBALTMP
      else  
        fn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',p) ..'.smtemp'
      end
      LoadGlobalMap(fn, p)
      TemplateChanged()
      updatetravellingtracknames()
      lupd.update_gfx = true
    else
      if lvar.overtemplate == lvar.overtmp_cnt then 
        if lvar.overtemplate_active == true then
          lvar.overtemplate_active = false                    
        else
          lvar.overtemplate_active = true
          lvar.overtemplate = 1
        end
      else
        if lvar.overtemplate_active == true then
          lvar.overtemplate = lvar.overtemplate + 1
        else
          lvar.overtemplate_active = true                    
        end
      end
      
      TemplateChanged()
      lupd.update_gfx = true
      --tmp.bstate = 1
    end
  
  end
  
  function Remote_PrevLayer(_, data)
  
    if lvar.showglobalmap then
      lvar.readparams = nil
      local p = lvar.currentglobalmap - 1
      if p < 1 then p = 16 end
      local fn
      if p == 1 then
        fn = paths.globtemplate_path..LBX_DEFGLOBALTMP
      else  
        fn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',p) ..'.smtemp'
      end
      LoadGlobalMap(fn, p)
      TemplateChanged()
      updatetravellingtracknames()
      lupd.update_gfx = true
    else
      if lvar.overtemplate == 1 then 
        if lvar.overtemplate_active == true then
          lvar.overtemplate_active = false
        else
          lvar.overtemplate_active = true          
          lvar.overtemplate = lvar.overtmp_cnt
        end
      else
        if lvar.overtemplate_active == true then          
          lvar.overtemplate = lvar.overtemplate - 1
        else
          lvar.overtemplate_active = true                    
        end
      end
      
      TemplateChanged()
      lupd.update_gfx = true
      --tmp.bstate = 1
    end
  end
  
  function Remote_GlobalLayout(_, data)
    if tonumber(data) >= 1 and tonumber(data) <= 1 then
      lvar.readparams = nil
      local p = tonumber(data)
      if lvar.currentglobalmap ~= p then
        local fn
        if p == 1 then
          fn = paths.globtemplate_path..LBX_DEFGLOBALTMP
        else  
          fn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',p) ..'.smtemp'
        end
        LoadGlobalMap(fn, p) 
        lvar.showglobalmap = true
        
      elseif lvar.showglobalmap then
        lvar.showglobalmap = false
      else
        lvar.showglobalmap = true
        if lvar.globmapdata[p] and lvar.globmapdata[p].setmode and lvar.globmapdata[p].setmode ~= -1 then
          SetMode(lvar.globmapdata[p].setmode)
        end
      end
      TemplateChanged()
      updatetravellingtracknames()
      BState_DelReset(i)
      lupd.update_gfx = true        
    end
  end
  
  function Remote_SetStripperLayer_Enable(_, data)
    if tonumber(data) == 1 then
      lvar.strippertemplate_active = true
    else
      lvar.strippertemplate_active = false
    end
    TemplateChanged()
  end

  function Remote_LearnFX(_, data)
    if lrnmode then
      local i = tonumber(data)
      if i and lvar.fadersidx[i] then
        LearnPlug(i)
      end
    end
  end
  
  function Remote_SetStripperLayer(_, data)
  
    lvar.readparams = nil
    
    local guids = GetAllTrackFXGUIDs()
    local tmpchanged = true
    local tmp = {dirty = {},
                 pos = {},
                 sft = {},
                 eft = {}}
    local solo = 0
    for key, ass in string.gmatch(data,'%[(.-)%](.-)\n') do
      if key == 'SOLO' then
        solo = tonumber(ass)
      else
        local fxguid, fxparam, fxparamname, sscolor = string.match(ass,'(.-)|(.-)|(.-)|(.*)')
        if fxguid and guids[fxguid] then
          local tguid = guids[fxguid].tguid
          local trn = guids[fxguid].trn
          local fxn = guids[fxguid].fxn
          
          local slot = lvar.ctlmapidx2[key]
          if slot then
            tmp.pos[slot] = Assign_GetDefaultGlobalHost_Tab(ptype.host , 1, trn, tguid, fxn, fxguid, tonumber(fxparam), fxparamname, tonumber(sscolor))
            --tmp.pos[slot] = GetDefaultGlobalHost_Tab(ptype.stripperlink , 1, nil, nil, nil, nil, nil, fxparamname, tonumber(sscolor))
            
            if ctl_template.fader[slot].lmode == 4 then
              
              local gmem = reaper.gmem_write
              tmp.pos[slot].butstates_arrayidx = {}
              
              for b = 1, tmp.pos[slot].butstates do
              
                if tmp.pos[slot].ptype == ptype.host then
                  tmp.pos[slot].butstates_arrayidx[math.ceil(tonumber(tmp.pos[slot].butstates_array[b]*100000))/100000] = b
                else
                  tmp.pos[ii].butstates_arrayidx[tmp.pos[slot].butstates_array[b]] = b
                end
               
              end
            end
            
            tmpchanged = true
          end
          
        else
          local slot = lvar.ctlmapidx2[key]
          if slot and solo == 1 then
            tmp.pos[slot] = Assign_GetDefaultGlobalHost_Tab(ptype.internal, 0, -99, '', -1, '', -1, '', 0)
          end
        end
      end
    end
    strippertemplate = tmp
    if tmpchanged then
      lvar.strippertemplate_active = true
      TemplateChanged()
    end
    
  end
  
  function Remote_AssignSwap(_, data)
    if data then
      local src, dst = string.match(data, '(%d+),(%d+)')
      src = tonumber(src)
      dst = tonumber(dst)
      if src and dst then
        src = src + 1
        dst = dst + 1
        tmp, gflag = GetTemplate(src, nil, true, true)
        if tmp then
          local temptmp = tmp.pos[src]
          tmp.pos[src] = tmp.pos[dst]
          tmp.pos[dst] = temptmp

          if gflag == 3 then
            lvar.saveperm_highlight = true
          elseif gflag == 2 then
            lvar.saveglob_highlight = true
          elseif gflag == 1 or gflag == 4 then
            lvar.save_highlight = true
          end
          lupd.update_gfx = true
          
          TemplateChanged()
        end
      end
    end
  end
  
  function Remote_ModeToggle()
    if lvar.mode == 1 then
      SetMode(3)
    else
      SetMode(1)    
    end  
  end

  function Remote_ModeSet(m)
    if m == 'SK2_MODE_PLUGIN' then
      SetMode(1)
    elseif m == 'SK2_MODE_INSTANCE' then
      SetMode(2)
    elseif m == 'SK2_MODE_TRACK' then
      SetMode(3)
    end
  end
  
  function CalcButtStates(pt, buttype, butstates)
    local gmem = reaper.gmem_read
    local butstates_array = {}
    local butstates_array_ext = {}
    local butstates_array_sscolor = {}
    local butstates_array_name = {}
    
    if buttype == 4 or buttype == 6 then
      local ccmult = 1
      if pt == ptype.cc then
        ccmult = 127
      end
      butstates = F_limit(butstates, 2, 32)
      for i = 1, butstates do
        butstates_array[i] = (1/(butstates-1))*(i-1)*ccmult
        if pt == ptype.cc then
          butstates_array[i] = math.floor(butstates_array[i])
        end
      end            
    else
      butstates = 1
      
      local ccmult = 1
      if pt == ptype.cc then
        ccmult = 127
      end
      butstates_array[1] = 1*ccmult
    end
    return butstates_array, butstates_array_ext
  end
  
  function SetUnlitFaderCols(amt)
    for i = 1, #ptype_info do
      ptype_info[i].dimcol = DimColour(ptype_info[i].col,amt)
    end
  end
  
  function DimColour(s, amt)
    if not s then return end
    local t = {}
    for i in s:gmatch("[%d%.]+") do 
      t[#t+1] = math.floor(tonumber(i)*amt)
    end
    return string.format('%i',t[1])..' '..string.format('%i',t[2])..' '..string.format('%i',t[3])
  end
  
  function AddPopUp()
      local fn = reaper.GetResourcePath().."/Scripts/LBX/LBX_SmartKnobs2_Properties.lua"
      lvar.popup_actid = reaper.AddRemoveReaScript(true, 0, fn, true)
      lvar.popup = fn
  end
  
  function SelectFader2(i, openpop, forcegflag)
  
    if not i then i = lvar.selectedfader end
    if i and ctl_template.fader[i] then

      local tmp, gflag
      local isopen = reaper.GetExtState(PUSCRIPT, 'IsOpen')
      if tonumber(isopen) and lvar.gflag and (lvar.selectfadermode == 0 or forcegflag) then
      
        gflag = lvar.gflag

        if gflag == 3 then
          tmp = permatemplate          
        elseif gflag == 2 then
          tmp = globtemplate
        elseif gflag == 4 and lvar.overtemplate_active then

          if template.layer and template.layer[lvar.overtemplate] then
            tmp = template.layer[lvar.overtemplate]
          else
            tmp = {pos = {}, dirty = {}}
          end
          
        elseif gflag == 4 and not lvar.overtemplate_active then

          if template.layer and template.layer[lvar.overtemplate] then
            tmp = template.layer[lvar.overtemplate]
          else
            tmp = {pos = {}, dirty = {}}
          end
                  
        else
          --gflag = 1
          tmp = template
        end
      
      else

        if lvar.selectfadermode == 0 then
        
          tmp, gflag = GetTemplate(i, nil, true, true)
          if lvar.showglobalmap then
            if gflag ~= 2 and gflag ~= 3 then
              gflag = 2
              tmp = {pos = {}, dirty = {}}            
            end        
          elseif gflag == 4 --[[and lvar.overtemplate_active]] then
            gflag = 4
          elseif gflag == 1 and lvar.overtemplate_active then
            if template.layer and template.layer[lvar.overtemplate] and template.layer[lvar.overtemplate].pos[i] then
              gflag = 4          
            end
            gflag = 4
            if template.layer and template.layer[lvar.overtemplate] then
              tmp = template.layer[lvar.overtemplate]
            else
              tmp = {pos = {}, dirty = {}}
            end
          end
          
        else
        
          tmp, gflag = GetTemplate(i, nil, true, true)
          if tmp.pos[i] == nil then
            if lvar.showglobalmap then
              if gflag ~= 2 and gflag ~= 3 then
                gflag = 2
                tmp = {pos = {}, dirty = {}}            
              end        
            elseif gflag == 4 --[[and lvar.overtemplate_active]] then
              gflag = 4
            elseif gflag == 1 and lvar.overtemplate_active then
              if template.layer and template.layer[lvar.overtemplate] and template.layer[lvar.overtemplate].pos[i] then
                gflag = 4          
              end
              gflag = 4
              if template.layer and template.layer[lvar.overtemplate] then
                tmp = template.layer[lvar.overtemplate]
              else
                tmp = {pos = {}, dirty = {}}
              end
            end
            
          end
          
        end
      end
      SelectFader(i, openpop, tmp, gflag)
    end
  end
  
  function SelectFader(i, openpop, tmp, gflag)
   
    if i and FFX then
      lvar.oselectedfader = i --lvar.selectedfader
      lvar.selectedfader = i
      
      --reaper.SetExtState(PUSCRIPT, '', , false)
      --DBG('gg'..gflag)
      tmp.dirty[i] = true
      lupd.update_fader = true
      --[[if gflag == 4 and not lvar.overtemplate_active then
        gflag = 1
      end]]
      
      lvar.gflag = gflag
      
      local tm = ''
      --DBG(gflag..'  '..lvar.overtemplate)
      if gflag == 2 then
        --gmap
        tm = lvar.globmapnames[lvar.currentglobalmap] or string.format('%i',lvar.currentglobalmap)
      elseif gflag == 1 or gflag == 4 then
        if lvar.mode == 3 then
          --track
          tm = FFX.trname
        else
          --plugin
          tm = FFX.fxname
        end
      end
      reaper.SetExtState(PUSCRIPT, 'focusmode', string.format('%i',lvar.mode), false)

      reaper.SetExtState(PUSCRIPT, 'targetmap', tm or '', false)
      reaper.SetExtState(PUSCRIPT, 'selfader', string.format('%i',i), false)
      reaper.SetExtState(PUSCRIPT, 'sscolormode', ctl_template.fader[i].sscolor or '', false)
      reaper.SetExtState(PUSCRIPT, 'layer', string.format('%i',lvar.overtemplate), false)
      local midimap = lvar.midimap[(ctl_template.fader[i].odevbus or ctl_template.fader[i].devbus)+1]
      reaper.SetExtState(PUSCRIPT, 'device', midimap or '', false)
      if tmp.pos[i] and ((tmp.pos[i].globalhost == 1 and (gflag == 2 or gflag == 3)) 
         or ((tmp.pos[i].globalhost or 0) == 2)) then
        local ptrack = tmp.pos[i].ptrack
        local ptr = GetTrack(ptrack)
        --Ensure correct FX is transferred
        local rptrn, rptrg, rpfxn
        if ptr then
          rptrn, rptrg, rpfxn = FindFX(ptr, reaper.GetTrackGUID(ptr), tmp.pos[i].pfxguid)
        else
          rptrn, rptrg, rpfxn = FindFX(nil, nil, tmp.pos[i].pfxguid)
        end
        --DBG('aa '..tostring(ptrack)..' '..tostring(rptrn)..' '..tostring(rpfxn))
        
        reaper.SetExtState(PUSCRIPT, 'foc_fx_trn', rptrn or tmp.pos[i].ptrack, false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_num', rpfxn or tmp.pos[i].pfxnum, false)
        --reaper.SetExtState(PUSCRIPT, 'foc_fx_trn', tmp.pos[i].ptrack, false)
        --reaper.SetExtState(PUSCRIPT, 'foc_fx_num', tmp.pos[i].pfxnum, false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_guid', tmp.pos[i].pfxguid or '', false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_itemnum', '', false) --edit when global take fx allowed
        reaper.SetExtState(PUSCRIPT, 'foc_fx_itemguid', '', false)

        reaper.SetExtState(PUSCRIPT, 'foc_fx_trn2', FFX.trn, false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_num2', FFX.fxnum, false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_guid2', FFX.fxguid or '', false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_itemnum2', FFX.itemnum or '', false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_itemguid2', FFX.itemguid or '', false)

      else
        reaper.SetExtState(PUSCRIPT, 'foc_fx_trn', FFX.trn, false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_num', FFX.fxnum, false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_guid', FFX.fxguid or '', false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_itemnum', FFX.itemnum or '', false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_itemguid', FFX.itemguid or '', false)

        reaper.SetExtState(PUSCRIPT, 'foc_fx_trn2', FFX.trn, false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_num2', FFX.fxnum, false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_guid2', FFX.fxguid or '', false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_itemnum2', FFX.itemnum or '', false)
        reaper.SetExtState(PUSCRIPT, 'foc_fx_itemguid2', FFX.itemguid or '', false)
      end
      
      --This works by lvar.ssnumidx holding ctl_template.fader idx - from the ctl_template.fader you get devbus and ssnum
      --Remember to check sscolormode for each
      local ss_cnt = #lvar.ssnumidx
      reaper.SetExtState(PUSCRIPT, 'sscount', ss_cnt, false)
      for ss_i = 1, ss_cnt --[[#lvar.ssnumidx]] do
        --if cm is 1 or 2 - then valid for color
        if lvar.ssnumidx[ss_i] then
          reaper.SetExtState(PUSCRIPT, 'ss_colormode_'..string.format('%i',ss_i), ctl_template.fader[lvar.ssnumidx[ss_i]].sscolor or '', false)
          reaper.SetExtState(PUSCRIPT, 'ss_ssnum_'..string.format('%i',ss_i), ctl_template.fader[lvar.ssnumidx[ss_i]].ssnum or '', false)
          reaper.SetExtState(PUSCRIPT, 'ss_ssnumdev_'..string.format('%i',ss_i), ctl_template.fader[lvar.ssnumidx[ss_i]].devbus or '', false)
        else
          reaper.SetExtState(PUSCRIPT, 'ss_colormode_'..string.format('%i',ss_i), '', false)
          reaper.SetExtState(PUSCRIPT, 'ss_ssnum_'..string.format('%i',ss_i), '', false)
          reaper.SetExtState(PUSCRIPT, 'ss_ssnumdev_'..string.format('%i',ss_i), '', false)
        end
      end
      
      if tmp.pos[i] then
        reaper.SetExtState(PUSCRIPT, 'emptyslot', 0, false)
        reaper.SetExtState(PUSCRIPT, 'gflag', gflag, false)
        
        reaper.SetExtState(PUSCRIPT, 'ctlname', ctl_template.fader[i].devctl, false)
        reaper.SetExtState(PUSCRIPT, 'devbus', ctl_template.fader[i].odevbus or ctl_template.fader[i].devbus, false)
        --reaper.SetExtState(PUSCRIPT, 'ssnum', ctl_template.fader[i].ssnum or '', false)
        
        reaper.SetExtState(PUSCRIPT, 'lmode', ctl_template.fader[i].lmode, false)

        --local tt = reaper.time_precise()
        local tmpdata_sk2 = pickle(tmp.pos[i])
        --DBG('pickle '..reaper.time_precise()-tt)

        reaper.SetExtState(PUSCRIPT, 'tmpdata_sk2', tmpdata_sk2, false)
        --DBG('extstate '..reaper.time_precise()-tt)

        --[[reaper.SetExtState(PUSCRIPT, 'ptype', tmp.pos[i].ptype or 1, false)
        reaper.SetExtState(PUSCRIPT, 'pname', tmp.pos[i].pname, false)
        reaper.SetExtState(PUSCRIPT, 'name', tmp.pos[i].name or '', false)
        reaper.SetExtState(PUSCRIPT, 'cc', tostring(tmp.pos[i].cc), false)
        reaper.SetExtState(PUSCRIPT, 'cc14bit', tmp.pos[i].cc14bit or 0, false)
        reaper.SetExtState(PUSCRIPT, 'ccchan', tmp.pos[i].ccchan, false)
        reaper.SetExtState(PUSCRIPT, 'ccnum', tmp.pos[i].ccnum, false)
        
        reaper.SetExtState(PUSCRIPT, 'pnum', tmp.pos[i].pnum, false)
        
       
        
        reaper.SetExtState(PUSCRIPT, 'track', tmp.pos[i].track or -1, false)
        reaper.SetExtState(PUSCRIPT, 'trguid', tmp.pos[i].trguid or '', false)
        reaper.SetExtState(PUSCRIPT, 'trparam', tmp.pos[i].trparam or -1, false)
        reaper.SetExtState(PUSCRIPT, 'trsend', tmp.pos[i].trsend or -1, false)
        reaper.SetExtState(PUSCRIPT, 'troff', tmp.pos[i].troff or 0, false)
        reaper.SetExtState(PUSCRIPT, 'actionid', tmp.pos[i].actionid or '', false)
        reaper.SetExtState(PUSCRIPT, 'actionmon', tmp.pos[i].actionmon or 0, false)
        reaper.SetExtState(PUSCRIPT, 'buttype', tmp.pos[i].buttype or 4, false)
        reaper.SetExtState(PUSCRIPT, 'butstates', tmp.pos[i].butstates or 2, false)
        reaper.SetExtState(PUSCRIPT, 'code', tmp.pos[i].code or -1, false)
        reaper.SetExtState(PUSCRIPT, 'codeval', tmp.pos[i].codeval or 0, false)
        reaper.SetExtState(PUSCRIPT, 'enc_res', tmp.pos[i].enc_res or 128, false)
        reaper.SetExtState(PUSCRIPT, 'defcc_val', tmp.pos[i].defcc_val or '', false)
        reaper.SetExtState(PUSCRIPT, 'sscolor', tmp.pos[i].sscolor or 7, false)
        reaper.SetExtState(PUSCRIPT, 'ledon', tmp.pos[i].ledon or '', false)
        reaper.SetExtState(PUSCRIPT, 'exauto', tmp.pos[i].exauto or 0, false)
        reaper.SetExtState(PUSCRIPT, 'polarity', tmp.pos[i].polarity or 0, false)
        reaper.SetExtState(PUSCRIPT, 'valtime', tmp.pos[i].valtime or -1, false)

        reaper.SetExtState(PUSCRIPT, 'linkA', tmp.pos[i].linkA or '', false)
        reaper.SetExtState(PUSCRIPT, 'linkA_linkonly', tmp.pos[i].linkA_linkonly or '', false)
        reaper.SetExtState(PUSCRIPT, 'linkB', tmp.pos[i].linkB or '', false)
        reaper.SetExtState(PUSCRIPT, 'linkA_mode', tmp.pos[i].linkA_mode or 1, false)
        reaper.SetExtState(PUSCRIPT, 'linkB_mode', tmp.pos[i].linkB_mode or 1, false)

        reaper.SetExtState(PUSCRIPT, 'ss_override', tmp.pos[i].ss_override or '', false)
        reaper.SetExtState(PUSCRIPT, 'ss_override_sscolor', tmp.pos[i].ss_override_sscolor or 0, false)
        reaper.SetExtState(PUSCRIPT, 'ss_override_name', tmp.pos[i].ss_override_name or 0, false)]]
        
        --reaper.SetExtState(PUSCRIPT, '', tmp.pos[i]., false)

        --[[if ctl_template.fader[i].lmode == 4 then
          local gmem = reaper.gmem_write
          if not tmp.pos[i].butstates_array then
            tmp.pos[i].butstates_array = {}
            tmp.pos[i].butstates_array_ext = {}
            tmp.pos[i].butstates_array_sscolor = {}
            tmp.pos[i].butstates_array_name = {}
          end
          for b = 1, 32 do
            if tmp.pos[i].butstates_array and tmp.pos[i].butstates_array[b] then
              gmem(lvar.gm_fb.bsarraytransfer + b-1, tmp.pos[i].butstates_array[b])
            else
              gmem(lvar.gm_fb.bsarraytransfer + b-1, -1)            
            end 
            if tmp.pos[i].butstates_array_ext and tmp.pos[i].butstates_array_ext[b] then
              gmem(lvar.gm_fb.bsarraytransferext + b-1, tmp.pos[i].butstates_array_ext[b])
            else
              gmem(lvar.gm_fb.bsarraytransferext + b-1, 0)
            end 
            if tmp.pos[i].butstates_array_sscolor and tmp.pos[i].butstates_array_sscolor[b] then
              gmem(lvar.gm_fb.bsarraytransfersscolor + b-1, tmp.pos[i].butstates_array_sscolor[b])
            else
              gmem(lvar.gm_fb.bsarraytransfersscolor + b-1, -1)
            end 
            local key = 'ssvname_'..string.format('%i',b)
            reaper.SetExtState(PUSCRIPT, key, tmp.pos[i].butstates_array_name[b] or '', false)
          end
        end]]

      else

        reaper.SetExtState(PUSCRIPT, 'emptyslot', 1, false)
        reaper.SetExtState(PUSCRIPT, 'gflag', gflag, false)

        reaper.SetExtState(PUSCRIPT, 'ctlname', ctl_template.fader[i].devctl, false)
        reaper.SetExtState(PUSCRIPT, 'devbus', ctl_template.fader[i].odevbus or ctl_template.fader[i].devbus, false)
        reaper.SetExtState(PUSCRIPT, 'lmode', ctl_template.fader[i].lmode, false)
        
      end
      
      --end
      WriteLayerData(gflag, i)
      
      reaper.SetExtState(PUSCRIPT, 'readdirty', 1, false)
      if openpop then
        local isopen = reaper.GetExtState(PUSCRIPT, 'IsOpen')
        if not tonumber(isopen) then
          reaper.Main_OnCommand(lvar.popup_actid, 0)
          --dofile(lvar.popup)
        elseif reaper.JS_Window_SetZOrder then
          --bring to front
          local hwnd = reaper.JS_Window_Find('SK2 FADER PROPERTIES',true)
          if hwnd then
            reaper.JS_Window_SetZOrder(hwnd, 'TOP', hwnd)
          end
        end
      end
    end
  end
  
  function WriteLayerData(gflag, i)

    local tmp
    
    if gflag == 3 then
      tmp = permatemplate
    elseif gflag == 2 then
      tmp = globtemplate
    elseif gflag == 4 then
      if --[[lvar.overtemplate_active and]] template.layer and template.layer[lvar.overtemplate] then
        tmp = template.layer[lvar.overtemplate]
      else
        tmp = {pos = {}}
      end
    elseif gflag == 1 then
      tmp = template
    end
  
    --clear data
    --reaper.SetExtState(PUSCRIPTDATA, '', , false)
  
    local dev = ctl_template.fader[i].devbus
    
    if tmp then

      reaper.SetExtState(PUSCRIPTDATA, 'alldevctl_cnt', lvar.fcount, false)
      for f = 1, lvar.fcount do
      
        if ctl_template.fader[f].devbus == dev then
        
          local ctlname = ctl_template.fader[f].devctl
          if tmp.pos[f] then
            reaper.SetExtState(PUSCRIPTDATA, ctlname..'_col', tmp.pos[f].ptype, false)
          else
            reaper.SetExtState(PUSCRIPTDATA, ctlname..'_col', '', false)
          end
          local perm = false
          if permatemplate.pos[f] then
            perm = true
          end
          reaper.SetExtState(PUSCRIPTDATA, ctlname..'_perm', tostring(perm), false)
        
        end
        
        local ctlname = ctl_template.fader[f].devbus..'|'..ctl_template.fader[f].devctl
        local key = 'alldevctl_'..string.format('%i', f)
        
        reaper.SetExtState(PUSCRIPTDATA, key, ctlname, false)
        
        if tmp.pos[f] then
          reaper.SetExtState(PUSCRIPTDATA, ctlname..'_fader', f, false)
          reaper.SetExtState(PUSCRIPTDATA, ctlname..'_name', tmp.pos[f].pname or tmp.pos[f].name, false)
          reaper.SetExtState(PUSCRIPTDATA, ctlname..'_lmode', ctl_template.fader[f].lmode, false)
        else
          reaper.SetExtState(PUSCRIPTDATA, ctlname..'_fader', -1, false)
          reaper.SetExtState(PUSCRIPTDATA, ctlname..'_name', '', false)
          reaper.SetExtState(PUSCRIPTDATA, ctlname..'_lmode', ctl_template.fader[f].lmode, false)
        end
        
      
      end
    end
    
  end
  
  function RebuildSharedLinks(tmp)

    local links = {}
    for f = 1, lvar.fcount do
      if tmp.pos[f] then
        local la = tmp.pos[f].linkA or tmp.pos[f].linkA_linkonly
        if la then
          links[la] = {idx = f,
                       linkB = string.format('%i',ctl_template.fader[f].devbus) .. '|' .. ctl_template.fader[f].devctl
                       }
          if tmp.pos[f].linkA then
            links[la].linkonly = false
          else
            links[la].linkonly = true
          end
        elseif tmp.pos[f].linkB then
          tmp.pos[f].linkB = nil
          local lidx = lvar.ctlmapidx[tmp.pos[f].linkB]
          if lidx and tmp.pos[lidx] and tmp.pos[lidx].linkA then
            tmp.pos[f].ss_override = nil
          end
        end
      end
    end
  
    for f = 1, lvar.fcount do
      local lidx = string.format('%i',ctl_template.fader[f].devbus) .. '|' .. ctl_template.fader[f].devctl
      if tmp.pos[f] and links[lidx] then
        tmp.pos[f].linkB = links[lidx].linkB
        if links[lidx].linkonly ~= true then
          tmp.pos[f].ss_override = tmp.pos[links[lidx].idx].ss_override or ctl_template.fader[links[lidx].idx].ssnum
        end
      end
    end
    
  end
  
  function ReadExtParamData()
  
    lvar.readparams = nil
  
    local i = lvar.selectedfader
    if i and i ~= -1 then
    
      local tmp
      lvar.gflag = tonumber(reaper.GetExtState(PUSCRIPT, 'gflag'))
      local gflag = lvar.gflag
      if gflag then
        if gflag == 3 then
          tmp = permatemplate
          --pglob = true        
        elseif gflag == 2 then
          tmp = globtemplate
          --glob = true
        elseif gflag == 4 --[[and lvar.overtemplate_active]] then
          if not template.layer then
            template.layer = {}
          end
          if not template.layer[lvar.overtemplate] then
            template.layer[lvar.overtemplate] = {dirty = {},
                                                pos = {},
                                                sft = {},
                                                eft = {}}
          end
          tmp = template.layer[lvar.overtemplate]
        elseif gflag == 1 then
          tmp = template
        end
      else
        tmp, gflag = GetTemplate(i)
        --[[if permatemplate.pos[i] then
          tmp = permatemplate
          pglob = true        
        elseif globtemplate.pos[i] and lvar.showglobalmap then
          tmp = globtemplate
          glob = true
        else
          tmp = template
        end]]
      end
      
      
      local globalhost
      if tmp and tmp.pos[i] then
        if (tmp.pos[i].globalhost or 0) >= 1 then
          globalhost = tmp.pos[i].globalhost
        end
      end
      --DBG(globalhost)
      --local ctlname = reaper.GetExtState(PUSCRIPT, 'ctlname')
      --local devbus = tonumber(reaper.GetExtState(PUSCRIPT, 'devbus')) or ''
      --local lmode = tonumber(reaper.GetExtState(PUSCRIPT, 'lmode')) or -1
      if tmp then
        tmp.pos[i] = {}
        local tdata_sk2 = reaper.GetExtState(PUSCRIPT, 'tmpdata_sk2_apply')
        tmp.pos[i] = unpickle(tdata_sk2)
        --tmp.pos[i].ptype = tonumber(reaper.GetExtState(PUSCRIPT, 'ptype')) or 1
        --tmp.pos[i].pname = reaper.GetExtState(PUSCRIPT, 'pname') or ''
        if tmp.pos[i].name == '' then
          tmp.pos[i].name = nil
        end
        if tmp.pos[i].ptype == ptype.cc then
          tmp.pos[i].cc = true
        else
          tmp.pos[i].cc = false        
        end
        --[[tmp.pos[i].cc14bit = tonumber(reaper.GetExtState(PUSCRIPT, 'cc14bit')) or 0
        tmp.pos[i].ccchan = tonumber(reaper.GetExtState(PUSCRIPT, 'ccchan')) or -1
        tmp.pos[i].ccnum = tonumber(reaper.GetExtState(PUSCRIPT, 'ccnum')) or -1
        tmp.pos[i].pnum = tonumber(reaper.GetExtState(PUSCRIPT, 'pnum')) or -1]]
        --DBG(tmp.pos[i].loc)
        if tmp.pos[i].ptype == ptype.host and (gflag == 2 or gflag == 3) and FFX then
          --Set as global host parameter
          local ptrn = tonumber(reaper.GetExtState(PUSCRIPT, 'foc_fx_trn'))
          local pfxnum = tonumber(reaper.GetExtState(PUSCRIPT, 'foc_fx_num'))
          local pfxguid = tonumber(reaper.GetExtState(PUSCRIPT, 'foc_fx_guid'))
          
          tmp.pos[i].ptrack = ptrn
          local track = GetTrack(ptrn)
          if track then
            tmp.pos[i].ptrguid = reaper.GetTrackGUID(track)
            tmp.pos[i].pfxnum = pfxnum
            tmp.pos[i].pfxguid = reaper.TrackFX_GetFXGUID(track, pfxnum)
            tmp.pos[i].globalhost = globalhost or 1
            if tmp.pos[i].pfxnum ~= -1 then
              _, tmp.pos[i].pfxmodule = reaper.BR_TrackFX_GetFXModuleName(track, pfxnum)
            end
          else
            reaper.MB('Error applying data - track not found','Apply',0)
          end
          
        elseif tmp.pos[i].ptype == ptype.host then
          local gh = 0
          if lvar.mode == 3 then
            gh = 2
          end
          tmp.pos[i].globalhost = globalhost or gh
          if tmp.pos[i].globalhost == 0 then
            tmp.pos[i].ptrack = -99
            tmp.pos[i].pfxnum = -1
            tmp.pos[i].pfxguid = nil
            tmp.pos[i].ptrguid = nil
          else
            if tonumber(reaper.GetExtState(PUSCRIPT, 'UpdateFocFX')) == 1 then
              local ptrn = tonumber(reaper.GetExtState(PUSCRIPT, 'foc_fx_trn'))
              local pfxnum = tonumber(reaper.GetExtState(PUSCRIPT, 'foc_fx_num'))
              local pfxguid = tonumber(reaper.GetExtState(PUSCRIPT, 'foc_fx_guid'))
              tmp.pos[i].ptrack = ptrn
              local track = GetTrack(ptrn)
              tmp.pos[i].ptrguid = reaper.GetTrackGUID(track)
              tmp.pos[i].pfxnum = pfxnum
              tmp.pos[i].pfxguid = reaper.TrackFX_GetFXGUID(track, pfxnum)
              --tmp.pos[i].globalhost = globalhost or 1
              --_, tmp.pos[i].pfxmodule = reaper.BR_TrackFX_GetFXModuleName(track, pfxnum)
            end
          end
          if tmp.pos[i].pfxnum ~= -1 then
            local track = GetTrack(tmp.pos[i].ptrack)
            if track then
              _, tmp.pos[i].pfxmodule = reaper.BR_TrackFX_GetFXModuleName(track, tmp.pos[i].pfxnum)
            end
          end
        end
        reaper.SetExtState(PUSCRIPT, 'UpdateFocFX', 0, false)
        
        --[[
        tmp.pos[i].track = tonumber(reaper.GetExtState(PUSCRIPT, 'track')) or -1
        tmp.pos[i].trguid = reaper.GetExtState(PUSCRIPT, 'trguid') or ''
        tmp.pos[i].trparam = tonumber(reaper.GetExtState(PUSCRIPT, 'trparam'))
        tmp.pos[i].trsend = tonumber(reaper.GetExtState(PUSCRIPT, 'trsend'))
        tmp.pos[i].troff = tonumber(reaper.GetExtState(PUSCRIPT, 'troff')) or -1
        tmp.pos[i].actionid = reaper.GetExtState(PUSCRIPT, 'actionid') or -1
        tmp.pos[i].actionmon = tonumber(reaper.GetExtState(PUSCRIPT, 'actionmon')) or 0
        tmp.pos[i].buttype = tonumber(reaper.GetExtState(PUSCRIPT, 'buttype')) or 4
        tmp.pos[i].butstates = tonumber(reaper.GetExtState(PUSCRIPT, 'butstates')) or 2
        tmp.pos[i].code = tonumber(reaper.GetExtState(PUSCRIPT, 'code')) or -1
        tmp.pos[i].codeval = tonumber(reaper.GetExtState(PUSCRIPT, 'codeval')) or 0
        tmp.pos[i].enc_res = tonumber(reaper.GetExtState(PUSCRIPT, 'enc_res')) or 128
        tmp.pos[i].defcc_val = tonumber(reaper.GetExtState(PUSCRIPT, 'defcc_val'))
        --if ctl_template.fader[i].sscolor then
          tmp.pos[i].sscolor = tonumber(reaper.GetExtState(PUSCRIPT, 'sscolor'))          
        --end
        tmp.pos[i].ledon = tonumber(reaper.GetExtState(PUSCRIPT, 'ledon'))
        tmp.pos[i].exauto = tonumber(reaper.GetExtState(PUSCRIPT, 'exauto'))
        tmp.pos[i].polarity = tonumber(reaper.GetExtState(PUSCRIPT, 'polarity')) or 0

        tmp.pos[i].valtime = tonumber(reaper.GetExtState(PUSCRIPT, 'valtime')) or -1
        if tmp.pos[i].valtime == -1 then
          tmp.pos[i].valtime = nil
        end

        tmp.pos[i].linkA = zn(reaper.GetExtState(PUSCRIPT, 'linkA'))
        tmp.pos[i].linkA_linkonly = zn(reaper.GetExtState(PUSCRIPT, 'linkA_linkonly'))
        tmp.pos[i].linkB = zn(reaper.GetExtState(PUSCRIPT, 'linkB'))
        tmp.pos[i].linkA_mode = tonumber(reaper.GetExtState(PUSCRIPT, 'linkA_mode')) or 1
        tmp.pos[i].linkB_mode = tonumber(reaper.GetExtState(PUSCRIPT, 'linkB_mode')) or 1
        
        --Process link data here
        --remove any old linkB matched to this slot
        
        --[[for f = 1, lvar.fcount do
          if tmp.pos[f] and tmp.pos[f].linkB == tmp.pos[i].linkA then
            tmp.pos[f].linkB = nil
            tmp.pos[f].ss_override = nil
          end
        end
        if tmp.pos[i].linkA then
          tmp.pos[i].linkB = nil
          
          --add new linkB
          local idx = lvar.ctlmapidx[tmp.pos[i].linkA]
          if idx then
            tmp.pos[idx].linkB = string.format('%i',ctl_template.fader[i].devbus) .. '|' .. ctl_template.fader[i].devctl
            tmp.pos[idx].ss_override = ctl_template.fader[i].ssnum
          end
        end] ]
        
        tmp.pos[i].ss_override = tonumber(reaper.GetExtState(PUSCRIPT, 'ss_override'))
        tmp.pos[i].ss_override_sscolor = tonumber(reaper.GetExtState(PUSCRIPT, 'ss_override_sscolor')) or 0
        tmp.pos[i].ss_override_name = tonumber(reaper.GetExtState(PUSCRIPT, 'ss_override_name')) or 0
        ]]
        RebuildSharedLinks(tmp)
        
        if tmp.pos[i].cc14bit == 1 and tmp.pos[i].ccnum > 31 then
          tmp.pos[i].cc14bit = 0
        end
        
        --[[local name = reaper.GetExtState(PUSCRIPT, 'name')
        if name ~= '' then
          tmp.pos[i].name = name
        end]]
  
        if tmp.pos[i].ptype == ptype.cc then
          
        end
  
        --tmp.pos[i].butstates_array = {}
        tmp.pos[i].butstates_arrayidx = {}
        --tmp.pos[i].butstates_array_ext = {}
        --tmp.pos[i].butstates_array_sscolor = {}
        --tmp.pos[i].butstates_array_name = {}
        if ctl_template.fader[i].lmode == 4 then
          local gmem = reaper.gmem_read
          for b = 1, tmp.pos[i].butstates do
            --local v = gmem(lvar.gm_fb.bsarraytransfer + b-1)
            --tmp.pos[i].butstates_array[b] = v
            local v = tmp.pos[i].butstates_array[b]
            if tmp.pos[i].ptype == ptype.host then
              tmp.pos[i].butstates_arrayidx[math.ceil(tonumber(v*100000))/100000] = b
            else
              tmp.pos[i].butstates_arrayidx[tmp.pos[i].butstates_array[b]] = b
            end
            
            --[[local v = gmem(lvar.gm_fb.bsarraytransferext + b-1)
            tmp.pos[i].butstates_array_ext[b] = v
            local v = gmem(lvar.gm_fb.bsarraytransfersscolor + b-1)
            if v ~= -1 then
              tmp.pos[i].butstates_array_sscolor[b] = v
            end]]
            --[[local key = 'ssvname_'..string.format('%i',b)
            local v = reaper.GetExtState(PUSCRIPT, key)
            if (v or '') ~= '' then
              tmp.pos[i].butstates_array_name[b] = v
            end]]
          end
          if #tmp.pos[i].butstates_array > tmp.pos[i].butstates then
            for b = tmp.pos[i].butstates+1, #tmp.pos[i].butstates_array do
              tmp.pos[i].butstates_array[b] = nil
            end
          end
        end

        --DBG('get '..i..'  '..tmp.pos[i].butstates..'  '..#tmp.pos[i].butstates_array)
        
        TemplateChanged()

        if gflag == 3 then
          lvar.saveperm_highlight = true
        elseif gflag == 2 then
          lvar.saveglob_highlight = true
        elseif gflag == 1 or gflag == 4 then
          lvar.save_highlight = true
        end
        lupd.update_gfx = true    
      end
    end
  
  end
  
  function ClearSelectedFader(gflag)
  
    local i = lvar.selectedfader
    
    if i and gflag then
      if gflag == 3 then
        tmp = permatemplate
      elseif gflag == 2 then
        tmp = globtemplate
      elseif gflag == 4 and lvar.overtemplate_active and template.layer and template.layer[lvar.overtemplate] and template.layer[lvar.overtemplate].pos[i] then
        tmp = template.layer[lvar.overtemplate]
      elseif gflag == 1 then
        tmp = template
      end

      if tmp then      
        lvar.readparams = nil
        
        tmp.pos[i] = nil
        tmp.dirty[i] = true
        lupd.update_fader = true
        SetCCs()
        updatetravellingtracknames(true)
      
        if gflag == 3 then
          lvar.saveperm_highlight = true
        elseif gflag == 2 then
          lvar.saveglob_highlight = true
        elseif gflag == 1 or gflag == 4 then
          lvar.save_highlight = true
        end
        SelectFader2(i, true)
        lupd.update_gfx = true
      end
    end
    
  end

  ------------------------------------------------------------

  function Env_AutoShow()
    --DBGOut('Env_AutoShow')
    if lvar.recenvdata then
      reaper.PreventUIRefresh(1)
      --reaper.Main_OnCommand(40889, -1)
      reaper.Undo_BeginBlock()
      local s = lvar.env_autoshow_bank*lvar.env_autoshow_cnt +1
      local vcnt = 0
      for i = 1, #lvar.recenvdata do
        if lvar.autoenv_solo then
          if i == lvar.autoenv_solo then
            VisEnv(lvar.recenvdata[i].env, true)
          else
            VisEnv(lvar.recenvdata[i].env, false)                  
          end
        else
          if (lvar.autoenv_mode ~= 2) or not lvar.trackenvs.envidx[tostring(lvar.recenvdata[i].env)] then    
            if i >= s and lvar.recenvdata[i].exauto ~= 1 and vcnt < lvar.env_autoshow_cnt then
              vcnt = vcnt + 1
              VisEnv(lvar.recenvdata[i].env, true)
            else
              VisEnv(lvar.recenvdata[i].env, false)                  
            end
          end
        end
      end
      
      Update_Envelopes()
      
      reaper.Undo_EndBlock("Envelope bank change", 0)      
    
      reaper.PreventUIRefresh(-1)
    end
    --DBGOut('exit func: Env_AutoShow')
  end

  function GetTrackEnvelopes_State(trn, hide)
    --DBGOut('GetTrackEnvelopes_State')
  
    local tab = {}
    local tr = GetTrack(trn)
    --local _, tn = reaper.GetTrackName(tr)
    --DBG(tn)
    if tr then
      for i = 0, reaper.CountTrackEnvelopes(tr)-1 do
  
        local env = reaper.GetTrackEnvelope(tr, i)
        if env then
          --Set index
          --reaper.GetSetEnvelopeInfo_String(env, 'P_EXT:LBX_ID', i, true)
          local _, chunk = reaper.GetEnvelopeStateChunk(env,'',false)
          local idname = string.match(chunk, '<(.-)\n')
          local dtr = reaper.BR_GetMediaTrackSendInfo_Track(tr,0,i,1)
          local guid = ''
          if dtr then
            guid = reaper.GetTrackGUID(dtr)
          end
          
          local br_env = reaper.BR_EnvAlloc(env, false)                        
          local active, visible, armed, inLane, laneHeight = reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
          reaper.BR_EnvFree(br_env, false)
          tab[i] = {id = idname..guid, i = i, trn = trn, env = env,
                   active = active,
                   visible = visible,
                   armed = armed,
                   inlane = inLane,
                   laneheight = laneHeight}
          local _, envname = reaper.GetEnvelopeName(env)
          
          --Hide envelope
          --if hide then
          --  VisEnv(env, false)
          --end
        end
      end
      
      --reaper.SetOnlyTrackSelected(tr)
      --reaper.Main_OnCommand(reaper.NamedCommandLookup('_BR_SHOW_SEND_ENV_ALL_SEL_TRACK'), -1)]]
      if hide and lvar.autoenv then
        reaper.SetOnlyTrackSelected(tr)
        reaper.Main_OnCommand(40889, -1)        
      end
      
    end
    
    --DBGOut('exit func: GetTrackEnvelopes_State')
    return tab    
  end

  function GetTakeEnvelopes_State(take, hide)
    --DBGOut('GetTakeEnvelopes_State')
  
    local tab = {}
    local tr = GetTrack(trn)
    if tr then
      for i = 0, reaper.CountTakeEnvelopes(take)-1 do
  
        local env = reaper.GetTakeEnvelope(take, i)
        if env then
          --Set index
          --reaper.GetSetEnvelopeInfo_String(env, 'P_EXT:LBX_ID', i, true)
          local _, chunk = reaper.GetEnvelopeStateChunk(env,'',false)
          local idname = string.match(chunk, '<(.-)\n')
          --[[local dtr = reaper.BR_GetMediaTrackSendInfo_Track(tr,0,i,1)
          local guid = ''
          if dtr then
            guid = reaper.GetTrackGUID(dtr)
          end]]
          
          local br_env = reaper.BR_EnvAlloc(env, false)                        
          local active, visible, armed, inLane, laneHeight = reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
          reaper.BR_EnvFree(br_env, false)
          tab[i] = {id = idname, i = i, take = take, env = env,
                   active = active,
                   visible = visible,
                   armed = armed,
                   inlane = inLane,
                   laneheight = laneHeight}
          local _, envname = reaper.GetEnvelopeName(env)
          
          --Hide envelope
          --if hide then
          --  VisEnv(env, false)
          --end
        end
      end
      
      --[[reaper.SetOnlyTrackSelected(tr)
      reaper.Main_OnCommand(reaper.NamedCommandLookup('_BR_SHOW_SEND_ENV_ALL_SEL_TRACK'), -1)]]
      if hide then
        reaper.Main_OnCommand(40889, -1)        
      end
      
    end
    
    --DBGOut('exit func: GetTakeEnvelopes_State')
    return tab    
  end

  function REC_ReturnEnvelopesToStoredState2()
  
    if lvar.trackenvs then
      for t, tab in pairs(lvar.trackenvs) do    
        if tonumber(t) then
          for e, tab2 in pairs(lvar.trackenvs[t]) do
          
            local env = tab2.env
            local br_env = reaper.BR_EnvAlloc(env, false)                        
            local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling = 
                  reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
            reaper.BR_EnvSetProperties(br_env, active, tab2.vis, armed, inLane, laneHeight, defaultShape, faderScaling)   
            reaper.BR_EnvFree(br_env, true)          
          
          end
        end
      end
    
    end
  
  end

  function REC_ReturnEnvelopesToStoredState(keepdata, act, arm, vis2)
    --DBGOut('REC_ReturnEnvelopesToStoredState')

    reaper.PreventUIRefresh(1)

    if not keepdata then
      if lvar.autoenv_mode == 2 then
        REC_ReturnEnvelopesToStoredState2()
        lvar.trackenvs = nil
      end        
    end
    
    if lvar.deftrackenvdata then
      
      local trns = lvar.deftrackenvdata.trns
      for t, b in pairs(trns) do
        local tr = GetTrack(t)
        --local _, tn = reaper.GetTrackName(tr)
        --DBG(tn)
        if tr and b then
          --DBG('trn '..t)
          local envidx = {}
          if lvar.deftrackenvdata then
            
            local trenvdata = lvar.deftrackenvdata[t]
            if trenvdata then
              
              reaper.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', trenvdata.trheightov or 0)
              
              --create index
              for i = 0, #trenvdata do
                if trenvdata[i] then
                  envidx[tostring(trenvdata[i].env)] = i
                end
              end
            
              for i = 0, reaper.CountTrackEnvelopes(tr)-1 do
          
                local env = reaper.GetTrackEnvelope(tr, i)
                if env then
                  if envidx[tostring(env)] then

                    --envelope in def data
                    local e = lvar.deftrackenvdata[t][envidx[tostring(env)]]
                    local br_env = reaper.BR_EnvAlloc(env, false)                        
                    local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling = 
                          reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
                    
                    local rep_arm, rep_act, rep_vis
                    local vis = e.visible
                    if lvar.recenvdata then
                      local f = lvar.recenvdata.idx[tostring(env)]
                      if f then
                        if fader_touch[f] then
                          vis = true
                          rep_arm = arm
                          rep_act = act
                          rep_vis = vis2
                        else
                          rep_arm = arm
                          rep_act = act
                        end
                      end
                    end

                    reaper.BR_EnvSetProperties(br_env, rep_act or e.active, rep_vis or vis, rep_arm or e.armed, e.inlane, e.laneheight, defaultShape, faderScaling)                                
                    reaper.BR_EnvFree(br_env, true)
  
                    --note - keep visible if values have been captured?
                    
                  else
                    --envelope not in def data
                    
                    local br_env = reaper.BR_EnvAlloc(env, false)                        
                    local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling = reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)

                    local rep_arm, rep_act, rep_vis
                    local vis = false
                    if lvar.recenvdata then
                      local f = lvar.recenvdata.idx[tostring(env)]
                      if f then
                        if fader_touch[f] then
                          vis = true
                          rep_arm = arm
                          rep_act = act
                          rep_vis = vis2
                        else
                          
                        end
                      end
                    end
                    
                    reaper.BR_EnvSetProperties(br_env, rep_act or active, rep_vis or vis, rep_arm or armed, inLane, laneHeight, defaultShape, faderScaling)   
                    reaper.BR_EnvFree(br_env, true)
  
                    --note - keep visible if values have been captured?
                                  
                  end
  
                end
              end
            
            end
          end
      
        end
      end
      
      if not keepdata then
        lvar.deftrackenvdata = nil
      end
    end

    reaper.PreventUIRefresh(-1)
    
    --DBGOut('exit func: REC_ReturnEnvelopesToStoredState')
  end

  function GetArrangeDim()
  
    local hwnd = reaper.GetMainHwnd()
    local cwin2 = reaper.JS_Window_FindChildByID(hwnd, 1000)
    if cwin2 then      
      local retval, l, t, r, b = reaper.JS_Window_GetClientRect(cwin2)
      return l, t, r-l, b-t
    end

  end
  
  function REC_ZoomEnvs()
    
    --mode 2 = zoom all envelopes
    --other modes = only zoom assigned envelopes
   
    reaper.PreventUIRefresh(1)
    local puir
    if lvar.env_spread == 1 and FFX then
         
      local tr = reaper.GetSelectedTrack2(0,0,true) --GetTrack(FFX.trn) --reaper.GetSelectedTrack2(0, 0, true)
      if tr then
        if reaper.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP') == 1 then
       
          local cnt = reaper.CountTrackEnvelopes(tr)
          if cnt > 0 then
          
            local x, y, w, h = GetArrangeDim()
            local viscnt = 0
            for i = 0, cnt-1 do
              local env = reaper.GetTrackEnvelope(tr, i)
              local _, vis = GetEnvProps(env)
              if vis == true then
                viscnt = viscnt + 1
              end
            end
            
            if viscnt > 0 then
              --local tcp_h = reaper.GetMediaTrackInfo_Value(tr, 'I_TCPH')
              
              if lvar.env_spread_limit > 0 then
                viscnt = math.min(viscnt, lvar.env_spread_limit) 
              end
              
              local minth, maxth = lvar.env_mintrackheight, lvar.env_maxtrackheight
              if maxth == 0 then
                maxth = math.huge
              end
              
              local tcp_h = math.min(math.max(h/(viscnt+1),minth),maxth)
              local sprh = math.min(math.floor((h-tcp_h)/viscnt), lvar.env_maxheight)
              
              reaper.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', tcp_h)
              
              for i = 0, cnt-1 do
                local env = reaper.GetTrackEnvelope(tr, i)
                --if lvar.recenvdata.idx[tostring(env)] then
                  local _, vis = GetEnvProps(env)
                  if vis == true then
                    SetEnvLaneHeight(env, sprh)
                  end
                --end
              end
              
              puir = true
              reaper.PreventUIRefresh(-1)
              reaper.UpdateArrange()
              --ScrollTCP2(tr, true)
              lvar.update_tcp2_A = reaper.time_precise() + 0.05
              lvar.scrollTCPtoselectedtrack = math.huge              
            end
          end
        end        
      end
    else
      if lvar.autoenv_mode == 2 then
        local h = math.min(lvar.env_laneheight * lvar.env_zoomh, lvar.env_maxheight)
        local minth, maxth = lvar.env_mintrackheight, lvar.env_maxtrackheight
        if maxth == 0 then
          maxth = math.huge
        end
        local trh = math.max(math.min(h, maxth), minth)
      
        for t = 0, reaper.CountTracks(0) do
          local tr = GetTrack(t)
          if reaper.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP') == 1 then
          
            reaper.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', trh)
            local cnt = reaper.CountTrackEnvelopes(tr)
            if cnt > 0 then
              for i = 0, cnt-1 do
                local env = reaper.GetTrackEnvelope(tr, i)
                if lvar.recenvdata.idx[tostring(env)] then
                  local _, vis = GetEnvProps(env)
                  if vis == true then
                    local z = lvar.env_indzoomh[i+1]
                    if z then
                      z = math.min(lvar.env_laneheight * z, lvar.env_maxheight)
                    end
                    local hh = z or h
                    SetEnvLaneHeight(env, hh)
                  end
                end
              end
            end
          end
        end
      
        puir = true
        reaper.PreventUIRefresh(-1)
        reaper.UpdateArrange()
        --ScrollTCP2(tr, true)
        lvar.update_tcp2_A = reaper.time_precise() + 0.05
        lvar.scrollTCPtoselectedtrack = math.huge
        
      else
        if lvar.recenvdata then

          local h = math.min(lvar.env_laneheight * lvar.env_zoomh, lvar.env_maxheight)
          local minth, maxth = lvar.env_mintrackheight, lvar.env_maxtrackheight
          if maxth == 0 then
            maxth = math.huge
          end
          local trh = math.max(math.min(h, maxth), minth)
          local etrks = {}
          
          for e = 1, #lvar.recenvdata do
            if lvar.recenvdata[e].exauto ~= true then
              local env = lvar.recenvdata[e].env
              if env then
                local _, vis = GetEnvProps(env)
                if vis == true then
                  --local h = math.min(lvar.env_laneheight * lvar.env_zoomh, lvar.env_maxheight)
                  local tr = reaper.Envelope_GetParentTrack(env)
                  
                  if tr and not etrks[tostring(tr)] then
                    reaper.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', trh)
                    etrks[tostring(tr)] = true
                  end

                  local z = lvar.env_indzoomh[e]
                  if z then
                    z = math.min(lvar.env_laneheight * z, lvar.env_maxheight)
                  end
                  local hh = z or h
                  SetEnvLaneHeight(env, hh)
                end        
              end
            end
          end
          
          puir = true
          reaper.PreventUIRefresh(-1)
          reaper.UpdateArrange()
          --ScrollTCP2(tr, true)
          lvar.update_tcp2_A = reaper.time_precise() + 0.05
          lvar.scrollTCPtoselectedtrack = math.huge
        end
      end
    end
    if not puir then
      reaper.PreventUIRefresh(-1)
    end    
  end

  function Update_Envelopes()
  
    if recmode == 1 and lvar.autoenv then
    
      REC_ZoomEnvs()
    
    end
  
  end
  
  function REC_AutoTracks_Gather(trns, getenvs)
  
    reaper.PreventUIRefresh(1)

    REC_AutoTracks_Restore()
    
    lvar.rec_trackvis = {}
    lvar.rec_trackheight = {}
    lvar.trackenvs = {}
    lvar.trackenvs.envidx = {}
    for t = 0, reaper.CountTracks(0) do
    
      local tr = GetTrack(t)
      lvar.rec_trackvis[t] = reaper.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP')
      lvar.rec_trackheight[t] = reaper.GetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE')
      if getenvs then
        local cnt = reaper.CountTrackEnvelopes(tr)
        if cnt > 0 then
          for i = 0, cnt-1 do
            local env = reaper.GetTrackEnvelope(tr, i)
            local ecnt = reaper.CountEnvelopePoints(env)
            if ecnt > 1 then
              if not lvar.trackenvs[t] then
                lvar.trackenvs[t] = {}
              end
              local idx = tostring(env)
              lvar.trackenvs[t][i] = {}
              lvar.trackenvs[t][i].env = env
              local br_env = reaper.BR_EnvAlloc(env, false)
              local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling = 
                                        reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
              reaper.BR_EnvFree(br_env, true)
              
              lvar.trackenvs[t][i].vis = visible
              lvar.trackenvs.envidx[tostring(env)] = true
              trns[t] = true
            end
          end
        end
      end
    
    end

    reaper.PreventUIRefresh(-1)
  
  end

  function ScrollTCP()
    reaper.Main_OnCommand(40913,0)
    lvar.scrollTCPtoselectedtrack = math.huge
  end

  function ScrollTCP2(tr, focusenv)

    if not tr then
      tr = reaper.GetSelectedTrack2(0,0,true)
    end
    if tr then
      local tcp_y = reaper.GetMediaTrackInfo_Value(tr, 'I_TCPY')
      local hwnd = reaper.GetMainHwnd()
      local cwin2 = reaper.JS_Window_FindChildByID(hwnd, 1000)
      if cwin2 then      
        local retval, position, pageSize, min, max, trackPos = reaper.JS_Window_GetScrollInfo(cwin2, 'SB_VERT')
        local tcp_h = 0
        --[[if focusenv then
          tcp_h = reaper.GetMediaTrackInfo_Value(tr, 'I_TCPH')
        end]]
        reaper.JS_Window_SetScrollPos(cwin2, 'SB_VERT', position + tcp_y + tcp_h)
      end
    end
    
    lvar.scrollTCPtoselectedtrack = math.huge
  end

  function REC_AutoTracks_Show(showenvs)

    if lvar.deftrackenvdata.trns then

      reaper.PreventUIRefresh(1)
    
      local trns = lvar.deftrackenvdata.trns
      for t = 0, reaper.CountTracks(0) do
        
        local tr = GetTrack(t)
        if trns[t] then
          v = 1
        else
          v = 0
        end
          
        reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINTCP', v)      
      
        if showenvs and v == 1 and lvar.trackenvs[t] then
          for eidx, tab in pairs(lvar.trackenvs[t]) do
            if tab.env then
              local env = tab.env
              local br_env = reaper.BR_EnvAlloc(env, false)
              local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling = 
                                        reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
              reaper.BR_EnvSetProperties(br_env, active, true, armed, inLane, laneHeight, defaultShape, faderScaling)   
              reaper.BR_EnvFree(br_env, true)
              
            end
          end
        end
      end    

      reaper.PreventUIRefresh(-1)
      reaper.UpdateArrange()
      ScrollTCP()
      lvar.scrollTCPtoselectedtrack = reaper.time_precise()--+0.2
    end

  end

  function REC_AutoTracks_Restore()

    if lvar.rec_trackvis then

      reaper.PreventUIRefresh(1)

      for t = 0, reaper.CountTracks(0) do
      
        local tr = GetTrack(t)
        if tr then
          local v = lvar.rec_trackvis[t]
          if v then
            reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINTCP', v)
            reaper.SetMediaTrackInfo_Value(tr, 'I_HEIGHTOVERRIDE', lvar.rec_trackheight[t])
          end
        end
      end
      lvar.rec_trackvis = nil

      reaper.PreventUIRefresh(-1)
      reaper.UpdateArrange()
      --ScrollTCP()
      --lvar.scrollTCPtoselectedtrack = reaper.time_precise()--+0.1
    end
    
  end
  
  function REC_EnvelopeData_SlipAssignments(active, notmpchange)

    if lvar.autoenv_assslip and lvar.autoenv and lvar.chanstrips.count > 0 then
    --lvar.readparams = nil
      
    lvar.tmptoplayer_active = active
    tmptoplayer = {dirty = {},
                   pos = {},
                   sft = {},
                   eft = {}}
    
    if active then
      local freeslot = {}
      for i = 1, lvar.fcount do
        --if ctl_template.fader[i].ttype then
        if lvar.chanstrips.idx2[i] then

          freeslot[#freeslot+1] = i
      
        end
      end
      
      local fs = 1
      for i = 1, lvar.fcount do
        if lvar.chanstrips.idx2[i] then
          local tmp = GetTemplate(i,nil,nil,true)
          local tmppos = tmp.pos[i]
          if tmppos and (tmppos.ptype == ptype.host or tmppos.ptype == ptype.track) and tmppos.exauto ~= 1 and freeslot[fs] then
            tmptoplayer.pos[freeslot[fs]] = table.copy(tmppos)

            local cstab = lvar.chanstrips[lvar.chanstrips.idx2[i]]
            local cstabto = lvar.chanstrips[lvar.chanstrips.idx2[freeslot[fs]]]
            for cs = 2, #cstab do
              local shift = cstab[cs]
              local shiftto = cstabto[cs]
              if shift and shiftto then
                local tmppos = tmp.pos[shift]
                if tmppos and (tmppos.ptype == ptype.host or tmppos.ptype == ptype.track) and tmppos.exauto ~= 1 then
                  tmptoplayer.pos[shiftto] = table.copy(tmppos)
                end
              end
            end
            fs = fs + 1
          end
        end
      end    
      
      if not notmpchange then
        TemplateChanged()
      end
      lupd.update_gfx = true
    else
      if not notmpchange then
        TemplateChanged()
      end
      lupd.update_gfx = true
    end
    
    end
  end
  
  function GetTCPScrollPos()
    local hwnd = reaper.GetMainHwnd()
    local cwin2 = reaper.JS_Window_FindChildByID(hwnd, 1000)
    if cwin2 then      
      local retval, position, pageSize, min, max, trackPos = reaper.JS_Window_GetScrollInfo(cwin2, 'SB_VERT')
      return position
    end
  end

  function SetTCPScrollPos(sp)
    lvar.setscrollpos = sp
  end
  
  function SetTCPScrollPos2(sp)
    local hwnd = reaper.GetMainHwnd()
    local cwin2 = reaper.JS_Window_FindChildByID(hwnd, 1000)
    if cwin2 then      
      reaper.JS_Window_SetScrollPos(cwin2, 'SB_VERT', sp)
    end
  end
  
  function GetFaderKeys(ctltype, devbus)
    local cfader = ctl_template.fader
    local faderkeys = {}
    for i = 1, lvar.fcount do
      if string.match(cfader[i].devctl, ctltype..' %d+') and (devbus == -1 or devbus-1 == cfader[i].devbus) then
        local key = cfader[i].devbus..'|'..cfader[i].devctl
        faderkeys[#faderkeys+1] = {key = key, slot = i}
      end
    end
    return faderkeys, #faderkeys
  end
  
  function GetKeysByTab(devctltab)
    local cfader = ctl_template.fader
    local faderkeys = {}
    local dctidx = {}
    for i = 1, #devctltab do
      dctidx[devctltab[i]] = i
    end
    
    for i = 1, lvar.fcount do
      if dctidx[cfader[i].devctl] then
        local key = cfader[i].devbus..'|'..cfader[i].devctl
        faderkeys[dctidx[cfader[i].devctl]] = {key = key, slot = i}
      end
    end
    return faderkeys, #devctltab
  end
  
  function REC_MapEnvsToFaders()

    lvar.readparams = nil
    
    local sscols = {}
    sscols[1] = lvar.rec_automap_color_vol
    sscols[2] = lvar.rec_automap_color_pan
    sscols[3] = lvar.rec_automap_color_mute
    
    local sscol_plug = lvar.rec_automap_color_plug
    local ofxnum
    
    local tmpchanged = true
    local tmp = {dirty = {},
                 pos = {},
                 sft = {},
                 eft = {}}
    
    local trackcnt = reaper.CountSelectedTracks2(0, true)

    if trackcnt == 0 then return end
    
    local faders, fadercnt
    if not lvar.rec_automap_flip then
      faders, fadercnt = GetFaderKeys('Fader', lvar.rec_automap_device)
    else
      faders, fadercnt = GetFaderKeys('Encoder', lvar.rec_automap_device)
    end
    local bankctls, bankctlscnt = GetKeysByTab({'Bank Left', 'Bank Right', 'Flip'})

    --bank left/right
    if bankctls[1] then
      tmp.pos[bankctls[1].slot] = Assign_GetDefaultInternal_Tab(ptype.internal, 3, 14, 1, {1}, {0}, 'Bank L', 7)
      if ctl_template.fader[bankctls[1].slot].lmode == 4 then
        local slot = bankctls[1].slot
        tmp.pos[slot].butstates_arrayidx = {}
        for b = 1, tmp.pos[slot].butstates do
          tmp.pos[slot].butstates_arrayidx[tmp.pos[slot].butstates_array[b]] = b
        end
      end
    end
    
    if bankctls[2] then
      tmp.pos[bankctls[2].slot] = Assign_GetDefaultInternal_Tab(ptype.internal, 3, 15, 1, {1}, {0}, 'Bank R', 7)
      if ctl_template.fader[bankctls[2].slot].lmode == 4 then
        local slot = bankctls[2].slot
        tmp.pos[slot].butstates_arrayidx = {}
        for b = 1, tmp.pos[slot].butstates do
          tmp.pos[slot].butstates_arrayidx[tmp.pos[slot].butstates_array[b]] = b
        end
      end
    end

    --Flip
    if bankctls[3] then
      tmp.pos[bankctls[3].slot] = Assign_GetDefaultInternal_Tab(ptype.internal, 3, 16, 2, {0,1}, {0,0}, 'Flip', 7)
      if ctl_template.fader[bankctls[3].slot].lmode == 4 then
        local slot = bankctls[3].slot
        tmp.pos[slot].butstates_arrayidx = {}
        for b = 1, tmp.pos[slot].butstates do
          tmp.pos[slot].butstates_arrayidx[tmp.pos[slot].butstates_array[b]] = b
        end
      end
    end
    
    if trackcnt > 1 then
      --Only map track volume
      local fadpos = 1
      lvar.rec_automap_selectedtracks = {}
      for t = 1, trackcnt do
        local track = reaper.GetSelectedTrack2(0, t-1, true) --FFX.track???
        if track then
      
          local trn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
          local tguid = reaper.GetTrackGUID(track)
          lvar.rec_automap_selectedtracks[t] = {track = track, trn = trn, tguid = tguid}
          local slot = faders[fadpos].slot
          if slot then
            local _, tnm = reaper.GetTrackName(track)
            local trparnm = --[[string.format('%i',trn) ..' '.. ]]tab_trparams_envnames[1]..' '..tnm

            tmp.pos[slot] = Assign_GetDefaultTrack_Tab(ptype.track, trn, tguid, 1, -1, trparnm, sscols[1])
            fadpos = fadpos + 1
            tmpchanged = true
          end
        end
      end
      reaper.SetOnlyTrackSelected(lvar.rec_automap_selectedtracks[1].track)
      if lvar.rec_automap_solo and fadpos <= fadercnt then
        for f = fadpos, fadercnt do
          local slot = faders[f].slot
          tmp.pos[slot] = Assign_GetDefaultGlobalHost_Tab(ptype.internal, 0, -99, '', -1, '', -1, '', 0)
        end
      end
    else
      local track = reaper.GetSelectedTrack2(0, 0, true) --FFX.track???
      if track then
        
        local guids = GetAllTrackFXGUIDs()
        
        local envcnt = reaper.CountTrackEnvelopes(track)
        lvar.rec_automap_envcnt = envcnt
        local sendidx = 0
        
        local validenvs = {}
        local validenvs_col = {}
        
        for e = 0, envcnt-1 do
          local env = reaper.GetTrackEnvelope(track, e)
          local _, name = reaper.GetEnvelopeName(env)
          if tab_tr_envnames[name] then
            if tab_tr_envnames[name]&16 == 16 then
              --send ignore
            else
              validenvs[#validenvs+1] = e
            end
          else
            local param, plugin = string.match(name,'(.+) %/ (.*)')
            local track, fxnum, pnum = reaper.Envelope_GetParentTrack(env)
            if fxnum ~= -1 then
              if not ofxnum then
                ofxnum = fxnum
              end
              if fxnum ~= ofxnum then
                ofxnum = fxnum
                sscol_plug = sscol_plug + 1
                if sscol_plug > #tab_xtouch_colors then
                  sscol_plug = 1
                end
              end
              validenvs[#validenvs+1] = e
              if not validenvs_col[fxnum] then
                validenvs_col[fxnum] = sscol_plug
              end
            end
          end
        end
        local venvcnt = #validenvs
        
        local fadpos = 1
        --Always map volume (if bankoffset == 0)
        if lvar.rec_automap_bankoffset == 0 then
          local trn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
          local tguid = reaper.GetTrackGUID(track)
          local slot = faders[fadpos].slot
          tmp.pos[slot] = Assign_GetDefaultTrack_Tab(ptype.track, trn, tguid, 1, -1, tab_trparams_envnames[1], sscols[1])
          fadpos = fadpos + 1
        end
        
        local e = 0
        while fadpos <= fadercnt do
        --for e = 0, fadercnt-1 do
          local ee = e + lvar.rec_automap_bankoffset
          if validenvs[ee+1] and faders[fadpos] then
            local env = reaper.GetTrackEnvelope(track, validenvs[ee+1])
            local _, name = reaper.GetEnvelopeName(env)
            if tab_tr_envnames[name] ~= 1 or lvar.rec_automap_bankoffset > 0 then --Not Volume - already mapped
              if tab_tr_envnames[name] then
                --DBG(name..'  '..(tab_tr_envnames[name]&16))
                if tab_tr_envnames[name]&16 == 16 then
                  --send --ignore as associating send envelopes with send indexes are nigh on impossible!
                else
                  local track = reaper.Envelope_GetParentTrack(env)
                  if track then
                    local trn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
                    local tguid = reaper.GetTrackGUID(track)
                    local slot = faders[fadpos].slot
                    if slot then
                      local trparnm = tab_trparams_envnames[tab_tr_envnames[name]]
                   
                      tmp.pos[slot] = Assign_GetDefaultTrack_Tab(ptype.track, trn, tguid, tab_tr_envnames[name], -1, trparnm, sscols[tab_tr_envnames[name]] or tonumber(sscolor))
                      fadpos = fadpos + 1
                      tmpchanged = true
                    
                      if ctl_template.fader[slot].lmode == 4 then
                                    
                        local gmem = reaper.gmem_write
                        tmp.pos[slot].butstates_arrayidx = {}
                        
                        for b = 1, tmp.pos[slot].butstates do
                        
                          if tmp.pos[slot].ptype == ptype.host then
                            tmp.pos[slot].butstates_arrayidx[math.ceil(tonumber(tmp.pos[slot].butstates_array[b]*100000))/100000] = b
                          else
                            tmp.pos[ii].butstates_arrayidx[tmp.pos[slot].butstates_array[b]] = b
                          end
                         
                        end
                      end
                    end
                  end
                end
              else
                local param, plugin = string.match(name,'(.+) %/ (.*)')
                local track, fxnum, pnum = reaper.Envelope_GetParentTrack(env)
                --DBG(plugin..'  '..fxnum..'  '..pnum)
                if fxnum ~= -1 then
                  
                  local trn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
                  local fxguid = reaper.TrackFX_GetFXGUID(track, fxnum)
                  local ret, fxparamname = reaper.TrackFX_GetParamName(track, fxnum, pnum, '')
                  if fxguid and guids[fxguid] then
                    local tguid = guids[fxguid].tguid
                    local trn = guids[fxguid].trn
                    local fxn = guids[fxguid].fxn
                    
                    local slot = faders[fadpos].slot
                    if slot then
                      tmp.pos[slot] = Assign_GetDefaultGlobalHost_Tab(ptype.host , 1, trn, tguid, fxn, fxguid, tonumber(pnum), fxparamname, validenvs_col[fxnum] or tonumber(sscolor))
                      fadpos = fadpos + 1
                      tmpchanged = true
                    
                      if ctl_template.fader[slot].lmode == 4 then
                                    
                        local gmem = reaper.gmem_write
                        tmp.pos[slot].butstates_arrayidx = {}
                        
                        for b = 1, tmp.pos[slot].butstates do
                        
                          if tmp.pos[slot].ptype == ptype.host then
                            tmp.pos[slot].butstates_arrayidx[math.ceil(tonumber(tmp.pos[slot].butstates_array[b]*100000))/100000] = b
                          else
                            tmp.pos[ii].butstates_arrayidx[tmp.pos[slot].butstates_array[b]] = b
                          end
                         
                        end
                      end
                    end
                  end
                end
              end
            end
          else
            break
          end
          e=e+1
        end
        if lvar.rec_automap_solo and fadpos <= fadercnt then
          for f = fadpos, fadercnt do
            local slot = faders[f].slot
            tmp.pos[slot] = Assign_GetDefaultGlobalHost_Tab(ptype.internal, 0, -99, '', -1, '', -1, '', 0)
          end
        end
      end
    end
    
    rectemplate = tmp
    if tmpchanged then
      TemplateChanged()
      
      A_ReadParamVals(true, true)
    end
    
  end
    
  function REC_EnvelopeData_Gather()
    --DBGOut('REC_EnvelopeData_Gather')

    reaper.PreventUIRefresh(1)
    if lvar.deftrackenvdata then
      REC_ReturnEnvelopesToStoredState()
      --REC_EnvelopeData_SlipAssignments()
    end
    
    --lvar.tcpsp = GetTCPScrollPos()
        
    lvar.recenvdata = {}
    lvar.recenvdata.idx = {}
    lvar.recenvdata.idx2 = {}
    lvar.deftrackenvdata = {}
    lvar.env_autoshow_bank = 0
    
    local trns = {}
    
    --Get tracks
    local rc = 0
    
    local selectedtracks = StoreSelectedTracks()
    
    for i = 1, lvar.fcount do
      
      --if ctl_template.fader[i].ttype then
      if lvar.chanstrips.idx2[i] then
              
        local tmp = GetTemplate(i)
        local tmppos = tmp.pos[i]
        if tmppos and (tmppos.ptype == ptype.track or tmppos.ptype == ptype.host) and tmppos.exauto ~= 1 then
    
          if tmppos.ptype == ptype.track then
            local trn = tmppos.track
            local ttrn, trackD = Internal_GetTrack(trn, tmppos)
            --local _, tn = reaper.GetTrackName(trackD)
            --DBG(tn..'  '..ttrn)
            if trackD and ttrn and not trns[ttrn] then
              trns[ttrn] = true
              --Get Existing Envelopes
              lvar.deftrackenvdata[ttrn] = GetTrackEnvelopes_State(ttrn, true)
              lvar.deftrackenvdata[ttrn].trheightov = reaper.GetMediaTrackInfo_Value(trackD, 'I_HEIGHTOVERRIDE')
            end
          
          elseif tmppos.ptype == ptype.host then
            if not FFX.take or tmppos.globalhost >= 1 then
              local ttrn = FFX.trn
              if tmppos.globalhost >= 1 then
                ttrn = tmppos.ptrack
              end
              if ttrn and not trns[ttrn] then
                local ttrn, trackD = Internal_GetTrack(ttrn, tmppos)
                if trackD then
                  trns[ttrn] = true
                  --Get Existing Envelopes
                  lvar.deftrackenvdata[ttrn] = GetTrackEnvelopes_State(ttrn, true)                    
                  lvar.deftrackenvdata[ttrn].trheightov = reaper.GetMediaTrackInfo_Value(trackD, 'I_HEIGHTOVERRIDE')
                end
              end
            else
              --takefx
              --ignore for now
            end
          end
            
          --Get Envelope
          local fenv = GetFaderEnvelope(i)
          --DBG(i..' fenv '..tostring(fenv))
          if fenv then
            rc = rc + 1
            lvar.recenvdata[rc] = {env = fenv,
                                   fader = i,
                                   exauto = tmppos.exauto}
            ArmEnv(fenv, true)
            if lvar.recenvdata[rc].env then
              local act, vis = GetEnvProps(fenv)
              local _, nm = reaper.GetEnvelopeName(fenv)
              --DBG(i..'  '..tostring(vis)..tostring(fenv)..'   '..nm..'  '..tostring(act))
              lvar.recenvdata.idx[tostring(lvar.recenvdata[rc].env)] = lvar.recenvdata[rc].fader              
              lvar.recenvdata.idx2[i] = {env = lvar.recenvdata[rc].env, vis = false}
            end
          end
        end
        
      end
    end
    
    lvar.deftrackenvdata.trns = trns
    
    if lvar.autoenv then
      if lvar.autoenv_mode == 0 then
        --reshow visible envelopes + auto envs
        REC_ReturnEnvelopesToStoredState(true, true, true)
        Env_AutoShow()
        
      elseif lvar.autoenv_mode == 1 then
        --Show only auto lanes - hide non-auto tracks in TCP
        REC_AutoTracks_Gather(trns)
        REC_AutoTracks_Show()
        Env_AutoShow()
        
      elseif lvar.autoenv_mode == 2 then
        --Show all lanes with data
        REC_AutoTracks_Gather(trns, true)
        REC_AutoTracks_Show(true)
        Env_AutoShow()

      elseif lvar.autoenv_mode == 3 then
        --reshow visible envelopes + auto envs
        REC_ReturnEnvelopesToStoredState(true, true, true)
  
      end
    else
      REC_ReturnEnvelopesToStoredState(true, true, true)    
    end
    
    RestoreSelectedTracks(selectedtracks)

    reaper.PreventUIRefresh(-1)
    
    --TemplateChanged()
    --DBGOut('exit func: REC_EnvelopeData_Gather')
    
  end

  ------------------------------------------------------------
    
  function GetObjects()
    local obj = {}
      
    obj.sections = {}
    local num = 7
    
    local zm = lvar.guizoom
    local h22 = math.floor(22*zm)
    local h14 = math.floor(14*zm)
    local hbutt = math.floor(butt_h*zm)
    
    local pw =  math.floor(gfx1.main_w/2)-10

    fader_w = math.min(math.max(gfx1.main_w-70-pw,50),200)
    fader_h = math.floor(24*lvar.guizoom2)
    fader_space = 2
    
    box_w = 40
    
    --FB
    obj.sections[150] = {x = gfx1.main_w - 30, --obj.sections[5].x+obj.sections[5].w+5,
                       y = 6,
                       w = 20,
                       h = h22}

    --settings
    obj.sections[9] = {x = obj.sections[150].x - 60, --+butt_h/4,
                       y = 6,
                       w = 58,
                       h = h22}
    --mode
    obj.sections[12] = {x = 10, --+butt_h/4,
                       y = obj.sections[9].y,
                       w = 80,
                       h = h22}
    obj.sections[13] = {x = 10, --+butt_h/4,
                       y = obj.sections[12].y+obj.sections[12].h+2,
                       w = 80,
                       h = h22}
    obj.sections[14] = {x = 10, --+butt_h/4,
                       y = obj.sections[13].y+obj.sections[13].h+2,
                       w = 80,
                       h = h22}

    --global save
    obj.sections[16] = {x = gfx1.main_w - 90, --+butt_h/4,
                       y = obj.sections[14].y,
                       w = 80,
                       h = h22}

    --global show/hide
    obj.sections[15] = {x = obj.sections[14].x + obj.sections[14].w + 2, --+butt_h/4,
                       y = obj.sections[14].y,
                       w = obj.sections[16].x-12-(obj.sections[14].w + 2),
                       h = h22}
    --learn
    obj.sections[8] = {x = obj.sections[16].x,
                       y = obj.sections[13].y,
                       w = obj.sections[16].w,
                       h = h22}

    obj.sections[17] = {x = obj.sections[15].x,
                       y = obj.sections[12].y,
                       w = obj.sections[15].w,
                       h = h22*2+2}

    --status line - flip indicator
    obj.sections[19] = {x = 10, --+butt_h/4,
                       y = obj.sections[14].y+obj.sections[14].h+6,
                       w = 80,
                       h = h14}
    --stamp/print ccs
    obj.sections[20] = {x = obj.sections[16].x, --+butt_h/4,
                       y = obj.sections[14].y+obj.sections[14].h+6,
                       w = obj.sections[16].w,
                       h = h14}

    local www = 30
    
    --hl group
    obj.sections[21] = {x = obj.sections[19].x+obj.sections[19].w+2, --+butt_h/4,
                       y = obj.sections[14].y+obj.sections[14].h+6,
                       w = math.min(50, obj.sections[20].x - (obj.sections[19].x+obj.sections[19].w) -6 - www),
                       h = h14}

    obj.sections[22] = {x = obj.sections[21].x+obj.sections[21].w+2, --+butt_h/4,
                       y = obj.sections[14].y+obj.sections[14].h+6,
                       w = www,
                       h = h14}

    --takeover button
    local tox = obj.sections[22].x+obj.sections[22].w+2
    obj.sections[27] = {x = tox, --+butt_h/4,
                       y = obj.sections[14].y+obj.sections[14].h+6,
                       w = obj.sections[20].x - tox - 2,
                       h = h14}

    --Auto Env
    obj.sections[28] = {x = obj.sections[19].x, --+butt_h/4,
                       y = obj.sections[19].y+obj.sections[19].h+6,
                       w = obj.sections[19].w,
                       h = h14}

    --Show ctl
    obj.sections[31] = {x = obj.sections[20].x, --+butt_h/4,
                       y = obj.sections[28].y,
                       w = obj.sections[20].w,
                       h = h14}
    
    local bww = (obj.sections[15].w / 2)-2
    --Finetune settings
    obj.sections[33] = {x = obj.sections[15].x+2, --+butt_h/4,
                       y = obj.sections[28].y,
                       w = bww,
                       h = h14}

    --RR settings
    obj.sections[32] = {x = obj.sections[33].x+obj.sections[33].w+2, --+butt_h/4,
                       y = obj.sections[28].y,
                       w = bww,
                       h = h14}
    
    --cc lanes
    obj.sections[23] = {x = obj.sections[19].x, --+butt_h/4,
                       y = obj.sections[28].y+obj.sections[28].h+6,
                       w = obj.sections[19].w,
                       h = h14}
    --override
    obj.sections[24] = {x = obj.sections[19].x+obj.sections[19].w+2, --+butt_h/4,
                       y = obj.sections[23].y,
                       w = math.floor(gfx1.main_w/2) - (obj.sections[19].x+obj.sections[19].w+2),
                       h = h14}

    obj.sections[25] = {x = obj.sections[24].x+obj.sections[24].w+2, --+butt_h/4,
                       y = obj.sections[23].y,
                       w = math.floor((gfx1.main_w-10)/2),
                       h = h14}

    

    --LAYERS
    obj.sections[29] = {x = obj.sections[23].x, --+butt_h/4,
                       y = obj.sections[23].y+obj.sections[23].h+6,
                       w = math.floor((gfx1.main_w-20)/2),
                       h = hbutt}
    
    obj.sections[26] = {x = obj.sections[25].x, --+butt_h/4,
                       y = obj.sections[29].y, --+obj.sections[23].h+6,
                       w = obj.sections[25].w,
                       h = hbutt}
    
    --fxname
    local offs50 = 68*zm

    --save
    local bw = 56
    local minioff = 5
    obj.sections[5] = {x = gfx1.main_w - 10 - bw, --math.max(obj.sections[8].x+obj.sections[8].w+10 ,obj.sections[6].x+obj.sections[6].w+10)-5,
                       y = obj.sections[29].y + obj.sections[29].h + minioff + 6*(zm-1), --obj.sections[50].y-hbutt-67*zm,
                       w = bw,
                       h = hbutt+18*zm}
                       
    --rec mode
    obj.sections[6] = {x = 10, --math.max(obj.sections[8].x+obj.sections[8].w+10, obj.sections[1].x+obj.sections[1].w-130),
                       y = obj.sections[5].y,
                       w = bw,
                       h = hbutt+18*zm}
    
    local xx = obj.sections[8].x+ obj.sections[8].w+4
    obj.sections[3] = {x = bw+10,
                       y = obj.sections[29].y + obj.sections[29].h + minioff-1,--obj.sections[50].y-hbutt-(offs50)-1,
                       w = obj.sections[5].x-bw-12,
                       h = math.floor(hbutt)+22*zm}
    
    obj.sections[18] = {x = 5,
                        y = obj.sections[29].y + obj.sections[29].h + minioff,
                        w = gfx1.main_w-10,
                        h = obj.sections[3].h+24*zm}
    local x18 = obj.sections[6].x+obj.sections[6].w+4
    local w18 = obj.sections[5].x-4-x18
    obj.sections[10018] = {x = x18,
                        y = obj.sections[29].y + obj.sections[29].h + minioff,
                        w = w18,
                        h = obj.sections[3].h+24*zm}

    obj.sections[11] = {x = obj.sections[3].x,
                       y = obj.sections[3].y,
                       w = obj.sections[3].w,
                       h = obj.sections[3].h}
    obj.sections[7] = {x = obj.sections[3].x,
                       y = obj.sections[3].y-3*zm,
                       w = obj.sections[3].w,
                       h = hbutt}

    obj.sections[30] = {x = obj.sections[7].x,
                       y = obj.sections[3].y+35*zm,
                       w = obj.sections[7].w,
                       h = 10*zm}

    --SAVE TAG
    local bw = 56
    obj.sections[1003] = {x = gfx1.main_w - 10 - bw,
                       y = obj.sections[5].y+obj.sections[5].h+4,
                       w = bw,
                       h = 18*zm}
    --LOAD TAG
    obj.sections[1004] = {x = 10,
                       y = obj.sections[1003].y,
                       w = bw,
                       h = obj.sections[1003].h}
    --CURRENT TAG
    local xw = obj.sections[1004].x+obj.sections[1004].w
    obj.sections[1005] = {x = obj.sections[3].x,
                           y = obj.sections[1004].y,
                           w = obj.sections[3].w,
                           h = obj.sections[1003].h}

    obj.sections[1001] = {x = 5, --+butt_h/4,
                          y = obj.sections[18].y+obj.sections[18].h,
                          w = math.floor((gfx1.main_w-10)/2),
                          h = 18*zm}
    obj.sections[1002] = {x = obj.sections[1001].x+obj.sections[1001].w+2, --+butt_h/4,
                          y = obj.sections[1001].y,
                          w = obj.sections[1001].w,
                          h = 18*zm}

    --Control panel area (down to track/plugin name box)
    --local o50y = 268*zm
    local o50y = obj.sections[1001].y + obj.sections[1001].h + 4
    obj.sections[50] = {x = 10,
                        y = o50y,
                        w = gfx1.main_w - 10,
                        h = gfx1.main_h-o50y}
    lvar.pcolumns = 1
    if obj.sections[50].w > lvar.displayswitch_w and lvar.display_mini then
      local maxsize = 250
      local ycnt = math.floor(obj.sections[50].h / (fader_h + fader_space))
      local mcols = math.ceil(lvar.fcount / ycnt) 
      local ww = math.max(math.min(math.floor((obj.sections[50].w) / maxsize),mcols),1)
    
      pname_w = math.floor(obj.sections[50].w / ww)+math.floor(10/ww)
      lvar.hide_globalshortcuts = nil
      lvar.hide_globalshortcuts2 = nil
      lvar.pcolumns = ww
    else
      pname_w = obj.sections[50].w - fader_w - 10
    end    
    
    --pname
    obj.sections[2] = {x = 90,
                       y = obj.sections[50].y,
                       w = pname_w,
                       h = gfx1.main_h-obj.sections[50].y}
    
    --slider
    obj.sections[1] = {x = obj.sections[50].x + pname_w + 10,
                       y = obj.sections[2].y,
                       w = fader_w-10,
                       h = obj.sections[2].h}
    
    obj.sections[1000] = {x = obj.sections[1].x+obj.sections[1].w + 2,
                       y = obj.sections[50].y,
                       w = 6,
                       h = obj.sections[2].h}
    
    --temp pnum
    obj.sections[4] = {x = 10,
                       y = obj.sections[2].y,
                       w = 30,
                       h = gfx1.main_h-10}
    
    --cc toggle
    obj.sections[10] = {x = 50,
                        y = obj.sections[2].y,
                        w = 30,
                        h = gfx1.main_h-10}
    
    lvar.gbc = 16
    while math.floor(obj.sections[17].w/(lvar.gbc/2)) < 20 and lvar.gbc > 2 do
      lvar.gbc = lvar.gbc/2
    end
    if lvar.gbc == 2 and (obj.sections[50].w > lvar.displayswitch_w or lvar.display_mini) then
      if math.floor(obj.sections[17].w/(lvar.gbc/2)) < 14 then
        lvar.hide_globalshortcuts = true      
        lvar.hide_globalshortcuts2 = true      
      end
    end
    --[[if obj.sections[17].w <= 40*8 then
      lvar.gbc = 8
    else
      lvar.gbc = 16
    end]]
    
    --Setup
    --SB
    obj.sections[999] = {x = gfx1.main_w-8,
                         y = 0,
                         w = 8,
                         h = gfx1.main_h}
    
    
    --Input MIDI
    obj.sections[101] = {x = 10,
                         y = 80,
                         w = gfx1.main_w - 20,
                         h = (butt_h-8)*8}
    --Group inputs
    obj.sections[124] = {x = gfx1.main_w/2 - 40,
                         y = obj.sections[101].y+obj.sections[101].h+2,
                         w = 40,
                         h = (butt_h-8)}                     
    --Global Filter
    obj.sections[126] = {x = gfx1.main_w-110,
                         y = obj.sections[124].y,
                         w = 100,
                         h = (butt_h-8)}                     
    
    --Output MIDI
    obj.sections[102] = {x = 10,
                         y = obj.sections[101].y+obj.sections[101].h + 80,
                         w = gfx1.main_w - 20,
                         h = (butt_h-8)*8}

    --Ctl map    
    obj.sections[120] = {x = 10,
                         y = obj.sections[102].y+obj.sections[102].h + 50,
                         w = gfx1.main_w - 20,
                         h = butt_h}

    obj.sections[121] = {x = 10,
                         y = obj.sections[120].y+obj.sections[120].h + 2,
                         w = gfx1.main_w - 20,
                         h = butt_h}

    obj.sections[122] = {x = 10,
                         y = obj.sections[121].y+obj.sections[121].h + 2,
                         w = gfx1.main_w - 20,
                         h = butt_h}

    obj.sections[123] = {x = 10,
                         y = obj.sections[122].y+obj.sections[122].h + 2,
                         w = gfx1.main_w - 20,
                         h = butt_h}

    --Fader Count
    local bx = math.min(math.max(math.min(gfx1.main_w - 100, 180), math.floor(gfx1.main_w/2)),gfx1.main_w - 70)
    obj.sections[104] = {x = bx,
                         y = obj.sections[123].y+obj.sections[123].h + 25,
                         w = 60,
                         h = butt_h}

    --Loopback
    obj.sections[125] = {x = 10,
                         y = obj.sections[104].y+obj.sections[104].h + 40,
                         w = gfx1.main_w - 20,
                         h = butt_h}

    --Retro rec
    obj.sections[106] = {x = bx,
                         y = obj.sections[125].y+obj.sections[125].h + 20,
                         w = 60,
                         h = butt_h}

    --Sort 
    --[[obj.sections[107] = {x = bx,
                         y = obj.sections[106].y+obj.sections[106].h + 10,
                         w = 60,
                         h = butt_h}]]

    --Sort
    obj.sections[109] = {x = bx,
                         y = obj.sections[106].y+obj.sections[106].h + 10,
                         w = 60,
                         h = butt_h}

    --Hide tracks
    obj.sections[108] = {x = bx,
                         y = obj.sections[109].y+obj.sections[109].h + 10,
                         w = 60,
                         h = butt_h}
                         
    --LIVE CC Feedback
    obj.sections[113] = {x = bx,
                         y = obj.sections[108].y+obj.sections[108].h + 10,
                         w = 60,
                         h = butt_h}
                         

    --Create Sends
    obj.sections[111] = {x = bx-20,
                         y = obj.sections[113].y+obj.sections[113].h+6,
                         w = 100,
                         h = 20}

    obj.sections[112] = {x = bx,
                         y = obj.sections[111].y+obj.sections[111].h + 20,
                         w = 60,
                         h = butt_h}

    local w = math.min(180, gfx1.main_w - 20)
    --SetUp
    obj.sections[105] = {x = math.floor(gfx1.main_w / 2 - w/2),
                         y = obj.sections[112].y+obj.sections[112].h + 30,
                         w = w,
                         h = butt_h}

    --Exit
    local w = math.min(120, gfx1.main_w - 20)
    obj.sections[100] = {x = math.floor(gfx1.main_w / 2 - w/2),
                         y = obj.sections[105].y+obj.sections[105].h + 10,
                         w = w,
                         h = butt_h}

    --Filt setup
    local py, fsw, fsh
    if gfx1.main_h >= 670 then
      py = math.min(obj.sections[101].y + obj.sections[101].h + 24, gfx1.main_h - 660)
      fsw = math.max(math.min(gfx1.main_w-8, 300),200)
      fsh = 650
    else
      fsw = math.max(math.min(gfx1.main_w-8, 300),200)
      fsh = math.max(math.min(gfx1.main_h-8, 650),330)
      py = math.max(gfx1.main_h - fsh - 10, 8)
    end
    obj.sections[10000] = {x = math.floor(gfx1.main_w/2 - fsw/2),
                           y = py,
                           w = fsw,
                           h = fsh}

    --Title
    obj.sections[10001] = {x = 4,
                           y = 4,
                           w = fsw - 8,
                           h = butt_h}

    local bx = math.min(math.max(math.min(fsw - 70, 200), math.floor(fsw/2)),fsw - 70)
    obj.sections[10002] = {x = bx,
                           y = obj.sections[10001].y+obj.sections[10001].h + 30,
                           w = 60,
                           h = butt_h}
    obj.sections[10003] = {x = bx,
                           y = obj.sections[10002].y+obj.sections[10002].h + 10,
                           w = 60,
                           h = butt_h}
    obj.sections[10004] = {x = bx,
                           y = obj.sections[10003].y+obj.sections[10003].h + 10,
                           w = 60,
                           h = butt_h}
    obj.sections[10005] = {x = bx,
                           y = obj.sections[10004].y+obj.sections[10004].h + 10,
                           w = 60,
                           h = butt_h}
    obj.sections[10006] = {x = bx,
                           y = obj.sections[10005].y+obj.sections[10005].h + 10,
                           w = 60,
                           h = butt_h}
    obj.sections[10007] = {x = bx,
                           y = obj.sections[10006].y+obj.sections[10006].h + 10,
                           w = 60,
                           h = butt_h}
    obj.sections[10008] = {x = 10,
                           y = obj.sections[10007].y+obj.sections[10007].h + 40,
                           w = fsw-20,
                           h = fsh-(obj.sections[10007].y+obj.sections[10007].h + 40)}
    local cw = math.floor(obj.sections[10008].w / 8)
    local ch = (butt_h/2)+8
    obj.sections[10008].cw = cw
    obj.sections[10008].ch = ch
    
    --scriptwin
    obj.sections[110] = {x = 0, y = 0, w = gfx1.main_w, h = 2048}   

    --Colors
    lvar.colorsel_btnsize = 30
    lvar.colorsel_btnsize_w = 80
    lvar.colorsel_btnsize_spacer = 5
    
    local ww = 240
    
    local hhh = 15*(lvar.colorsel_btnsize+lvar.colorsel_btnsize_spacer)+(40-lvar.colorsel_btnsize_spacer)
    local hh = hhh + 50
    
    obj.sections[201] = {x = math.floor(gfx1.main_w/2 - ww/2),
                         y = math.floor(gfx1.main_h/2 - hh/2),
                         w = ww,
                         h = hh}
    
    obj.sections[200] = {x = obj.sections[201].x + 10,
                         y = obj.sections[201].y,
                         w = (ww-20)/2,
                         h = hh}
    obj.sections[202] = {x = obj.sections[200].x + obj.sections[200].w,
                         y = obj.sections[201].y,
                         w = (ww-20)/2,
                         h = hh}
    
    --Color Desc
    obj.sections[203] = {x = obj.sections[201].x,
                         y = obj.sections[200].y + hhh,
                         w = ww,
                         h = 50}                  

    --Group setup
    local ww = 300
    local hh = 340
    local bw = 60
    local bw2 = 100
    local vpad = 20
    
    obj.sections[300] = {x = math.floor(gfx1.main_w/2 - ww/2),
                         y = math.floor(gfx1.main_h/2 - hh/2),
                         w = ww,
                         h = hh}
    --type
    obj.sections[301] = {x = obj.sections[300].x + math.floor(obj.sections[300].w/2)-bw2+10,
                         y = vpad + obj.sections[300].y + butt_h + 10,
                         w = bw2,
                         h = butt_h}
    --repeats
    obj.sections[302] = {x = obj.sections[300].x + math.floor(obj.sections[300].w/2)-bw+10,
                         y = vpad + obj.sections[300].y + (butt_h + 10) * 2,
                         w = bw,
                         h = butt_h}
    --on
    obj.sections[303] = {x = obj.sections[300].x + obj.sections[300].w-bw-10,
                         y = vpad + obj.sections[300].y + butt_h + 10,
                         w = bw,
                         h = butt_h}
    --off
    obj.sections[304] = {x = obj.sections[300].x + obj.sections[300].w-bw-10,
                         y = vpad + obj.sections[300].y + (butt_h + 10) * 2,
                         w = bw,
                         h = butt_h}
    --invert
    obj.sections[309] = {x = obj.sections[300].x + math.floor(obj.sections[300].w/2)-bw+10,
                         y = vpad + obj.sections[300].y + (butt_h + 10) * 3,
                         w = bw,
                         h = butt_h}

    vpad = 10
    --type
    obj.sections[305] = {x = obj.sections[300].x + math.floor(obj.sections[300].w/2)-bw2+10,
                         y = vpad + obj.sections[300].y + math.floor(hh/2) + (butt_h + 10),
                         w = bw2,
                         h = butt_h}
    --on
    obj.sections[306] = {x = obj.sections[300].x + math.floor(obj.sections[300].w/2)-bw+10,
                         y = vpad + obj.sections[300].y + math.floor(hh/2) + (butt_h + 10) * 2,
                         w = bw,
                         h = butt_h}
    --off
    obj.sections[307] = {x = obj.sections[300].x + obj.sections[300].w-bw-10,
                         y = vpad + obj.sections[300].y + math.floor(hh/2) + (butt_h + 10),
                         w = bw,
                         h = butt_h}
    --repeats
    obj.sections[308] = {x = obj.sections[300].x + obj.sections[300].w-bw-10,
                         y = vpad + obj.sections[300].y + math.floor(hh/2) + (butt_h + 10) * 2,
                         w = bw,
                         h = butt_h}
    --invert
    obj.sections[310] = {x = obj.sections[300].x + math.floor(obj.sections[300].w/2)-bw+10,
                         y = vpad + obj.sections[300].y + math.floor(hh/2) + (butt_h + 10) * 3,
                         w = bw,
                         h = butt_h}
    
    obj.sections[311] = {x = obj.sections[300].x + obj.sections[300].w-bw-10,
                         y = vpad + obj.sections[300].y + math.floor(hh/2) + (butt_h + 10) * 3 + 10,
                         w = bw,
                         h = butt_h+10}

    obj.sections[400] = {x = 10,
                             y = math.floor(gfx1.main_h/2 - 20),
                             w = gfx1.main_w-20,
                             h = 40}

    --TAG SEARCH
    obj.sections[2000] = {x = 2,
                          y = obj.sections[50].y,
                          w = gfx1.main_w-4,
                          h = obj.sections[50].h}
    
    obj.sections[2001] = {x = 10,
                          y = 10,
                          w = obj.sections[2000].w-20,
                          h = butt_h}
    obj.sections[2002] = {x = obj.sections[2001].x,
                          y = obj.sections[2001].y+obj.sections[2001].h+10,
                          w = obj.sections[2001].w,
                          h = obj.sections[2000].h - (obj.sections[2001].y+obj.sections[2001].h+10)}
    
    return obj
  end
  
  -----------------------------------------------------------------------     
  
  function GetGUI_vars()
    gfx.mode = 0
    
    local gui = {}
      gui.aa = 1
      gui.fontname = 'Calibri'
      gui.fontsize_tab = 20    
      gui.fontsz_knob = 18
      gui.fontsz_special = 0
      local OS = reaper.GetOS()
      
      if OS == "OSX32" or OS == "OSX64" then gui.fontsize_tab = gui.fontsize_tab - 5 end
      if OS == "OSX32" or OS == "OSX64" then gui.fontsz_knob = gui.fontsz_knob - 5 end
      --if OS == "OSX32" or OS == "OSX64" then gui.fontsz_get = gui.fontsz_get - 5 end
   
      if OS == "Other" then
        gui.fontsz_knob = 15
        gui.fontsz_special = -1
      end
      gui.color = {['back'] = '87 109 130',
                    ['back2'] = '87 109 130',
                    ['black'] = '0 0 0',
                    ['green'] = '87 109 130',
                    ['blue'] = '87 109 130',
                    ['white'] = '255 255 255',
                    ['red'] = '255 42 0',
                    ['green_dark'] = '0 0 0',
                    ['yellow'] = '87 109 130',
                    ['pink'] = '87 109 130',
                    }
    return gui
  end 
  
  --------------------------------------------
  --------------------------------------------
  function table.copy(t)
    if t == nil then return nil end
    local u = { }
    for k, v in pairs(t) do u[k] = v end
    return setmetatable(u, getmetatable(t))
  end
        
  function GetTrack(t)
  
    local track
    if t == nil or t == 0 then
      track = reaper.GetMasterTrack(0)
    else
      track = reaper.GetTrack(0, t-1)
    end
    return track
  
  end

  function GetTrack2(t)
  
    if t then
      return reaper.GetTrack(0, t-1)
    end
  end

  function GetTrackByName(tn)
  
    for t = 0, reaper.CountTracks(0) do
      local track = GetTrack(t)
      local _, trackname = reaper.GetTrackName(track)
      if trackname == tn then
        return track
      end
    end
    
  end
  
  function table_sort(tab, key)
    if tab then
      table.sort(tab, function(a,b) return a[key] < b[key] end)
      return tab
    end
  end
  
  function table_slowsort_gen(tbl,idxfield)
  
     local dtbl = {}
     local rtbl
     local cnt = #tbl
     if cnt > 0 then
       for st = 1, cnt do
         if st == 1 then
           --insert
           table.insert(dtbl, tbl[st])
         else
           local inserted = false
           local dcnt = #dtbl
           for dt = 1, dcnt do
             if dtbl[dt][idxfield] then
               if tbl[st] and dtbl[dt] and (tonumber(tbl[st][idxfield]) or 0) > (tonumber(dtbl[dt][idxfield]) or 0) then
                 table.insert(dtbl, dt, tbl[st])
                 inserted = true
                 break
               end
             else
               break
             end
           end
           if inserted == false then
             table.insert(dtbl, tbl[st])
           end
         end
       end
       rtbl = {}
       for dt = #dtbl, 1, -1 do
         rtbl[#dtbl-(dt-1)] = dtbl[dt]
       end
     end
     return rtbl
  end
  
  function table_slowsort_str(tbl,idxfield)
  
     local dtbl = {}
     local rtbl
     local cnt = #tbl
     if cnt > 0 then
       for st = 1, cnt do
         if st == 1 then
           --insert
           table.insert(dtbl, tbl[st])
         else
           local inserted = false
           local dcnt = #dtbl
           for dt = 1, dcnt do
             if dtbl[dt][idxfield] then
               if tbl[st] and dtbl[dt] and (tbl[st][idxfield] or '') > (dtbl[dt][idxfield] or '') then
                 table.insert(dtbl, dt, tbl[st])
                 inserted = true
                 break
               end
             else
               break
             end
           end
           if inserted == false then
             table.insert(dtbl, tbl[st])
           end
         end
       end
       rtbl = {}
       for dt = #dtbl, 1, -1 do
         rtbl[#dtbl-(dt-1)] = dtbl[dt]
       end
     end
     return rtbl
  end

  function ToggleAssDispMode()
    if lvar.assignmentdisplay and lvar.assignmentdisplay_active then
      lvar.AKLayerMode = lvar.AKLayerMode + 1
      if lvar.AKLayerMode > 3 then
        lvar.AKLayerMode = 0
      end
    end
  end
  
  function ToggleFBMode()
    lvar.fbcconseek = not lvar.fbcconseek
    local v = 0
    if lvar.fbcconseek == true then
      v = 1
    end
    if LBX_CTL_TRACK then
      local tr = GetTrack(LBX_CTL_TRACK)
      if tr then
        --for i = 0, reaper.TrackFX_GetCount(tr)-2 do
          reaper.gmem_write(lvar.gm_fb.gswitch50, v)
          --reaper.TrackFX_SetParam(tr, i, 49, v)
        --end
      end
    end
    lupd.update_gfx = true
  end
  
  function FBToggle()
  
    if LBX_CTL_TRACK then
      local tr = GetTrack(LBX_CTL_TRACK)
      if tr then
        local v = reaper.TrackFX_GetParam(tr,0,47) 
        reaper.TrackFX_SetParam(tr,0,47,1-v)
        for f = 1, reaper.TrackFX_GetCount(tr)-1 do
          reaper.TrackFX_SetParam(tr,f,47,1-v)
        end
        lupd.update_gfx = true
      end
    end
  
  end

  function FBActive()
  
    if LBX_CTL_TRACK then
      local tr = GetTrack(LBX_CTL_TRACK)
      if tr then
        local v = reaper.TrackFX_GetParam(tr,0,47)
        return v
      end
    end
  
  end

  function FBToggle2()
  
    if LBX_CTL_TRACK then
      local tr = GetTrack(LBX_CTL_TRACK)
      if tr then
        local v = reaper.gmem_read(lvar.gm_fb.gswitch47) --reaper.TrackFX_GetParam(tr,0,46) 
        reaper.gmem_write(lvar.gm_fb.gswitch47,1-v)
        
        --reaper.TrackFX_SetParam(tr,0,46,1-v)
        --[[for f = 1, reaper.TrackFX_GetCount(tr)-1 do
          reaper.TrackFX_SetParam(tr,f,46,1-v)
        end]]
        lupd.update_gfx = true
      end
    end
  
  end
  
  function FBActive2()
  
    if LBX_CTL_TRACK then
      local tr = GetTrack(LBX_CTL_TRACK)
      if tr then
        local v = reaper.gmem_read(lvar.gm_fb.gswitch47) --reaper.TrackFX_GetParam(tr,0,46)
        return v
      end
    end
  
  end
  
  function SetAutoMode(trn, m)
  
    reaper.PreventUIRefresh(1)
    if lvar.mode ~= 3 then
      local track = GetTrack(trn)
      if track then
        reaper.SetTrackAutomationMode(track, m)
      end
    else
      --track mode - check assignments
      if m == 0 and lvar.automode_active then
        for i = 1, #lvar.automode_active do
          local track = GetTrack(lvar.automode_active[i])
          if track then
            reaper.SetTrackAutomationMode(track, m)          
          end
        end
        lvar.automode_active = nil
      else
        local trns = {}
        --always set selected track even if assignments do not exist
        local seltr = reaper.GetSelectedTrack2(0,0,true)
        if seltr then
          local trn = reaper.GetMediaTrackInfo_Value(seltr, 'IP_TRACKNUMBER')
          trns[trn] = true
        end
        for i = 1, lvar.fcount do
          
          local tmp = GetTemplate(i)
          local tmppos = tmp.pos[i]
          if tmppos and tmppos.ptype == ptype.track then
            local trn = tmppos.track
            local ttrn, trackD = Internal_GetTrack(trn, tmppos)
            --[[if trn then
              if trn <= -1 then
                if trn == -1 then
                  trackD = reaper.GetSelectedTrack2(0, 0, true)
                  if trackD then
                    ttrn = reaper.GetMediaTrackInfo_Value(trackD, 'IP_TRACKNUMBER')
                  end
                elseif trn == -2 then
                  ttrn = lvar.track_internal + tmppos.troff 
                  if lvar.ctltracks[ttrn] then
                    ttrn = ttrn + lvar.ctltracks.count
                  end 
                  trackD = GetTrack(ttrn)
                end
              else
                trackD = GetTrack(trn)
                ttrn = trn
              end
            end]]
            if ttrn then
              trns[ttrn] = true
            end
          end
  
        end
        
        lvar.automode_active = {}
        
        for a,b in pairs(trns) do
          local track = GetTrack(a)
          if m > 0 then
            lvar.automode_active[#lvar.automode_active+1] = a
          end
          if track then
            reaper.SetTrackAutomationMode(track, m)
          end    
        end    
      end
    end
    reaper.PreventUIRefresh(-1)
  end
  
  function Menu_AutoMode(trn)
  
    --set automode to trim/read
    local track = GetTrack(trn)
    local am = reaper.GetTrackAutomationMode(track, 0)
  
    local mstr = ''
    for i = 1, #tab_automode do
      if i > 1 then
        mstr = mstr..'|'
      end
      if i < 3 then
        mstr = mstr .. '#'
      end
      if LBX_CTL_TRACK_AM == i-1 then
        mstr = mstr..'!'
      end
      mstr = mstr..tab_automode[i]
    end
    local ssco = ''
    if lvar.ss_color_override_enabled then
      ssco = '!'
    end
    local ssna = ''
    if lvar.ss_color_override_nonautomatable then
      ssna = '!'
    end
    local rom = ''
    if lvar.recoffmode == 1 then
      rom = '!'
    end
    local sp = ''
    if lvar.rec_starttransportonfadertouch then
      sp = '!'
    end
    local amm = ''
    if recmode == 1 then
      amm = '#'
    end
    local am = ''
    if lvar.rec_mapactiveenvstofaders2 then
      am = '!'
    end
    local am2 = ''
    if lvar.rec_automap_solo then
      am2 = '!'
    end
    
    local dv
    local dm = {'','','',''}
    local dmAll = ''
    local dmChk = ''
    if lvar.rec_automap_device == -1 then
      dv = 'All Devices'
      dmAll = '!'
    else
      dmChk = '!'
      dv = lvar.midimap[lvar.rec_automap_device]
      dm[lvar.rec_automap_device] = '!'
    end
    local devlist = dmAll..'All Devices|'
    for i = 1, 4 do
      if lvar.midimap[i] then
        if i == 4 then
          devlist = devlist ..'|<'
        else
          devlist = devlist ..'|'
        end
        devlist = devlist..dm[i]..lvar.midimap[i]
      else
        if i == 4 then
          devlist = devlist ..'|<#'
        else
          devlist = devlist ..'|#'
        end
        devlist = devlist..'Device '..string.format('%i',i)
      end
    end
    
    mstr = mstr .. '||'..ssco..'Scribble Color Override - Automatable Params|'..ssna..'Scribble Color Override - Non-Automatable Params'..
                   '||'..rom..'REC off automation mode = Read||'..sp..'Start transport on fader touch||'
                   ..am..amm..'Automap: Map selected track active envelopes to faders|'
                   ..am2..amm..'Automap: Show only selected track envelopes (hide others)|'
                   ..dmChk..amm..'>Automap Device: ['..dv..']|'..devlist
    gfx.x, gfx.y = mouse.mx, mouse.my
    local res = gfx.showmenu(mstr)
    return res-1
  
  end
  
  function GetCTLTrack()
    
    for i = 1, reaper.CountTracks(0) do
      local track = GetTrack(i)
      if track ~= nil then
        local trname, _ = reaper.GetTrackState(track)  
        if trname == LBX_CTL_TRNAME then
          LBX_CTL_TRACK = i
          LBX_CTL_TRACK_GUID = reaper.GetTrackGUID(track)
          LBX_CTL_TRACK_INF = {count = reaper.TrackFX_GetCount(track),
                               guids = {}}
                               
          if LBX_CTL_TRACK_INF.count > 0 then
            local cnt = LBX_CTL_TRACK_INF.count                     
            for f = 0, cnt-1 do
              local _, fxnm = reaper.TrackFX_GetFXName(track,f,'')
              if fxnm == 'JS: LBX_SKCTL' then
                LBX_CTL_TRACK_INF.guids[f] = reaper.TrackFX_GetFXGUID(track,f)
              elseif fxnm == 'JS: LBX_FBOut' then
                LBX_CTL_TRACK_INF.count = LBX_CTL_TRACK_INF.count-1
                LBX_FBOUT_FXNUM = f
              end
            end
          end
          control_cnt = reaper.TrackFX_GetParam(track,0,0)
          return track
        end
      end
    end
    
  end

  function GetAITrack()
    
    for i = 1, reaper.CountTracks(0) do
      local track = GetTrack(i)
      if track ~= nil then
        local trname, _ = reaper.GetTrackState(track)  
        if trname == LBX_AI_TRNAME then
          LBX_AI_TRACK = i
          LBX_AI_TRACK_GUID = reaper.GetTrackGUID(track)
                               
          return track
        end
      end
    end
    
  end

  --[[function GetTOUCHTrack()
    
    for i = 1, reaper.CountTracks(0) do
      local track = GetTrack(i)
      if track ~= nil then
        local trname, _ = reaper.GetTrackState(track)  
        if trname == LBX_TOUCH_TRNAME then
          LBX_TOUCH_TRACK = i
          LBX_TOUCH_TRACK_GUID = reaper.GetTrackGUID(track)
                               
          return track
        end
      end
    end
    
  end]]

  function GetCCTrack()
    
    for i = 1, reaper.CountTracks(0) do
      local track = GetTrack(i)
      if track ~= nil then
        local trname, _ = reaper.GetTrackState(track)  
        if trname == LBX_CC_TRNAME then
          LBX_CC_TRACK = i
          LBX_CC_TRACK_GUID = reaper.GetTrackGUID(track)
          LBX_CC_TRACK_INF = {count = reaper.TrackFX_GetCount(track),
                              guids = {}}
                               
          if LBX_CC_TRACK_INF.count > 0 then                     
            for f = 0, LBX_CC_TRACK_INF.count-1 do
              LBX_CC_TRACK_INF.guids[f] = reaper.TrackFX_GetFXGUID(track,f)
            end
          end
          return track
        end
      end
    end
    
  end

  function GetFOLTrack(justfol)

    local t = reaper.time_precise()
    
    local tracks = {}
    local tcnt = 0
    local ftrack
    for i = reaper.CountTracks(0), 1, -1 do
      ftrack = GetTrack(i)
      if ftrack ~= nil then
        local trname, _ = reaper.GetTrackState(ftrack)  
        if trname == LBX_FOL_TRNAME then
          tracks.fol = i
          LBX_FOL_TRACK = i
          LBX_FOL_TRACK_GUID = reaper.GetTrackGUID(ftrack)
          if justfol then
            return ftrack, nil
          end
          tcnt = tcnt + 1
        end
      end
    end

    local track
    LBX_INPUTCC_TRACKS = {}
    LBX_INPUTCC_TRACK_GUID = {}
    LBX_INPUT_TRACKS = {}
    LBX_INPUT_TRACK_GUID = {}
    LBX_OUT_TRACKS = {}
    LBX_OUT_TRACK_GUID = {}
    LBX_SYSX_OUT = {}
    
    local startsearch = LBX_FOL_TRACK or -1
    for i = startsearch+1, startsearch+1+lvar.tracks.tot do
      local track = GetTrack(i)
      if track ~= nil then
        local trname, _ = reaper.GetTrackState(track)  
        if trname == LBX_CTL_TRNAME then
          --DBG(trname)
          LBX_CTL_TRACK = i
          LBX_CTL_TRACK_GUID = reaper.GetTrackGUID(track)
          LBX_CTL_TRACK_INF = {count = reaper.TrackFX_GetCount(track),
                               guids = {}}
                               
          if LBX_CTL_TRACK_INF.count > 0 then
            local cnt = LBX_CTL_TRACK_INF.count                     
            for f = 0, cnt-1 do
              local _, fxnm = reaper.TrackFX_GetFXName(track,f,'')
              if fxnm == 'JS: LBX_SKCTL' then
                LBX_CTL_TRACK_INF.guids[f] = reaper.TrackFX_GetFXGUID(track,f)
              elseif fxnm == 'JS: LBX_FBOut' then
                LBX_CTL_TRACK_INF.count = LBX_CTL_TRACK_INF.count-1
                LBX_FBOUT_FXNUM = f
              end
            end
          end
          control_cnt = reaper.TrackFX_GetParam(track,0,0)
          tracks.ctl = track
          tcnt = tcnt + 1

        elseif trname == LBX_CC_TRNAME then
          --DBG(trname)
          LBX_CC_TRACK = i
          LBX_CC_TRACK_GUID = reaper.GetTrackGUID(track)
          LBX_CC_TRACK_INF = {count = reaper.TrackFX_GetCount(track),
                              guids = {}}
                               
          if LBX_CC_TRACK_INF.count > 0 then                     
            for f = 0, LBX_CC_TRACK_INF.count-1 do
              LBX_CC_TRACK_INF.guids[f] = reaper.TrackFX_GetFXGUID(track,f)
            end
          end
          tracks.cc = track
          tcnt = tcnt + 1
        
        elseif string.match(trname,'SKCC_IN_') then
          --DBG(trname)
          local idx = #LBX_INPUTCC_TRACKS+1
          LBX_INPUTCC_TRACKS[idx] = i
          LBX_INPUTCC_TRACK_GUID[idx] = reaper.GetTrackGUID(track)
          tracks.skincc = track
          tcnt = tcnt + 1
        
        elseif string.match(trname,'__LBX_OUT') then
          --DBG(trname)
          local devbus = string.match(trname,'__LBX_OUT_(%d+)_')
          if devbus then
            LBX_SYSX_OUT[tonumber(devbus)] = i
            reaper.TrackFX_SetParam(track,0,7,tonumber(devbus))
          end
          local idx = #LBX_OUT_TRACKS+1
          LBX_OUT_TRACKS[idx] = i
          LBX_OUT_TRACK_GUID[idx] = reaper.GetTrackGUID(track)
          tracks.out = track
          tcnt = tcnt + 1
        
        elseif string.match(trname,'__LBX_RRMIDI') then
          --DBG(trname)
          LBX_RR_TRACK = i
          LBX_RR_TRACK_GUID = reaper.GetTrackGUID(track)
          LBX_RR_TRACK_INF = {count = reaper.TrackFX_GetCount(track),
                              guids = {}}
                               
          if LBX_RR_TRACK_INF.count > 0 then                     
            for f = 0, LBX_RR_TRACK_INF.count-1 do
              LBX_RR_TRACK_INF.guids[f] = reaper.TrackFX_GetFXGUID(track,f)
            end
          end
          tracks.rr = track
          tcnt = tcnt + 1

        elseif string.match(trname,'SK_IN_') then
          --DBG(trname)
          local idx = #LBX_INPUT_TRACKS+1
          LBX_INPUT_TRACKS[idx] = i
          LBX_INPUT_TRACK_GUID[idx] = reaper.GetTrackGUID(track)
          tracks.skin = track
          tcnt = tcnt + 1
        
        elseif trname == LBX_IN_TRNAME then
          --DBG(trname)
          LBX_IN_TRACK = i
          LBX_IN_TRACK_GUID = reaper.GetTrackGUID(track)
          LBX_IN_TRACK_INF = {count = reaper.TrackFX_GetCount(track),
                              guids = {}}
          tracks.input = track
          tcnt = tcnt + 1
        end
      end    
    end
    
    --DBG(reaper.time_precise()-t)
    tracks.count = tcnt
    return ftrack, tracks
  end

  function GetINTrack()
    
    for i = LBX_FOL_TRACK, reaper.CountTracks(0) do
      local track = GetTrack(i)
      if track ~= nil then
        local trname, _ = reaper.GetTrackState(track)  
        if trname == LBX_IN_TRNAME then
          LBX_IN_TRACK = i
          LBX_IN_TRACK_GUID = reaper.GetTrackGUID(track)
          LBX_IN_TRACK_INF = {count = reaper.TrackFX_GetCount(track),
                              guids = {}}
          return track
        end
      end
    end
    
  end

  function GetRRTrack()
    
    for i = 1, reaper.CountTracks(0) do
      local track = GetTrack(i)
      if track ~= nil then
        local trname, _ = reaper.GetTrackState(track)  
        if string.match(trname,'__LBX_RRMIDI') then
          LBX_RR_TRACK = i
          LBX_RR_TRACK_GUID = reaper.GetTrackGUID(track)
          LBX_RR_TRACK_INF = {count = reaper.TrackFX_GetCount(track),
                              guids = {}}
                               
          if LBX_RR_TRACK_INF.count > 0 then                     
            for f = 0, LBX_RR_TRACK_INF.count-1 do
              LBX_RR_TRACK_INF.guids[f] = reaper.TrackFX_GetFXGUID(track,f)
            end
          end
          return track
        end
      end
    end
    
  end

  function GetInputTracks()
  
    LBX_INPUT_TRACKS = {}
    LBX_INPUT_TRACK_GUID = {}
    
    local tr
    for i = 1, reaper.CountTracks(0) do
      local track = GetTrack(i)
      if track ~= nil then
        local trname, _ = reaper.GetTrackState(track) 
        if string.match(trname,'SK_IN_') then
          local idx = #LBX_INPUT_TRACKS+1
          LBX_INPUT_TRACKS[idx] = i
          LBX_INPUT_TRACK_GUID[idx] = reaper.GetTrackGUID(track)
          tr = track
        end
      end
    end
    return tr
  end

  function GetOUTTracks()
  
    LBX_OUT_TRACKS = {}
    LBX_OUT_TRACK_GUID = {}
    LBX_SYSX_OUT = {}
    
    local tr
    for i = 1, reaper.CountTracks(0) do
      local track = GetTrack(i)
      if track ~= nil then
        local trname, _ = reaper.GetTrackState(track) 
        if string.match(trname,'__LBX_OUT') then
          local devbus = string.match(trname,'__LBX_OUT_(%d+)_')
          if devbus then
            LBX_SYSX_OUT[tonumber(devbus)] = i
            reaper.TrackFX_SetParam(track,0,7,tonumber(devbus))
            --DBG(i..trname..'  '..devbus)
          end
          local idx = #LBX_OUT_TRACKS+1
          LBX_OUT_TRACKS[idx] = i
          LBX_OUT_TRACK_GUID[idx] = reaper.GetTrackGUID(track)
          tr = track
        end
      end
    end
    return tr
  end

  function CheckMasterTrackSolo()
    local track = reaper.GetMasterTrack(0)
    if track then
      local _, state = reaper.GetTrackState(track)
      if state&16==16 then
        lvar.msg = "Master track solo enabled..."
      else
        if lvar.msg == "Master track solo enabled..." then
          lvar.msg = nil
          lupd.update_gfx = true
          lvar.reset = true
        end
      end
    end
  end

  function GetInputCCTracks()
  
    LBX_INPUTCC_TRACKS = {}
    LBX_INPUTCC_TRACK_GUID = {}
    
    local tr
    for i = 1, reaper.CountTracks(0) do
      local track = GetTrack(i)
      if track ~= nil then
        local trname, _ = reaper.GetTrackState(track) 
        if string.match(trname,'SKCC_IN_') then
          local idx = #LBX_INPUTCC_TRACKS+1
          LBX_INPUTCC_TRACKS[idx] = i
          LBX_INPUTCC_TRACK_GUID[idx] = reaper.GetTrackGUID(track)
          tr = track
        end
      end
    end
    return tr
  end
    
  function SetCCInputData(channel, startcc)
  
    if LBX_CC_TRACK then
      local tr = GetTrack(LBX_CC_TRACK)
      if channel then
        reaper.TrackFX_SetParam(tr, 0, 1, channel)
      end
      if startcc then
        reaper.TrackFX_SetParam(tr, 0, 2, startcc)
      end
      reaper.TrackFX_SetParam(tr, 0, 3, 1)    
    end
    
  end
  
  function SetCCSend(dtrn)

    if LBX_CC_TRACK then
      --if not settings.ccsend then
        --remove send
        --[[local track = GetTrack(LBX_CC_TRACK)
        local scnt = reaper.GetTrackNumSends(track,0)
        for s = scnt-1,0,-1 do
          reaper.RemoveTrackSend(track, 0, s)
        end
        if dtrn then
          local dtrack = GetTrack(dtrn)
          reaper.CreateTrackSend(track, dtrack)      
          reaper.SetTrackSendInfo_Value(track, 0, 0, 'I_SRCCHAN', -1)
        end
        if LBX_RR_TRACK then
          local rtrack = GetTrack(LBX_RR_TRACK) 
          if rtrack then
            local idx = reaper.CreateTrackSend(track, rtrack)
            reaper.SetTrackSendInfo_Value(track, 0, idx, 'I_SRCCHAN', -1)          
          end
        end]]
      --else
      
        local t = reaper.time_precise()
        
        if recmode == 0 then
          SetSends2(dtrn)
        end
        
      --end
    end
  end
  
  function SetSendsAuto(all)
    GUI_DrawMsg(obj, gui, {'Creating Sends', '', 'Please Wait...','This may take some time.'})
    lvar.setsendsauto_all = all
    lvar.setsendsauto_timer = reaper.time_precise() + 0.5
    --SetSendsAuto2(all)
  end
  
  function SetSendsAuto2(all)

    reaper.PreventUIRefresh(1)
  
    local ttt = reaper.time_precise()
    
    local tcnt = reaper.CountTracks()    

    local track_cc = GetTrack(LBX_CC_TRACK)
    local track_ctl = GetTrack(LBX_CTL_TRACK)
    local track_rr = GetTrack(LBX_RR_TRACK)
    local track_in = GetTrack(LBX_IN_TRACK)
    
    
    --[[local track_in = {}
    for i = 1, #LBX_INPUT_TRACKS do
      track_in[i] = GetTrack(LBX_INPUT_TRACKS[i])
    end]]

    local cnt_cc, cnt_input, cnt_ctl = 0,0,0

    local sel = {}
    if not all then
      local i = 0
      local str = reaper.GetSelectedTrack(0,i)
      while str do
        strn = reaper.GetMediaTrackInfo_Value(str,'IP_TRACKNUMBER')
        sel[strn] = true
        i=i+1
        str = reaper.GetSelectedTrack(0,i)
      end
      --DBG('sel:'..i)
    end
    
    if not lvar.midiloopbackdev then
      local found = table.copy(lvar.ctltracks) or {}
      
      --CC
      local scnt = reaper.GetTrackNumSends(track_cc,0)
      for s = 0, scnt-1 do
        local dtr = reaper.BR_GetMediaTrackSendInfo_Track(track_cc,0,s,1)
        local dtn = reaper.GetMediaTrackInfo_Value(dtr,'IP_TRACKNUMBER')
        found[dtn] = true
      end
  
      for i = 0, tcnt do 
        if not found[i] then
          if all or sel[i] then
            --create
            cnt_cc = cnt_cc + 1
            local tr = GetTrack(i)
            local idx = reaper.CreateTrackSend(track_cc, tr)
                  
            reaper.SetTrackSendInfo_Value(track_cc, 0, idx, 'B_MUTE', 1)         
            reaper.SetTrackSendInfo_Value(track_cc, 0, idx, 'I_SRCCHAN', -1)
            reaper.BR_GetSetTrackSendInfo(track_cc, 0, idx, 'I_MIDI_SRCCHAN', true, 0)         
          end
        end
      end
      
      local found = table.copy(lvar.ctltracks) or {}
            
      --IN
      local scnt = reaper.GetTrackNumSends(track_in,0)
      for s = 0, scnt-1 do
        local dtr = reaper.BR_GetMediaTrackSendInfo_Track(track_in,0,s,1)
        local dtn = reaper.GetMediaTrackInfo_Value(dtr,'IP_TRACKNUMBER')
        found[dtn] = true
      end
  
      for t = 0, tcnt do 
        if not found[t] then
          if all or sel[t] then
            --create
            cnt_input = cnt_input + 1
            local tr = GetTrack(t)
            local idx = reaper.CreateTrackSend(track_in, tr)      
            reaper.SetTrackSendInfo_Value(track_in, 0, idx, 'B_MUTE', 1)         
            reaper.SetTrackSendInfo_Value(track_in, 0, idx, 'I_SRCCHAN', -1)
            reaper.BR_GetSetTrackSendInfo(track_in, 0, idx, 'I_MIDI_SRCCHAN', true, 0)         
          end
        end
      end
      
    end
    
    local found = table.copy(lvar.ctltracks) or {}

    --TGT
    if settings.liveccfb == true then
      local scnt = reaper.GetTrackNumSends(track_ctl,-1)
      for s = 0, scnt-1 do
        local dtr = reaper.BR_GetMediaTrackSendInfo_Track(track_ctl,-1,s,0)
        local dtn = reaper.GetMediaTrackInfo_Value(dtr,'IP_TRACKNUMBER')
        found[dtn] = true
      end
  
      for i = 0, tcnt do 
        if not found[i] then
          if all or sel[i] then
            --create
            cnt_ctl = cnt_ctl + 1
            local tr = GetTrack(i)
            local idx = reaper.CreateTrackSend(tr, track_ctl)      
            reaper.SetTrackSendInfo_Value(tr, 0, idx, 'B_MUTE', 1)         
            reaper.SetTrackSendInfo_Value(tr, 0, idx, 'I_SRCCHAN', -1)
            reaper.BR_GetSetTrackSendInfo(tr, 0, idx, 'I_MIDI_SRCCHAN', true, 0)         
          end
        end
      end
    end
    
    local track = reaper.GetSelectedTrack(0,0)
    if track then    
      local trn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
      if trn and not lvar.ctltracks[trn] --[[trn >= lvar.track_internal_min]] and recmode == 0 then
        SetCCSend(trn)
      end 
    end
    reaper.PreventUIRefresh(-1)
    
    --[[DBG(cnt_cc..' CC sends created')
    DBG(cnt_input..' Input sends created')
    DBG(cnt_ctl..' CTL feedback sends created')
    DBG('')
    DBG('Time taken: '..reaper.time_precise()-ttt)]]
  end
  
  local function CheckCTLGUID()
    local track = GetTrack(LBX_CTL_TRACK)
    if track and reaper.GetTrackGUID(track) == LBX_CTL_TRACK_GUID then
      CTMISSING = nil
      return true, track
    else
      LBX_CTL_TRACK = nil
      --local track = GetCTLTrack()
      local _, track = GetFOLTrack()
      if track then
        lvar.trackinfo = track
      end
      lvar.getfound = true
      if track.ctl then CTMISSING = nil else CTMISSING = true end
      return false, track
    end 
  end
  
  function SetSends2(dtrn)
 
    if dtrn == -1 then return end
    
    reaper.PreventUIRefresh(1)
    
    local t = reaper.time_precise()
    
    local found = table.copy(lvar.ctltracks) or {}
    
    if found[dtrn] then return end
    
    local track_tgt = GetTrack(dtrn)
    lvar.seltrackguid = reaper.GetTrackGUID(track_tgt)


    local ret, track_ctl = CheckCTLGUID()
    if not ret then
      return
    end
    local track_cc = GetTrack(LBX_CC_TRACK)
    local track_rr = GetTrack(LBX_RR_TRACK)
    local track_in = GetTrack(LBX_IN_TRACK)
    
    --[[local track_in = {}
    for i = 1, #LBX_INPUT_TRACKS do
      track_in[i] = GetTrack(LBX_INPUT_TRACKS[i])
    end]]
    
    if not lvar.midiloopbackdev then
      --CC
      local scnt = reaper.GetTrackNumSends(track_cc,0)
      local found, rrfound 
      for s = 0, scnt-1 do
        local dtr = reaper.BR_GetMediaTrackSendInfo_Track(track_cc,0,s,1)
        local dtn = reaper.GetMediaTrackInfo_Value(dtr,'IP_TRACKNUMBER')
        if dtn == dtrn then
          reaper.SetTrackSendInfo_Value(track_cc,0,s,'B_MUTE',0)
          found = true
        elseif dtn == LBX_RR_TRACK then
          reaper.SetTrackSendInfo_Value(track_cc,0,s,'B_MUTE',0)
          rrfound = true
        else
          reaper.SetTrackSendInfo_Value(track_cc,0,s,'B_MUTE',1)
        end
      end
      if not found then
        --create
        local idx = reaper.CreateTrackSend(track_cc, track_tgt)      
        reaper.SetTrackSendInfo_Value(track_cc, 0, idx, 'I_SRCCHAN', -1)
        reaper.BR_GetSetTrackSendInfo(track_cc, 0, idx, 'I_MIDI_SRCCHAN', true, 0) 
      end
      if not rrfound then
        --create
        local idx = reaper.CreateTrackSend(track_cc, track_rr)      
        reaper.SetTrackSendInfo_Value(track_cc, 0, idx, 'I_SRCCHAN', -1)
        reaper.BR_GetSetTrackSendInfo(track_cc, 0, idx, 'I_MIDI_SRCCHAN', true, 0) 
      end
      
      --IN
      local scnt = reaper.GetTrackNumSends(track_in,0)
      local found, rrfound 
      for s = 0, scnt-1 do
        local dtr = reaper.BR_GetMediaTrackSendInfo_Track(track_in,0,s,1)
        local dtn = reaper.GetMediaTrackInfo_Value(dtr,'IP_TRACKNUMBER')
        if dtn == dtrn then
          reaper.SetTrackSendInfo_Value(track_in,0,s,'B_MUTE',0)
          found = true
        elseif dtn == LBX_RR_TRACK then
          reaper.SetTrackSendInfo_Value(track_in,0,s,'B_MUTE',0)
          rrfound = true
        else
          reaper.SetTrackSendInfo_Value(track_in,0,s,'B_MUTE',1)        
        end
      end
      if not found then
        --create
        local idx = reaper.CreateTrackSend(track_in, track_tgt)      
        reaper.SetTrackSendInfo_Value(track_in, 0, idx, 'I_SRCCHAN', -1)
        reaper.BR_GetSetTrackSendInfo(track_in, 0, idx, 'I_MIDI_SRCCHAN', true, 0) 
      end
      if not rrfound then
        --create
        local idx = reaper.CreateTrackSend(track_in, track_rr)      
        reaper.SetTrackSendInfo_Value(track_in, 0, idx, 'I_SRCCHAN', -1)
        reaper.BR_GetSetTrackSendInfo(track_in, 0, idx, 'I_MIDI_SRCCHAN', true, 0) 
      end
    end
        
    --TGT
   
    if settings.liveccfb == true then
      local scnt = reaper.GetTrackNumSends(track_ctl,-1)
      local found 
      for s = 0, scnt-1 do
        local dtr = reaper.BR_GetMediaTrackSendInfo_Track(track_ctl,-1,s,0)
        if dtr then
          local dtn = reaper.GetMediaTrackInfo_Value(dtr,'IP_TRACKNUMBER')
          local dtnm = reaper.GetTrackState(dtr) 
          if dtn == dtrn then
            reaper.SetTrackSendInfo_Value(track_ctl,-1,s,'B_MUTE',0)
            found = true
          elseif not string.match(dtnm, '^SKCC_IN_') then
            reaper.SetTrackSendInfo_Value(track_ctl,-1,s,'B_MUTE',1)      
          end
        end
      end
      if not found then
        --create
        local idx = reaper.CreateTrackSend(track_tgt, track_ctl)      
        reaper.SetTrackSendInfo_Value(track_tgt, 0, idx, 'I_SRCCHAN', -1)
        reaper.BR_GetSetTrackSendInfo(track_tgt, 0, idx, 'I_MIDI_SRCCHAN', true, 0) 
      end
    end
    
    --reaper.SetOnlyTrackSelected(track_tgt)
  
    reaper.PreventUIRefresh(-1)
  
    --DBG(reaper.time_precise()-t)
  end
  
  --[[function SetSends(dtrn)
  
    local track_tgt = GetTrack(dtrn)
    lvar.seltrackguid = reaper.GetTrackGUID(track_tgt)
    local track_cc = GetTrack(LBX_CC_TRACK)
    local track_ctl = GetTrack(LBX_CTL_TRACK)
    local track_rr = GetTrack(LBX_RR_TRACK)
    local track_in = {}
    for i = 1, #LBX_INPUT_TRACKS do
      track_in[i] = GetTrack(LBX_INPUT_TRACKS[i])
    end
    
    --remove target send CC -- check for RR send
    local cc_rrsend = false
    local scnt = reaper.GetTrackNumSends(track_cc,0)
    for s = scnt-1,0,-1 do
      --local trn = reaper.GetTrackSendInfo_Value(track_cc, 0, s, 'P_DESTTRACK')
      local _, snm = reaper.GetTrackSendName(track_cc,s,'')
      if snm == LBX_RR_TRNAME then
        cc_rrsend = true
      else
        reaper.RemoveTrackSend(track_cc, 0, s)
      end
    end  
    
    --remove target send IN -- check for RR send
    local in_rrsend = false
    for i = 1, #track_in do
      local scnt = reaper.GetTrackNumSends(track_in[i],0)
      for s = scnt-1,0,-1 do
        --local trn = reaper.GetTrackSendInfo_Value(track_in[i], 0, s, 'P_DESTTRACK')
        local _, snm = reaper.GetTrackSendName(track_in[i],s,'')
        if snm == LBX_RR_TRNAME then
          in_rrsend = true
        else
          reaper.RemoveTrackSend(track_in[i], 0, s)
        end
      end    
    end
    
    --remove receives CTL
    local scnt = reaper.GetTrackNumSends(track_ctl,-1)
    for s = scnt-1,0,-1 do
      local trn = reaper.GetTrackSendInfo_Value(track_ctl, -1, s, 'P_SRCTRACK')
      if trn+1 ~= LBX_TOUCH_TRACK then
        reaper.RemoveTrackSend(track_ctl, -1, s)
      end
    end
    
    if track_tgt then
      --create target send CC
      local idx = reaper.CreateTrackSend(track_cc, track_tgt)      
      reaper.SetTrackSendInfo_Value(track_cc, 0, idx, 'I_SRCCHAN', -1)  
      
      --create target send IN
      for i = 1, #track_in do
        local idx = reaper.CreateTrackSend(track_in[i], track_tgt)      
        reaper.SetTrackSendInfo_Value(track_in[i], 0, idx, 'I_SRCCHAN', -1)  
      end
      
      --create receive CTL (target)
      local idx = reaper.CreateTrackSend(track_tgt, track_ctl)      
      reaper.SetTrackSendInfo_Value(track_tgt, 0, idx, 'I_SRCCHAN', -1)  
    end
    
    if track_rr then
      --create RR send CC
      if cc_rrsend == false then
        local idx = reaper.CreateTrackSend(track_cc, track_rr)      
        reaper.SetTrackSendInfo_Value(track_cc, 0, idx, 'I_SRCCHAN', -1)      
      end
      
      --create RR send IN
      if in_rrsend == false then
        for i = 1, #track_in do
          local idx = reaper.CreateTrackSend(track_in[i], track_rr)      
          reaper.SetTrackSendInfo_Value(track_in[i], 0, idx, 'I_SRCCHAN', -1)  
        end
      end
    end
  
  end]]
  
  local function CheckCCGUID()
    local track = GetTrack(LBX_CC_TRACK)
    if track and reaper.GetTrackGUID(track) == LBX_CC_TRACK_GUID then
      CTCCMISSING = nil
      return true, track
    else
      LBX_CC_TRACK = nil
      --local track = GetCCTrack()
      local _, track = GetFOLTrack()
      if track then
        lvar.trackinfo = track
      end
      lvar.getfound = true
      if track.cc then CTCCMISSING = nil else CTCCMISSING = true end
      return false, track
    end 
  end

  local function CheckRRGUID()
    local track = GetTrack(LBX_RR_TRACK)
    if track and reaper.GetTrackGUID(track) == LBX_RR_TRACK_GUID then
      CTRRMISSING = nil
      return true, track
    else
      LBX_RR_TRACK = nil
      --local track = GetRRTrack()
      local _, track = GetFOLTrack()
      if track then
        lvar.trackinfo = track
      end
      lvar.getfound = true
      if track.rr then CTRRMISSING = nil else CTRRMISSING = true end
      return false, track
    end 
  end

  local function CheckINGUID()
    local track = GetTrack(LBX_IN_TRACK)
    if track and reaper.GetTrackGUID(track) == LBX_IN_TRACK_GUID then
      CTINFOLMISSING = nil
      return true, track
    else
      LBX_IN_TRACK = nil
      --local track = GetINTrack()
      local _, track = GetFOLTrack()
      if track then
        lvar.trackinfo = track
      end
      lvar.getfound = true
      if track.input then CTINFOLMISSING = nil else CTINFOLMISSING = true end
      return false, track
    end 
  end
  
  local function CheckINPUTGUID()
    for i = 1, #LBX_INPUT_TRACKS do
      local track = GetTrack(LBX_INPUT_TRACKS[i])
      if track and reaper.GetTrackGUID(track) == LBX_INPUT_TRACK_GUID[i] then
        CTINMISSING = nil
      else
        LBX_INPUT_TRACKS = nil
        --local track = GetInputTracks()
        local _, track = GetFOLTrack()
        if track then
          lvar.trackinfo = track
        end
        lvar.getfound = true
        if track.skin then CTINMISSING = nil else CTINMISSING = true end
      end 
    end
  end

  local function CheckOUTGUID()
    for i = 1, #LBX_OUT_TRACKS do
      local track = GetTrack(LBX_OUT_TRACKS[i])
      if track and reaper.GetTrackGUID(track) == LBX_OUT_TRACK_GUID[i] then
        CTOUTMISSING = nil
      else
        LBX_OUT_TRACKS = nil
        --local track = GetOUTTracks()
        local _, track = GetFOLTrack()
        if track then
          lvar.trackinfo = track
        end
        lvar.getfound = true
        if track.out then CTOUTMISSING = nil else CTOUTMISSING = true end
      end 
    end
  end

  local function CheckFOLGUID()

    local track = GetTrack(LBX_FOL_TRACK)
    if track and reaper.GetTrackGUID(track) == LBX_FOL_TRACK_GUID then
      CTFOLMISSING = nil
      return true, track
    else
      LBX_FOL_TRACK = nil
      local ftrack, track = GetFOLTrack()
      if track then
        lvar.trackinfo = track
      end
      lvar.getfound = true
      if ftrack then 
        CTFOLMISSING = nil 
        if lvar.trackoffset_visibleonly > 0 then
          --Need to rescan visible tracks for mixer offsets
          lvar.tracks_vis = Internal_VisibleTracks()
        end
      else 
        CTFOLMISSING = true 
      end
      return false, track
    end 
  end
  
  local function CheckINPUTCCGUID()
    for i = 1, #LBX_INPUTCC_TRACKS do
      local track = GetTrack(LBX_INPUTCC_TRACKS[i])
      if track and reaper.GetTrackGUID(track) == LBX_INPUTCC_TRACK_GUID[i] then
        CTINCCMISSING = nil
      else
        LBX_INPUTCC_TRACKS = nil
        local _, track = GetInputCCTracks()
        lvar.getfound = true
        if track.skincc then CTINCCMISSING = nil else CTINCCMISSING = true end
      end 
    end
  end

  --[[function CheckTOUCHGUID()
    local track = GetTrack(LBX_TOUCH_TRACK)
    if track and reaper.GetTrackGUID(track) == LBX_TOUCH_TRACK_GUID then
      CTTOUCHMISSING = nil
      return true, track
    else    
      LBX_TOUCH_TRACK = nil
      local track = GetTOUCHTrack()
      lvar.getfound = true
      if track then CTTOUCHMISSING = nil else CTTOUCHMISSING = true end
      return false, track
    end 
  end]]
  
  local function BState_DelReset(i)
    lvar.bstate_resettimer = reaper.time_precise()+0.2
    lvar.bstate_delreset[#lvar.bstate_delreset+1] = i
  end
  
  local function ResetBState()
    local tmp
    for i = 1, #lvar.bstate_delreset do
      tmp = GetTemplate(lvar.bstate_delreset[i])
      --[[if permatemplate.pos[lvar.bstate_delreset[i] ] then
        tmp = permatemplate   
      elseif globtemplate.pos[lvar.bstate_delreset[i] ] and lvar.showglobalmap == true then
        tmp = globtemplate
      else
        tmp = template
      end]]
      if tmp.pos[lvar.bstate_delreset[i]] then
        tmp.pos[lvar.bstate_delreset[i]].bstate = (tmp.pos[lvar.bstate_delreset[i]].ledon or 0)
        reaper.gmem_write(lvar.gm_fb.bstate+(lvar.bstate_delreset[i]-1), tmp.pos[lvar.bstate_delreset[i]].bstate)
        tmp.pos[lvar.bstate_delreset[i]].oldval = nil
      end
    end
    lvar.bstate_delreset = {}
  end

  function ResetGrpBState()

    local g = lvar.ctlgroup_select
    local gidx = lvar.groupidx[g]
    if lvar.groupctlidx[gidx] then
      local gmem = reaper.gmem_write
      for a, b in pairs(lvar.groupctlidx[gidx]) do
        local i = b
        gmem(lvar.gm_fb.bstate+(i-1), 0)
      end
    end
    
  end
  
  function PrevGrid(rpt)
    --Thanks to Amalgalma
    reaper.Main_OnCommand(40755, 0) -- Snapping: Save snap state
    reaper.Main_OnCommand(40754, 0) -- Snapping: Enable snap
    for i = 1, (rpt or 1) do
      local cursorpos = reaper.GetCursorPosition()
      if cursorpos > 0 then
        local grid = cursorpos
        while (grid >= cursorpos) do
            cursorpos = cursorpos - 0.05
            if cursorpos >= 0.05 then
              grid = reaper.SnapToGrid(0, cursorpos)
            else
              grid = 0
            end
        end
        reaper.SetEditCurPos(grid,1,1)
      end  
    end
    reaper.Main_OnCommand(40756, 0) -- Snapping: Restore snap state
  end
  
  function NextGrid(rpt)
    --Thanks to Amalgalma
    reaper.Main_OnCommand(40755, 0) -- Snapping: Save snap state
    reaper.Main_OnCommand(40754, 0) -- Snapping: Enable snap
    for i = 1, (rpt or 1) do
      local cursorpos = reaper.GetCursorPosition()
      local grid = cursorpos
      while (grid <= cursorpos) do
          cursorpos = cursorpos + 0.05
          grid = reaper.SnapToGrid(0, cursorpos)
      end
      reaper.SetEditCurPos(grid,1,1)
    end
    reaper.Main_OnCommand(40756, 0) -- Snapping: Restore snap state
  end
  
  function SetScrubNudge(tmp, i)
    lvar.scrubactive = i
    --DBG(tmp.internal_val2)
    lvar.scrubflag = tab_scrubnudge[tmp.internal_val2].val
    --DBG(lvar.scrubflag)
    if tmp.internal_val2 == 3 then
      --minutes
      lvar.scrubtime = tmp.internal_val * 60
    elseif tmp.internal_val2 == 5 then
      --bars
      local tm = reaper.GetCursorPosition()
      local timesig_num, timesig_denom, tempo = reaper.TimeMap_GetTimeSigAtTime(0, tm)
      lvar.scrubtime = (timesig_num)*tmp.internal_val
    else
      lvar.scrubtime = tmp.internal_val
    end
  end
  
  function GetNextVisibleTrack(trn)
    local param = 'B_SHOWINTCP'
    if lvar.trackoffset_visibleonly == 2 then
      param = 'B_SHOWINMIXER'
    end
    
    local tc = reaper.CountTracks(0)
    for t = trn, tc do
      local track = GetTrack(t)
      if track then
        local vis = reaper.GetMediaTrackInfo_Value(track, param)
        if vis == 1 then
          trn = t
          break
        end
      end
    end
    return trn
  end

  function GetPrevVisibleTrack(trn)
    local param = 'B_SHOWINTCP'
    if lvar.trackoffset_visibleonly == 2 then
      param = 'B_SHOWINMIXER'
    end

    local tc = reaper.CountTracks(0)
    for t = trn, 0, -1 do
      local track = GetTrack(t)
      if track then
        local vis = reaper.GetMediaTrackInfo_Value(track, param)
        if vis == 1 then
          trn = t
          break
        end
      end
    end
    return trn
  end

  function GetNextVisibleTrack2(trn, jumpcnt)
    local param = 'B_SHOWINTCP'
    if lvar.trackoffset_visibleonly == 2 then
      param = 'B_SHOWINMIXER'
    end

    local tc = reaper.CountTracks(0)
    local cnt = 0
    for t = trn+1, tc do
      local track = GetTrack(t)
      if track then
        local vis = reaper.GetMediaTrackInfo_Value(track, param)
        if vis == 1 then
          cnt = cnt + 1
        end
        if cnt == jumpcnt then
          trn = t
          break
        end
      end
    end
    return trn
  end
  
  function GetPrevVisibleTrack2(trn, jumpcnt)
    local param = 'B_SHOWINTCP'
    if lvar.trackoffset_visibleonly == 2 then
      param = 'B_SHOWINMIXER'
    end

    local tc = reaper.CountTracks(0)
    local cnt = 0
    for t = trn-1, 0, -1 do
      local track = GetTrack(t)
      if track then
        local vis = reaper.GetMediaTrackInfo_Value(track, param)
        if vis == 1 then
          cnt = cnt - 1
        end
        if cnt == jumpcnt then
          trn = t
          break
        elseif t == 0 then
          trn = 0
        end
      end
    end
    return trn
  end
  
  local function ProcessInternal(tmp, i, rel)

    --local m_ctrl = reaper.JS_Mouse_GetState(4)&4
    local m_shift = reaper.JS_Mouse_GetState(8)&8==8
    --local m_alt = reaper.JS_Mouse_GetState(16)&16
    --DBG(m_shift)
    --DBG(i)
    if tmp.code == 1 then --internal track pos
      lvar.readparams = nil
      if lvar.trackoffset_visibleonly == 0 then
        lvar.track_internal = lvar.track_internal + tmp.codeval
        if lvar.track_internal < 0 then
          lvar.track_internal = 0
        elseif lvar.track_internal + lvar.ctltracks.count --[[lvar.track_internal_min]] > reaper.CountTracks(0) then
          lvar.track_internal = lvar.track_internal - tmp.codeval
        end
      elseif lvar.trackoffset_visibleonly > 0 then
        if tmp.codeval > 0 then
          lvar.track_internal = GetNextVisibleTrack2(lvar.track_internal, tmp.codeval) --or lvar.track_internal
        else
          lvar.track_internal = GetPrevVisibleTrack2(lvar.track_internal, tmp.codeval) --or lvar.track_internal
        end
        lvar.tracks_vis = Internal_VisibleTracks()
      end
      
      tmp.bstate = 1
      reaper.gmem_write(lvar.gm_fb.bstate+(i-1), 1)
      
      updatetravellingtracknames()
      
    elseif tmp.code == 2 then --global template
      if tmp.codeval == 1 then --enable/disable
        lvar.showglobalmap = not lvar.showglobalmap
        TemplateChanged()
        BState_DelReset(i)
        lupd.update_gfx = true
        
      elseif tmp.codeval == 2 then --previous
        lvar.readparams = nil
        local p = lvar.currentglobalmap - 1
        if p < 1 then p = 16 end
        local fn
        if p == 1 then
          fn = paths.globtemplate_path..LBX_DEFGLOBALTMP
        else  
          fn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',p) ..'.smtemp'
        end
        LoadGlobalMap(fn, p)
        TemplateChanged()
        updatetravellingtracknames()
        lupd.update_gfx = true
        
      elseif tmp.codeval == 3 then --next
        lvar.readparams = nil
        local p = lvar.currentglobalmap + 1
        if p > 16 then p = 1 end
        local fn
        if p == 1 then
          fn = paths.globtemplate_path..LBX_DEFGLOBALTMP
        else  
          fn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',p) ..'.smtemp'
        end
        LoadGlobalMap(fn, p)
        TemplateChanged()
        updatetravellingtracknames()
        lupd.update_gfx = true
        
      else
        lvar.readparams = nil
        local p = tmp.codeval - 3
        if lvar.currentglobalmap ~= p then
          local fn
          if p == 1 then
            fn = paths.globtemplate_path..LBX_DEFGLOBALTMP
          else  
            fn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',p) ..'.smtemp'
          end
          LoadGlobalMap(fn, p) 
          lvar.showglobalmap = true
          
          
        elseif lvar.showglobalmap then
          lvar.showglobalmap = false
        else
          lvar.showglobalmap = true
          if lvar.globmapdata[p] and lvar.globmapdata[p].setmode and lvar.globmapdata[p].setmode ~= -1 then
            SetMode(lvar.globmapdata[p].setmode)
          end
        end
        TemplateChanged()
        updatetravellingtracknames()
        BState_DelReset(i)
        lupd.update_gfx = true        
      end
      
    elseif tmp.code == 3 then --common funcs
      if tmp.codeval == 1 then --flip
        FlipParams()
        BState_DelReset(i)
        --tmp.oldval = nil
        
      elseif tmp.codeval == 2 then --track mode
  
        SetMode(3)
      
      elseif tmp.codeval == 3 then --instance mode
  
        SetMode(2)
  
      elseif tmp.codeval == 4 then --plugin mode
  
        SetMode(1)
      
      elseif tmp.codeval == 5 then --time/beats
        lvar.timecodedisplayformat = 1-lvar.timecodedisplayformat
        
      elseif tmp.codeval == 6 then --ccstamp
        if lvar.ccstamp_active == 1 then
          if mouse.shift then
            GUI_FlashButton(obj, gui, 20, 'PRINT CCs', 0.1, ptype_info[2].col, -4)
          else
            GUI_FlashButton(obj, gui, 20, 'PRINT CCs', 0.1, '205 205 205', -4)
          end
          StampSelectedItems()
        end

      elseif tmp.codeval == 7 then --btngrp on/off
        if #lvar.groupidx > 0 then
          HLGroupButtons()
          if lvar.ctlgroup_select == 0 then
            lvar.ctlgroup_select = lvar.octlgroup_select or 1
            HLGroupButtons(true)
          else
            lvar.octlgroup_select = lvar.ctlgroup_select
            lvar.ctlgroup_select = 0
          end
          SendScribbleData()
          lupd.update_gfx = true
        end
        
      elseif tmp.codeval == 8 then --prev btngrp
        if #lvar.groupidx > 0 then
          HLGroupButtons()
          lvar.ctlgroup_select = lvar.ctlgroup_select - 1
          if lvar.ctlgroup_select < 1 then
            lvar.ctlgroup_select = lvar.groupcnt
          end
          HLGroupButtons(true)
          SendScribbleData()
          lupd.update_gfx = true
        end
        
      elseif tmp.codeval == 9 then --next btngrp 
        if #lvar.groupidx > 0 then
          HLGroupButtons()
          lvar.ctlgroup_select = lvar.ctlgroup_select + 1
          if lvar.ctlgroup_select > lvar.groupcnt then
            lvar.ctlgroup_select = 1
          end
          HLGroupButtons(true)
          SendScribbleData()
          lupd.update_gfx = true
        end      

      elseif tmp.codeval == 10 then --retransmit values
        
        TemplateChanged()
        SendScribbleData()
        lupd.update_gfx = true

      elseif tmp.codeval == 12 then --remap controls toggle
        if lvar.remap.data then
          lvar.remap_active = not lvar.remap_active
          RemapCtls(lvar.remap_active)
        else
          lvar.remap_active = false
        end

      elseif tmp.codeval == 13 then --automap
        if recmode ~= 1 then
          lvar.rec_mapactiveenvstofaders2 = not lvar.rec_mapactiveenvstofaders2
          lupd.update_header = true
        end

      elseif tmp.codeval == 14 then --automap bank l
        lvar.rec_automap_bankoffset = math.max(0, lvar.rec_automap_bankoffset-8)
        --DBG(lvar.rec_automap_bankoffset)
        if lvar.rec_mapactiveenvstofaders then
          REC_MapEnvsToFaders()
          REC_EnvelopeData_Gather()
          lupd.update_gfx = true
        end
        
      elseif tmp.codeval == 15 then --automap bank r
        
        lvar.rec_automap_bankoffset = math.max(0,math.min(math.floor((lvar.rec_automap_envcnt-1)/8)*8, lvar.rec_automap_bankoffset+8))
        --DBG(lvar.rec_automap_bankoffset..'  '..math.floor((lvar.rec_automap_envcnt-1)/8)*8)
        if lvar.rec_mapactiveenvstofaders then
          REC_MapEnvsToFaders()
          REC_EnvelopeData_Gather()
          lupd.update_gfx = true
        end

      elseif tmp.codeval == 16 then --automap flip
        
        lvar.rec_automap_flip = not lvar.rec_automap_flip
        if lvar.rec_mapactiveenvstofaders then
          REC_MapEnvsToFaders()
          REC_EnvelopeData_Gather()
          lupd.update_gfx = true
        end
      
      elseif tmp.codeval == 17 then --Learn FX
        
        lrnmode = not lrnmode
        lupd.update_gfx = true
      
      elseif tmp.codeval == 18 then --REC
        
        if FFX and recmode == 0 then
          recmode = 1
          SetRecMode(recmode)
          lupd.update_gfx = true
        
        elseif FFX and recmode == 1 then
          recmode = -1
          SetRecMode(recmode)
          lupd.update_gfx = true
        
        end
        
      elseif tmp.codeval == 19 then --FB
        ToggleFBMode()
        
      elseif tmp.codeval == 20 then --SS Vals
        lvar.ss_alwaysshowdispval = not lvar.ss_alwaysshowdispval
        --lvar.forceSSupdate = true
        SendScribbleData()

      elseif tmp.codeval == 21 then --Assign Disp Mode
        ToggleAssDispMode()

      elseif tmp.codeval == 22 then --Track select mode
        if tmp.internal_val == 1 then
          lvar.trackselectmode = true
        else
          lvar.trackselectmode = false
        end
      end
      
      tmp.bstate = 1
      
    elseif tmp.code == 4 then --filter selection
      if tmp.codeval == 1 then 
        tmp.bstate = 1
        local cnt = 0        
        lvar.userfilter.select = (lvar.userfilter.select or 2) - 1
        while not lvar.userfilter[lvar.userfilter.select] do
          cnt = cnt + 1
          lvar.userfilter.select = lvar.userfilter.select - 1
          if lvar.userfilter.select < 1 then
            lvar.userfilter.select = 8
          end
          if lvar.userfilter[lvar.userfilter.select] or cnt == 8 then
            break
          end
        end
        if lvar.userfilter[lvar.userfilter.select] then
          lvar.lstfilt = table.copy(lvar.userfilter[lvar.userfilter.select].filter)
          lvar.lstfiltsel = {}
          for i = 1, #lvar.lstfilt do
            lvar.lstfiltsel[lvar.lstfilt[i]] = true
          end
          UpdateFilter()
        else
          lvar.userfilter.select = nil
        end
        lupd.update_gfx = true

      elseif tmp.codeval == 2 then
        tmp.bstate = 1
        local cnt = 0        
        lvar.userfilter.select = (lvar.userfilter.select or 0) + 1
        while not lvar.userfilter[lvar.userfilter.select] do
          cnt = cnt + 1
          lvar.userfilter.select = lvar.userfilter.select + 1
          if lvar.userfilter.select > 8 then
            lvar.userfilter.select = 1
          end
          if lvar.userfilter[lvar.userfilter.select] or cnt == 8 then
            break
          end
        end
        if lvar.userfilter[lvar.userfilter.select] then
          lvar.lstfilt = table.copy(lvar.userfilter[lvar.userfilter.select].filter)
          lvar.lstfiltsel = {}
          for i = 1, #lvar.lstfilt do
            lvar.lstfiltsel[lvar.lstfilt[i]] = true
          end
          UpdateFilter()
        else
          lvar.userfilter.select = nil
        end
        lupd.update_gfx = true
      
      elseif tmp.codeval == 3 then
        tmp.bstate = 1
        if lvar.filtidx then
          lvar.filtidx = nil
          lvar.filtidx2 = nil
          lvar.fcountfilt = nil
        else
          UpdateFilter()
        end
        lupd.update_gfx = true

      elseif tmp.codeval >= 4 then
        tmp.bstate = 1 
        local p = tmp.codeval -3
        if (lvar.userfilter.select ~= p or not lvar.filtidx) and lvar.userfilter[p] then
          lvar.lstfilt = table.copy(lvar.userfilter[p].filter)
          lvar.lstfiltsel = {}
          for i = 1, #lvar.lstfilt do
            lvar.lstfiltsel[lvar.lstfilt[i]] = true
          end
          lvar.userfilter.select = p
          UpdateFilter()
          lupd.update_gfx = true
        else
          lvar.filtidx = nil
          lvar.filtidx2 = nil
          lvar.fcountfilt = nil
          lupd.update_gfx = true
        end
        --[[if lvar.userfilter[p] then
          lvar.lstfilt = table.copy(lvar.userfilter[p].filter)
          lvar.lstfiltsel = {}
          for i = 1, #lvar.lstfilt do
            lvar.lstfiltsel[lvar.lstfilt[i] ] = true
          end
          lvar.userfilter.select = p
          UpdateFilter()
          lupd.update_gfx = true
        end]]
      
      end
      
    elseif tmp.code == 5 then --scrub/jog

      if tmp.codeval == 1 then --scrub
      
        --only works with relative mode
        if rel then
          
          if lvar.scrubflag == -1 then
            local amt = lvar.scrubtime * rel
            reaper.CSurf_ScrubAmt(amt)          
          else
            local amt = lvar.scrubtime * rel
            local dir = false
            if amt < 0 then
              dir = true
            end
            if lvar.scrubflag > 0 then
              reaper.ApplyNudge(0,0,6,lvar.scrubflag,math.abs(amt),dir,0)
            elseif lvar.scrubflag == -2 then
              --markers
              if dir == false then
                --next
                reaper.Main_OnCommand(40173,1)
              else
                reaper.Main_OnCommand(40172,1)              
              end
            elseif lvar.scrubflag == -3 then
              --items
              if dir == false then
                --next
                reaper.Main_OnCommand(40417,1)
              else
                reaper.Main_OnCommand(40416,1)              
              end

            elseif lvar.scrubflag == -4 then
              if dir == false then
                NextGrid()
              else
                PrevGrid()
              end
            end
          end
        end

      elseif tmp.codeval == 6 then --scrub/nudge time
      
        SetScrubNudge(tmp, i)
        --[[lvar.scrubactive = i
        lvar.scrubflag = tab_scrubnudge[tmp.internal_val2].val
        --DBG(lvar.scrubflag)
        if tmp.internal_val2 == 3 then
          --minutes
          lvar.scrubtime = tmp.internal_val * 60
        elseif tmp.internal_val2 == 5 then
          --bars
          local tm = reaper.GetCursorPosition()
          local timesig_num, timesig_denom, tempo = reaper.TimeMap_GetTimeSigAtTime(0, tm)
          lvar.scrubtime = (timesig_num)*tmp.internal_val
        else
          lvar.scrubtime = tmp.internal_val
        end]]
        
      elseif tmp.codeval >= 2 then --scrub time
      
        lvar.scrubactive = -1
        lvar.scrubflag = lvar.scrubtable[tmp.codeval-1]
        lvar.scrubtime = tmp.internal_val
      
      end
      
    elseif tmp.code == 6 then --Midi Ed Lanes
    
      if tmp.codeval <= 4 then --fixed slot toggle
        local track, trnm = GetCCLanesTrack()
        if track and lvar.lanes_xtra[trnm] then
          local slot = tmp.codeval
          
          if lvar.lanes_xtra[trnm][slot] and lvar.lanes_xtra[trnm][slot].tabidx then
            lvar.lanes_xtra[trnm][slot].show = not lvar.lanes_xtra[trnm][slot].show
            if lvar.midieditor_cclanes == true then
              lvar.update_midieditor_cclanes = true
            end
          else
            tmp.bstate = 1
          end
        end

      elseif tmp.codeval >= 11 and tmp.codeval <= 18 then --zoom/solo assign cc lane
        local ccass = tmp.codeval - 10

        if (lvar.midieditor_cclanes_solo_assign and lvar.midieditor_cclanes_solo_assign ~= ccass)
           or lvar.midieditor_cclanes_solovel
           or (lvar.midieditor_cclanes_solo and not lvar.midieditor_cclanes_solo_assign) then
        else
          lvar.midieditor_cclanes_solo = not lvar.midieditor_cclanes_solo
        end
        
        lvar.midieditor_cclanes_solovel = false

        if lvar.midieditor_cclanes_solo then
          local i = lvar.idx_cc[ccass]
          if i then
            lvar.midieditor_cclanes_solo_assign = ccass
          else
            lvar.midieditor_cclanes_solo_assign = nil
            lvar.midieditor_cclanes_solo = false
          end
        else
          lvar.midieditor_cclanes_solo_assign = nil
        end
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
        tmp.bstate = 1
        --reaper.gmem_write(lvar.gm_fb.bstate+(i-1), 1)
        
      elseif tmp.codeval >= 19 and tmp.codeval <= 22 then --zoom/solo active lane
        local ccass = tmp.codeval - 18

        if lvar.midieditor_cclanes_solo and (lvar.midieditor_cclanes_sololane ~= ccass 
                                             or lvar.midieditor_cclanes_solovel 
                                             or lvar.midieditor_cclanes_solo_assign) then
        else
          lvar.midieditor_cclanes_solo = not lvar.midieditor_cclanes_solo
        end

        lvar.midieditor_cclanes_solo_assign = nil
        lvar.midieditor_cclanes_solovel = false        
        
        if lvar.midieditor_cclanes_solo then
          lvar.midieditor_cclanes_sololane = ccass
        end
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
        tmp.bstate = 1
        
      elseif tmp.codeval == 23 then --zoom/solo velocity lane
  
        lvar.midieditor_cclanes_solo_assign = nil
        lvar.midieditor_cclanes_solovel = not lvar.midieditor_cclanes_solovel
        if lvar.midieditor_cclanes_solovel then
          lvar.midieditor_cclanes_solo = true
        else
          lvar.midieditor_cclanes_solo = false
        end
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
        tmp.bstate = 1
        
      elseif tmp.codeval == 7 then --velocity lane
        lvar.lanes_xtra.velshow = not (lvar.lanes_xtra.velshow)
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
        --tmp.bstate = 1
        
      elseif tmp.codeval == 8 then --show all fixed
        lvar.midieditor_cclanes_showallfixed = not lvar.midieditor_cclanes_showallfixed
        if lvar.midieditor_cclanes_showallfixed then
          lvar.lanes_xtra.velshow = false
        end
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
        
      elseif tmp.codeval == 9 then --hide all auto
        lvar.midieditor_cclanes_hideallauto = not lvar.midieditor_cclanes_hideallauto
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end

      elseif tmp.codeval == 10 then --solo
        lvar.midieditor_cclanes_solo = not lvar.midieditor_cclanes_solo
        lvar.midieditor_cclanes_solo_assign = nil
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
        
      elseif tmp.codeval == 5 then --increment offset/solod
      
        if lvar.midieditor_cclanes_solo then
          lvar.midieditor_cclanes_sololane = lvar.midieditor_cclanes_sololane + 1
          if lvar.midieditor_cclanes == true then
            lvar.update_midieditor_cclanes = true
          end          
        else
          if lvar.midieditor_cclanes_wrap then
            
            local track, trnm = GetCCLanesTrack()
            if track then
              
              if lvar.lanes_ov_tab[trnm] and lvar.lanes_ov_enable then
                local flag = false 
                if lvar.midieditor_cclanes_offset < #lvar.idx_cc - lvar.midieditor_cclanes_max then
                  flag = true
                end
                if lvar.midieditor_cclanes_offset == -1 then
                  lvar.midieditor_cclanes_offset = 0
                else
                  lvar.midieditor_cclanes_offset = math.min(lvar.midieditor_cclanes_offset + lvar.midieditor_cclanes_max,#lvar.idx_cc)
                end
                if lvar.midieditor_cclanes_offset >= #lvar.idx_cc and flag == false then
                  lvar.midieditor_cclanes_offset = -1
                end
              else              
                local flag = false 
                if lvar.midieditor_cclanes_offset < #lvar.idx_cc - lvar.midieditor_cclanes_max then
                  flag = true
                end
                lvar.midieditor_cclanes_offset = math.min(lvar.midieditor_cclanes_offset + lvar.midieditor_cclanes_max,#lvar.idx_cc)
                if lvar.midieditor_cclanes_offset >= #lvar.idx_cc and flag == false then
                  lvar.midieditor_cclanes_offset = 0
                end
              end
                          
              if lvar.midieditor_cclanes == true then
                lvar.update_midieditor_cclanes = true
              end
            end
          else
            lvar.midieditor_cclanes_offset = math.min(lvar.midieditor_cclanes_offset + lvar.midieditor_cclanes_max,
                                                      #lvar.idx_cc - lvar.midieditor_cclanes_max)        
            if lvar.midieditor_cclanes == true then
              lvar.update_midieditor_cclanes = true
            end
          end
        end
        tmp.bstate = 1
    
      elseif tmp.codeval == 6 then --decrement offset/solod

        if lvar.midieditor_cclanes_solo then
          lvar.midieditor_cclanes_sololane = lvar.midieditor_cclanes_sololane - 1
          if lvar.midieditor_cclanes == true then
            lvar.update_midieditor_cclanes = true
          end                  
        else
          if lvar.midieditor_cclanes_wrap then

            local track, trnm = GetCCLanesTrack()
            if track then
              
              if lvar.lanes_ov_tab[trnm] and lvar.lanes_ov_enable then
                local flag = false
                if lvar.midieditor_cclanes_offset > 0 then
                  flag = true
                end
                if lvar.midieditor_cclanes_offset == -1 then
                  lvar.midieditor_cclanes_offset = #lvar.idx_cc - (#lvar.idx_cc % lvar.midieditor_cclanes_max)
                else
                  lvar.midieditor_cclanes_offset = math.max(lvar.midieditor_cclanes_offset - lvar.midieditor_cclanes_max, 0)
                end
                if lvar.midieditor_cclanes_offset <= 0 and flag == false then
                  lvar.midieditor_cclanes_offset = -1
                end
                if lvar.midieditor_cclanes == true then
                  lvar.update_midieditor_cclanes = true
                end
                
              else
                local flag = false
                if lvar.midieditor_cclanes_offset > 0 then
                  flag = true
                end
                lvar.midieditor_cclanes_offset = math.max(lvar.midieditor_cclanes_offset - lvar.midieditor_cclanes_max, 0)
                if lvar.midieditor_cclanes_offset <= 0 and flag == false then
                  lvar.midieditor_cclanes_offset = #lvar.idx_cc - (#lvar.idx_cc % lvar.midieditor_cclanes_max)
                end
                if lvar.midieditor_cclanes == true then
                  lvar.update_midieditor_cclanes = true
                end
              end
            end
          else
            if lvar.midieditor_cclanes_offset == #lvar.idx_cc - lvar.midieditor_cclanes_max then
              local shift = #lvar.idx_cc % lvar.midieditor_cclanes_max
              if shift == 0 then
                shift = lvar.midieditor_cclanes_max
              end
              lvar.midieditor_cclanes_offset = math.max(lvar.midieditor_cclanes_offset - shift
                                                        , 0)
            else          
              lvar.midieditor_cclanes_offset = math.max(lvar.midieditor_cclanes_offset - lvar.midieditor_cclanes_max, 0)
            end
            if lvar.midieditor_cclanes == true then
              lvar.update_midieditor_cclanes = true
            end        
          end
        end
        tmp.bstate = 1

      elseif tmp.codeval == 24 then --lane height multiplier
        
        local vv = tmp.butstates_array[tmp.bpos] or 100
        
        lvar.midieditor_cclanes_heightmulti = vv/100
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end                
        tmp.bstate = 1

      elseif tmp.codeval >= 25 and tmp.codeval <= 28 then --lane height multiplier (individual lanes)
        
        local vv = tmp.butstates_array[tmp.bpos] or 100
        local l = tmp.codeval - 24
        
        lvar.midieditor_cclanes_hmulti[l] = vv/100
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end                
        tmp.bstate = 1

      elseif tmp.codeval == 29 then --previous preset
        local track, trnm = GetCCLanesTrack()
        if track and lvar.lanes_presets[trnm] then
          local cp = lvar.lanes_presets[trnm].select
          if not cp then
            cp = 1
          end
          for pp = 1, 8 do
            local p = cp - pp
            if p < 1 then
              p = 8+p
            end
            if lvar.lanes_presets[trnm][p] then
              lvar.lanes_presets[trnm].select = p
              lvar.lanes_ov_tab[trnm] = {all = lvar.lanes_presets[trnm][p]}
              lvar.midieditor_cclanes_offset = -1
              if lvar.midieditor_cclanes == true then
                lvar.update_midieditor_cclanes = true
              end
              lupd.update_gfx = true            
              break
            end
          end
        end
        tmp.bstate = 1
      
      elseif tmp.codeval == 30 then --next preset
        local track, trnm = GetCCLanesTrack()
        if track and lvar.lanes_presets[trnm] then
          local cp = lvar.lanes_presets[trnm].select
          if not cp then
            cp = 0
          end
          for pp = 1, 8 do
            local p = cp + pp
            if p > 8 then
              p = (p % 8)
            end
            if lvar.lanes_presets[trnm][p] then
              lvar.lanes_presets[trnm].select = p
              lvar.lanes_ov_tab[trnm] = {all = lvar.lanes_presets[trnm][p]}
              lvar.midieditor_cclanes_offset = -1
              lvar.lanes_ov_enable = true
              if lvar.midieditor_cclanes == true then
                lvar.update_midieditor_cclanes = true
              end
              lupd.update_gfx = true            
              break
            end
          end        
        end
        tmp.bstate = 1
              
      elseif tmp.codeval >= 31 and tmp.codeval <= 38 then --lane presets
        local track, trnm = GetCCLanesTrack()
        if track then
          local p = tmp.codeval - 30
          if lvar.lanes_presets[trnm] and lvar.lanes_presets[trnm][p] then
            lvar.lanes_presets[trnm].select = p
            lvar.lanes_ov_tab[trnm] = {all = lvar.lanes_presets[trnm][p]}
            lvar.midieditor_cclanes_offset = -1
            lvar.lanes_ov_enable = true
            if lvar.midieditor_cclanes == true then
              lvar.update_midieditor_cclanes = true
            end
            lupd.update_gfx = true
          --else
          --  tmp.bstate = 1
          end
        --else
        --  tmp.bstate = 1        
        end
        tmp.bstate = 1

      elseif tmp.codeval == 39 then --auto lanes
        
        lvar.midieditor_cclanes = not lvar.midieditor_cclanes
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
        lupd.update_gfx = true

      elseif tmp.codeval == 40 then --enable/disable preset
        
        lvar.lanes_ov_enable = not lvar.lanes_ov_enable
        if lvar.lanes_ov_enable then
          lvar.midieditor_cclanes_offset = -1
        end
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
        lupd.update_gfx = true
        tmp.bstate = 1        
        
      end
    
    elseif tmp.code == 7 then --Additional Layers

      if tmp.codeval <= 12 then --toggle layers 1-12
        local layer = tmp.codeval
        
        if tmp.buttype == 6 then
          local ol = lvar.overtemplate
          lvar.overtemplate = layer
          if tmp.valind == false then
            lvar.ot_store = {active = lvar.overtemplate_active, layer = ol}
            lvar.overtemplate_active = true
          else
            if lvar.ot_store then
              lvar.overtemplate_active = lvar.ot_store.active
              lvar.overtemplate = lvar.ot_store.layer
              lvar.ot_store = nil
            else
              lvar.overtemplate_active = false
            end
          end
        else
        
          if layer == lvar.overtemplate then
            lvar.overtemplate_active = not lvar.overtemplate_active
          else
            lvar.overtemplate = layer
            lvar.overtemplate_active = true
          end
        end
        tmp.bstate = 1
        TemplateChanged()
        lupd.update_gfx = true          
        
      elseif tmp.codeval == 13 then --toggle layer off
        if lvar.overtemplate_active then 
          lvar.overtemplate_active = false
          TemplateChanged()
          lupd.update_gfx = true
          tmp.bstate = 1
        else
          tmp.bstate = 1
        end

      elseif tmp.codeval == 14 then -- prev layer
        
        if lvar.overtemplate == 1 then 
          if lvar.overtemplate_active == true then
            lvar.overtemplate_active = false
          else
            lvar.overtemplate_active = true          
            lvar.overtemplate = lvar.overtmp_cnt
          end
        else
          if lvar.overtemplate_active == true then          
            lvar.overtemplate = lvar.overtemplate - 1
          else
            lvar.overtemplate_active = true                    
          end
        end
        
        TemplateChanged()
        lupd.update_gfx = true
        tmp.bstate = 1

      elseif tmp.codeval == 15 then -- next layer
        
        if lvar.overtemplate == lvar.overtmp_cnt then 
          if lvar.overtemplate_active == true then
            lvar.overtemplate_active = false                    
          else
            lvar.overtemplate_active = true
            lvar.overtemplate = 1
          end
        else
          if lvar.overtemplate_active == true then
            lvar.overtemplate = lvar.overtemplate + 1
          else
            lvar.overtemplate_active = true                    
          end
        end
        
        TemplateChanged()
        lupd.update_gfx = true
        tmp.bstate = 1

      elseif tmp.codeval >= 16 and tmp.codeval <= 27 then --latch toggle layers 1-12

        local layer = tmp.codeval-15
        if layer == lvar.overtemplate and lvar.overtemplate_active and lvar.overtemp_latchreturn then

          if lvar.overtemp_latchreturn then
            lvar.overtemplate = lvar.overtemp_latchreturn
            lvar.overtemplate_active = lvar.overtemp_latchreturn_active
          end
          lvar.overtemp_latchreturn = nil
          lvar.overtemp_latchreturn_active = nil
        
        else

          lvar.overtemp_latchreturn = lvar.overtemp_latchreturn or lvar.overtemplate
          if lvar.overtemp_latchreturn_active == nil then
            lvar.overtemp_latchreturn_active = lvar.overtemplate_active
          end
          lvar.overtemplate_active = true
          lvar.overtemplate = layer
          
          lvar.latchreturn_set = true
          lvar.latchreturn_timer = reaper.time_precise()+0.5
        end

        --[[if layer == lvar.overtemplate then
          lvar.overtemplate = lvar.overtemp_latchreturn or 0
          lvar.overtemp_latchreturn = nil
        else
          lvar.overtemp_latchreturn = lvar.overtemplate
          lvar.overtemplate = layer
          
          lvar.latchreturn_set = true
          lvar.latchreturn_timer = reaper.time_precise()+0.2
        end]]
        TemplateChanged()
        lupd.update_gfx = true          

      end
    
    elseif tmp.code == 8 then --Automation Items
      
      if tmp.codeval == 1 then --
        InsertAI(rel or 1)
        tmp.bstate = 1
                
      elseif tmp.codeval == 2 then --
        InsertAI(rel or -1)
        tmp.bstate = 1

      elseif tmp.codeval >= 3 and tmp.codeval <= 5 then --
        
        local val = tmp.internal_val
        local cd = tmp.codeval
        val = F_limit((val/16383) * tab_aicodes[cd].mult-tab_aicodes[cd].add,tab_aicodes[cd].min,tab_aicodes[cd].max)
        SetAIProperty(tab_aicodes[cd].code,val)

      elseif tmp.codeval == 6 then -- Rescan
        ScanAITrack(true)
        tmp.bstate = 1        
      end
      
    elseif tmp.code == 9 then --Takeover
    
      if tmp.codeval <= 4 then 
      
        local v = tmp.codeval
        if lvar.takeover.active == -1 then
        
          lvar.takeover.active = v
          tmp.bstate = 1
          
        else
        
          if lvar.takeover.active == v then
            
            lvar.takeover.active = -1
            tmp.bstate = 1
                    
          else

            lvar.takeover.active = v
            tmp.bstate = 1
            
          end
        
        end
        InsertTakeoverAssignments()
        TemplateChanged()
        tmp.flashss = true
        lupd.update_gfx = true
        --tmp.bstate = 1
        
      end
      
    elseif tmp.code == 10 then --REC Automode

      reaper.Undo_BeginBlock()
      LBX_CTL_TRACK_AM = tmp.codeval-1
      if LBX_CTL_TRACK_AM < 2 then
        recmode = -2
        SetRecMode(recmode)
        reaper.Undo_EndBlock("LBX REC mode disabled", 0)
        
      elseif FFX then
        reaper.PreventUIRefresh(1)
        if recmode == 1 then
          SetRecMode(-2)
        end
        recmode = 1
        SetRecMode(recmode)
        reaper.PreventUIRefresh(-1)
        
        reaper.Undo_EndBlock("LBX REC mode enabled", 0)        
      end

      tmp.bstate = -1
      --tmp.flashss = true
      lupd.update_gfx = true
          
    elseif tmp.code == 11 then --Auto envelopes

      if tmp.codeval == 1 then --
        
        if recmode == 0 then
          lvar.autoenv = not lvar.autoenv
          lupd.update_gfx = true
          tmp.bstate = 1
        end
        
      elseif tmp.codeval == 2 then --

        if recmode ~= 0 then
      
          lvar.env_autoshow_bank = lvar.env_autoshow_bank-1
          if lvar.env_autoshow_bank < 0 then
            lvar.env_autoshow_bank = math.floor(#lvar.recenvdata / lvar.env_autoshow_cnt)
          end
          Env_AutoShow()
      
        end
        tmp.bstate = 1
        
      elseif tmp.codeval == 3 then --

        if recmode ~= 0 then
          if (lvar.env_autoshow_bank+1) * lvar.env_autoshow_cnt < #lvar.recenvdata then
            lvar.env_autoshow_bank = lvar.env_autoshow_bank+1
            Env_AutoShow()
          else
            lvar.env_autoshow_bank = 0
            Env_AutoShow()
          end
        end
        tmp.bstate = 1

      elseif tmp.codeval == 4 then --All env height mult

        if recmode ~= 0 then
          local vv = tmp.butstates_array[tmp.bpos] or 100
          lvar.env_zoomh = vv/100
          lvar.update_envelopes = true
          
          lvar.env_spread = 0
          lvar.env_indzoomh = {}
          
        end      
        tmp.bstate = 1

      elseif tmp.codeval >= 5 and tmp.codeval <= 8 then --Env height mult

        if recmode ~= 0 then
          
          local envslot = tmp.codeval-4
          local vv = tmp.butstates_array[tmp.bpos] or 100
          lvar.env_indzoomh[envslot] = vv/100
          
          --lvar.env_zoomh = vv/100
          lvar.update_envelopes = true
          
          lvar.env_spread = 0
        
        end      
        tmp.bstate = 1
        
      elseif tmp.codeval == 9 then --spread 
        
        if recmode ~= 0 then
          lvar.env_spread = 1-lvar.env_spread
          lvar.update_envelopes = true
        end      
        tmp.bstate = 1

      elseif tmp.codeval >= 10 and tmp.codeval <= 17 then --solo env
      
        if recmode ~= 0 then
          local slot = tmp.codeval - 9
          if lvar.autoenv_solo == slot then
            lvar.autoenv_solo = nil
          else
            lvar.autoenv_solo = math.min(slot, #lvar.recenvdata)
            if lvar.autoenv_solo == 0 then 
              lvar.autoenv_solo = nil
            end
          end
          Env_AutoShow()
        end
        tmp.bstate = 1
      
      elseif tmp.codeval == 18 then --prev solo
      
        if recmode ~= 0 then
          if not lvar.autoenv_solo then
            lvar.autoenv_solo = 2
          
          end
          if lvar.autoenv_solo > 1 then
            lvar.autoenv_solo = lvar.autoenv_solo-1
            Env_AutoShow()
          else
            lvar.autoenv_solo = #lvar.recenvdata
            Env_AutoShow()
          end
        end
        tmp.bstate = 1
        
      elseif tmp.codeval == 19 then --next solo
      
        if recmode ~= 0 then
          if not lvar.autoenv_solo then
            lvar.autoenv_solo = 0
          end
          if lvar.autoenv_solo < #lvar.recenvdata then
            lvar.autoenv_solo = lvar.autoenv_solo+1
            Env_AutoShow()
          else
            lvar.autoenv_solo = 1
            Env_AutoShow()
          end
        end
        tmp.bstate = 1
      
      elseif tmp.codeval == 20 then --activate/deactivate solo

        if recmode ~= 0 then
          if not lvar.autoenv_solo then
            lvar.autoenv_solo = lvar.autoenv_solo_last or 1
          else
            lvar.autoenv_solo = nil
          end
          Env_AutoShow()
        end
        tmp.bstate = 1
      
      end
          
    elseif tmp.code == 12 then --Track Tags
    
      if tmp.codeval == 1 then --show tags

        if recmode == 0 then
          ToggleShowTag(not lvar.tags.show)
        end
        tmp.bstate = 1
      
      elseif tmp.codeval >= 2 and tmp.codeval <= 33 then --show tag slot
        
        local slot = tmp.codeval-1
        if recmode == 0 then
          ToggleShowTagSlot(slot)
        end      
        tmp.bstate = 1
      end
    
    elseif tmp.code == 13 then --Retro Rec

      if tmp.codeval == 1 then --Toggle Quantize
        lvar.rrsettings.autoquantize = 1 - lvar.rrsettings.autoquantize
        tmp.bstate = 1
        
      elseif tmp.codeval == 2 then --Strength
        lvar.rrsettings.quantize_strength = F_limit(tmp.internal_val,0,100)
        tmp.bstate = 1

      elseif tmp.codeval == 3 then --Select previous items
      
        RestoreSelectedItems()
      
      elseif tmp.codeval == 4 then --play on fader touch cc
      
        lvar.cc_starttransportonfadertouch = not lvar.cc_starttransportonfadertouch
        tmp.bstate = 1
        
      end
      
    elseif tmp.code == 14 then --Finetune

      if tmp.codeval == 1 then --Toggle Finetune
        
        lvar.finetune_active = not lvar.finetune_active
        TriggerCCChase() --ensure CC values are correct
        SetFineTune()
        TemplateChanged()
        lupd.update_gfx = true
        
        tmp.bstate = 1
        
      elseif tmp.codeval == 2 then --Strength
        lvar.fineamt = F_limit(tmp.internal_val,1,64)*128
        reaper.gmem_write(lvar.fineamt_idx, lvar.fineamt)
        tmp.bstate = 1
      
      end
    
    elseif tmp.code == 15 then --FX selection
    
      if tmp.codeval == 1 then --Toggle fx select mode
      
        lvar.fxsel_mode = 1-lvar.fxsel_mode
        if lvar.fxsel_mode == 1 then
          lvar.fxsel_focusedfx = nil
          local track = reaper.GetSelectedTrack2(0, 0, true)
          if track then
            local trn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
            local fxc = reaper.TrackFX_GetCount(track)
            lvar.fxsel_trn = trn
            lvar.fxsel_cnt = fxc
          end
        end
        lupd.update_gfx = true
        
        tmp.bstate = 1
      
      elseif tmp.codeval >= 2 and tmp.codeval <= 17 then --slot
      
        --[[if not m_shift then
          lvar.fxsel_mode = 1
          lvar.fxsel_focusedfx = nil
        end]]
        lvar.fxsel_focusedfx = nil
        lvar.fxsel_slot = tmp.codeval-2
        --DBG(lvar.fxsel_mode..'  '..lvar.fxsel_slot..'  '..lvar.fxsel_trn..'  '..lvar.fxsel_cnt)
        if (m_shift or lvar.fxsel_mode == 0) and lvar.fxsel_trn then
          local track = GetTrack(lvar.fxsel_trn) --reaper.GetSelectedTrack2(0, 0, true)
          if track then
            local fxc = reaper.TrackFX_GetCount(track)
            if lvar.fxsel_slot <= fxc then
              reaper.TrackFX_Show(track, lvar.fxsel_slot, 2)
              reaper.TrackFX_Show(track, lvar.fxsel_slot, 3)
            end
          end
        end
        lupd.update_gfx = true
        
        tmp.bstate = 1
        --lvar.readparams = nil
      
      elseif tmp.codeval == 20 then --prev

        lvar.fxsel_mode = 1
        lvar.fxsel_focusedfx = nil
        lvar.fxsel_slot = lvar.fxsel_slot - 1
        
        local track = reaper.GetSelectedTrack2(0, 0, true)
        if track then
          local fxc = reaper.TrackFX_GetCount(track)
          if lvar.fxsel_slot < 0 then
            lvar.fxsel_slot = fxc-1
          end
        else
          lvar.fxsel_slot = 0
        end
        lupd.update_gfx = true
        
        tmp.bstate = 1

      elseif tmp.codeval == 21 then --next
      
        lvar.fxsel_mode = 1
        lvar.fxsel_focusedfx = nil
        lvar.fxsel_slot = lvar.fxsel_slot + 1
        
        local track = reaper.GetSelectedTrack2(0, 0, true)
        if track then
          local fxc = reaper.TrackFX_GetCount(track)
          if lvar.fxsel_slot > fxc-1 then
            lvar.fxsel_slot = 0
          end
        else
          lvar.fxsel_slot = 0
        end
        lupd.update_gfx = true
        
        tmp.bstate = 1
      
      elseif tmp.codeval == 22 then --keep plugin type selection

        lvar.fxsel_plugtype = 1-lvar.fxsel_plugtype
        lupd.update_gfx = true
        
        tmp.bstate = 1
        
      end
    
    
    elseif tmp.code == 16 then --Data
    
      if tmp.codeval == 2 then
        
        --save layout
        if recmode == 0 and FFX then
          local tag = ''
          if lvar.mode == 3 and lvar.tags.trackassoc[FFX.trname] then
            tag = lvar.tags.trackassoc[FFX.trname].tag or ''
          end
          if lvar.mode == 3 and tag ~= '' then
            SaveTag()
          else
            SaveFXParamTemplate(FFX, template, nil, nil, false)
            GUI_FlashButton(obj, gui, 5, 'SAVE', 0.1, '205 205 205')
          end
          lvar.save_highlight = false
        end
        lupd.update_gfx = true
        
        tmp.bstate = 1
        
      elseif tmp.codeval == 3 then
        --save global
        if recmode == 0 and FFX then
          GlobalSave()
        end
        
      end
      
    elseif tmp.code == 17 then --Reaper Funcs
    
      if tmp.codeval == 1 then --Selected Track Height

        local cnt = reaper.CountSelectedTracks2(0, false)
        local h = math.floor((tmp.internal_val/16383)*1024)
        for i = 0, cnt-1 do
        
          local track = reaper.GetSelectedTrack2(0, i, false)
          if track then
            reaper.SetMediaTrackInfo_Value(track, 'I_HEIGHTOVERRIDE', h)
          end
        end
        --reaper.PreventUIRefresh(-1)
        reaper.TrackList_AdjustWindows(0)
        reaper.UpdateArrange()
      
      elseif tmp.codeval == 2 then --Track Envelope Height

        local track = reaper.GetSelectedTrack2(0,0,true)
        if track then
          local ecnt = reaper.CountTrackEnvelopes(track)-1
          local vis
          if ecnt >= 0 then
            for eidx = 0, ecnt do
              local env = reaper.GetTrackEnvelope(track, eidx)
              if env and IsEnvVisible(env) then
                vis = true
                local h = math.floor((tmp.internal_val/16383)*1024)
                SetEnvLaneHeight(env, h)
              end
            end
          end
          if not vis then
            tmp.val = nil
          end
        else
          tmp.val = nil
        end
        lvar.envvistimer1 = nil
        
      elseif tmp.codeval == 3 then --Selected Envelope Height
        local track = reaper.GetSelectedTrack2(0, 0, true)
        if track then
          local env = reaper.GetSelectedEnvelope(0) --or reaper.GetTrackEnvelope(track, 0)
          if env and IsEnvVisible(env) then
            local h = math.floor((tmp.internal_val/16383)*1024)
            SetEnvLaneHeight(env, h)
          else
            tmp.val = nil
          end
        else
          tmp.val = nil
        end
        lvar.envvistimer1 = nil
      end
    
    elseif tmp.code == 18 then --Quick FX Assign
    
      if tmp.codeval <= lvar.qfx_faders then --Fader
        local idx = tmp.codeval
        lvar.qfx_lasttouched = idx
        tmp.val = tmp.internal_val
        
        local qfx = lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx]
        if qfx then
          local val = tmp.internal_val
          local track2, trnum, fxnum2 = QFX_FindFX(qfx)
          if track2 and qfx.enabled == 1 then
            local pnum = qfx.pnum
          
            local ffxtake2
            local SetParamNormalized, pointer
            if not ffxtake2 then
              SetParamNormalized = reaper.TrackFX_SetParamNormalized
              pointer = track2
            else
              SetParamNormalized = reaper.TakeFX_SetParamNormalized
              pointer = ffxtake2
            end
          
            if lmode ~= 4 then
              if tmp.polarity ~= 1 then
                tmp.val = val
                --reaper.TrackFX_SetParamNormalized(track2, fxnum2, pnum, val/16383)
                --min/max
                local min, max = qfx.min or tmp.min or 0, qfx.max or tmp.max or 1
                local nval = (val/16383)*(max-min)+min
                SetParamNormalized(pointer, fxnum2, pnum, nval)
                --gmem_wr(lvar.gm_fb.fader_val +(i-1),val)
                fbvals[i] = val 
                --tmp.dirty[i] = true
              else
                local val2 = 16383-val
                tmp.val = val
                --reaper.TrackFX_SetParamNormalized(track2, fxnum2, pnum, val2/16383)
                --min/max
                local min, max = qfx.min or tmp.min or 0, qfx.max or tmp.max or 1
                local nval = 1-((val/16383)*(max-min)+min)
                
                SetParamNormalized(pointer, fxnum2, pnum, nval) --val2/16383)            
                fbvals[i] = val 
                --tmp.dirty[i] = true
              end
            else              
              if val/16383 > 0.5 then
                if tmp.buttype ~= 6 then
                  tmp.val = 0
                else
                  tmp.val = val
                end
                local bstate
                if tmp.butstates == 2 then
                  bstate = round(1-(tmp.bstate or 0),0)
                else
                  bstate = (tmp.bstate or 0)+(1/((tmp.butstates or 2)-1))
                  if bstate > 1 then
                    bstate = 0
                  end
                end  
                
                local vv = 0
                if tmp.buttype ~= 6 then
                  tmp.bpos = (tmp.bpos or 0) + 1
                else
                  if tmp.polarity ~= 1 then
                    tmp.bpos = 2 --#tmppos.butstates_array - should it be this?
                  else
                    tmp.bpos = 1
                  end
                end
                if tmp.bpos > #tmp.butstates_array then
                  tmp.bpos = 1
                end
                if (tmp.butstates_array[tmp.bpos] or -1) ~= -1 then
                  vv = tmp.butstates_array[tmp.bpos]
                end
                --reaper.TrackFX_SetParamNormalized(track2, fxnum2, pnum, vv)
                SetParamNormalized(pointer, fxnum2, pnum, vv)
                gmem_wr(lvar.gm_fb.fader_val+(i-1),tmp.val)
              elseif tmp.buttype == 6 then
                tmp.val = val
                local bstate
                if tmp.butstates == 2 then
                  bstate = round(1-(tmp.bstate or 0),0)
                else
                  bstate = (tmp.bstate or 0)+(1/((tmp.butstates or 2)-1))
                  if bstate > 1 then
                    bstate = 0
                  end
                end  
                
                local vv = 0
                if tmp.polarity ~= 1 then
                  tmp.bpos = 1
                else
                  tmp.bpos = 2
                end
                if (tmp.butstates_array[tmp.bpos] or -1) ~= -1 then
                  vv = tmp.butstates_array[tmp.bpos]
                end
                --reaper.TrackFX_SetParamNormalized(track2, fxnum2, pnum, vv)
                SetParamNormalized(pointer, fxnum2, pnum, vv)
                gmem_wr(lvar.gm_fb.fader_val+(i-1),tmp.val)
              end
            end
            
            lupd.update_faderbar = true
            ret = true
          
            if settings.floatfxgui ~= 0 then
              OpenFXGUI(track2, fxnum2)
            end
          end
        end
      elseif tmp.codeval <= 1024+lvar.qfx_faders then --Fader Learn
        local idx = tmp.codeval-1024
        lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx] = QFX_Learn(idx)
        lvar.readparams = nil
        SaveQFX(lvar.qfx_bank*lvar.qfx_faders+idx)
        lupd.update_gfx = true
        tmp.bstate = 1

      elseif tmp.codeval <= 2048+lvar.qfx_faders then --Fader Clear
        local idx = tmp.codeval-2048
        lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx] = nil
        lvar.readparams = nil
        SaveQFX(lvar.qfx_bank*lvar.qfx_faders+idx)
        lupd.update_gfx = true
        tmp.bstate = 1
      
      elseif tmp.codeval >= 3073 and tmp.codeval <= 3072+lvar.qfx_faders then  
      
        local idx = tmp.codeval-3072
        local qfx = lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx]
        if qfx then
          qfx.mode = 1-qfx.mode
          SaveQFX(lvar.qfx_bank*lvar.qfx_faders+idx)
          lupd.update_gfx = true
        end
        tmp.bstate = 1
      
      elseif tmp.codeval == 4097 then --prev bank
      
        lvar.qfx_bank = math.max(0, lvar.qfx_bank-1)
        lvar.readparams = nil
        lupd.update_gfx = true
        
        tmp.bstate = 1

      elseif tmp.codeval == 4098 then --next bank
      
        lvar.qfx_bank = math.min(lvar.qfx_banks-1, lvar.qfx_bank+1)
        lvar.readparams = nil
        lupd.update_gfx = true
        
        tmp.bstate = 1

      elseif tmp.codeval == 4099 then -- Learn
        if lvar.qfx_lasttouched then
          local idx = lvar.qfx_lasttouched
          lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx] = QFX_Learn(idx)
          lvar.readparams = nil
          SaveQFX(lvar.qfx_bank*lvar.qfx_faders+idx)
          lupd.update_gfx = true
          tmp.bstate = 1
        end
        
      elseif tmp.codeval == 4100 then -- Clear
        if lvar.qfx_lasttouched then
          local idx = lvar.qfx_lasttouched
          lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx] = nil
          lvar.readparams = nil
          SaveQFX(lvar.qfx_bank*lvar.qfx_faders+idx)
          lupd.update_gfx = true
          tmp.bstate = 1
        end

      elseif tmp.codeval == 4101 then -- Mode
        if lvar.qfx_lasttouched then
          local idx = lvar.qfx_lasttouched
          local qfx = lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx]
          if qfx then
            qfx.mode = 1-qfx.mode
            SaveQFX(lvar.qfx_bank*lvar.qfx_faders+idx)
            lupd.update_gfx = true
          end
          tmp.bstate = 1
        end

      elseif tmp.codeval == 4102 then -- Color
        if lvar.qfx_lasttouched then
          local idx = lvar.qfx_lasttouched
          local qfx = lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx]
          if qfx then
            local sscolor = (qfx.sscolor or 0) + 1
            if sscolor > #tab_xtouch_colors then
              sscolor = 0
            end
            qfx.sscolor = sscolor
            SaveQFX(lvar.qfx_bank*lvar.qfx_faders+idx)
            lupd.update_gfx = true
          end
          tmp.bstate = 1
        end

      elseif tmp.codeval == 4103 then -- Set min
        if lvar.qfx_lasttouched then
          local idx = lvar.qfx_lasttouched
          local qfx = lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx]
          if qfx then
            local val = tmp.internal_val
            local track2, trnum, fxnum2 = QFX_FindFX(qfx)
            if track2 then
              local pnum = qfx.pnum
            
              local ffxtake2
              local GetParamNormalized, pointer
              if not ffxtake2 then
                GetParamNormalized = reaper.TrackFX_GetParamNormalized
                pointer = track2
              else
                GetParamNormalized = reaper.TakeFX_GetParamNormalized
                pointer = ffxtake2
              end
              
              local val = GetParamNormalized(pointer, fxnum2, pnum)
              if val >= 0 and val <= 1 then
                qfx.min = val
                if (qfx.max or 1) < qfx.min then
                  qfx.max = qfx.min
                end
                SaveQFX(lvar.qfx_bank*lvar.qfx_faders+idx)
                lupd.update_gfx = true
                lvar.readparams = nil
              end
            end
          end
        end
        tmp.bstate = 1

      elseif tmp.codeval == 4104 then -- Set max
        if lvar.qfx_lasttouched then
          local idx = lvar.qfx_lasttouched
          local qfx = lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx]
          if qfx then
            local track2, trnum, fxnum2 = QFX_FindFX(qfx)
            if track2 then
              local pnum = qfx.pnum
            
              local ffxtake2
              local GetParamNormalized, pointer
              if not ffxtake2 then
                GetParamNormalized = reaper.TrackFX_GetParamNormalized
                pointer = track2
              else
                GetParamNormalized = reaper.TakeFX_GetParamNormalized
                pointer = ffxtake2
              end
              
              local val = GetParamNormalized(pointer, fxnum2, pnum)
              if val >= 0 and val <= 1 then
                qfx.max = val
                if (qfx.min or 0) > qfx.max then
                  qfx.min = qfx.max
                end
                SaveQFX(lvar.qfx_bank*lvar.qfx_faders+idx)
                lupd.update_gfx = true
                lvar.readparams = nil
              end
            end
          end
        end
        tmp.bstate = 1
      elseif tmp.codeval == 4105 then -- Reset min/max
        if lvar.qfx_lasttouched then
          local idx = lvar.qfx_lasttouched
          local qfx = lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx]
          if qfx then
            qfx.min = 0
            qfx.max = 1
            SaveQFX(lvar.qfx_bank*lvar.qfx_faders+idx)
            lupd.update_gfx = true
            lvar.readparams = nil
          end
        end
        tmp.bstate = 1
      end
      
    elseif tmp.code == 19 then --Write Faders
    
      local idx = tmp.codeval
      WriteFaderValuesToTracks(idx)      
      tmp.bstate = 1
    
    elseif tmp.code == 20 then --Reset Fader/Encoder
    
      local idx = tmp.codeval
      ResetFaderEncoder(idx)      
      tmp.bstate = 1

    end
    
  end
  
  function ResetFaderEncoder(idx)
  
    local m_shift = reaper.JS_Mouse_GetState(8)&8==8
    local undostr
    if m_shift then
      --encoder
      slot = lvar.encoders[idx]
      undostr = 'encoder '..tostring('%i',idx)
    else
      --fader
      slot = lvar.faders[idx]
      undostr = 'fader '..tostring('%i',idx)
    end
    if slot then
      local tmp = GetTemplatePos(slot, true)
      if tmp then
  
        reaper.Undo_BeginBlock()
        
        if tmp.cc then
          --ResetFader_CC(tmp, val)
        
        elseif tmp.ptype == ptype.host then
          --ResetFader_Host(tmp, slot, val)
        
        elseif tmp.ptype == ptype.track then
          ResetFader_Track(tmp, slot)
        
        elseif tmp.ptype == ptype.internal then
          --[[if tmp.code == 18 and tmp.codeval <= lvar.qfx_faders then
            ResetFader_QFX(tmp, slot, val)
          end]]
        end
        reaper.Undo_EndBlock("Reset "..undostr, -1)
  
      end
    end
  end
  
  function ResetFader_Track(tmp, idx)
    
    local tmppos = tmp
    local trn = tmppos.track
    local ttrn, trackD = Internal_GetTrack(trn, tmppos)
      
    if trackD then
  
      if not lvar.ctltracks[ttrn] then
        if tmppos.trparam ~= -1 then
          local parcode = tab_trparams_code[tmppos.trparam]
          local paramname = tab_trparams[tmppos.trparam]
          if parcode and not track_info[parcode].mononly then
            if paramname == 'Vol' then
              local val = 1
              reaper.CSurf_OnVolumeChange(trackD, 1, false)
            elseif paramname == 'Pan' then
              reaper.CSurf_OnPanChange(trackD, 0, false)
            else
              --reaper.InsertEnvelopePoint(env, curpos, val*1024, 1, 1, false, false)
            end
          end
        end
      end
    end
    
  end
  
  function WriteFaderValuesToTracks(idx, tmp, slot, val)
  
    local faders = lvar.faders
    if not tmp then
      slot = faders[idx]
      tmp = GetTemplatePos(slot, true)
    end
    if tmp then
  
      reaper.Undo_BeginBlock()
      
      if tmp.cc then
        WriteFader_CC(tmp, val)
      
      elseif tmp.ptype == ptype.host then
        WriteFader_Host(tmp, slot, val)
      
      elseif tmp.ptype == ptype.track then
        WriteFader_Track(tmp, slot, val)
      
      elseif tmp.ptype == ptype.internal then
        if tmp.code == 18 and tmp.codeval <= lvar.qfx_faders then
          WriteFader_QFX(tmp, slot, val)
        end
      end
      reaper.Undo_EndBlock("Write Fader Value", -1)

      reaper.TrackList_AdjustWindows(false)
      reaper.UpdateArrange()
    end
    
  end

  function FindItem(track, pos)
    --returns true if item @ pos, else false if item > pos
  
    reaper.PreventUIRefresh(1)
    
    local cnt = reaper.CountTrackMediaItems(track)
    for i = 0, cnt-1 do 
      local item = reaper.GetTrackMediaItem(track, i)
      local take = reaper.GetActiveTake(item)
      if take and reaper.TakeIsMIDI(take) then
        local spos = reaper.GetMediaItemInfo_Value(item, 'D_POSITION') 
        local epos = spos + reaper.GetMediaItemInfo_Value(item, 'D_LENGTH') 
        if pos >= spos and pos < epos then
          return item, take, true
        elseif pos < spos then
          return item, take, false
        end
      end
    end

    reaper.PreventUIRefresh(-1)
    
  end

  function WriteFader_CC(tmp, inval)

    local cc = tmp.ccnum
    local chan = tmp.ccchan
    local cc14bit = tmp.cc14bit

    local val = math.floor(((inval or tmp.val or 0) >> 7))
    --local val = math.floor((((tmp.val or 0) & 16256)/16256) * 127)

    local cnt = reaper.CountSelectedTracks(0)
    for t = 0, cnt-1 do
      local track = reaper.GetSelectedTrack(0, t)
      if track then
        
        local curpos = reaper.GetCursorPosition()
        
        local item, take, loc = FindItem(track, curpos)    
        if take then
          reaper.MarkTrackItemsDirty(track,item)
          
          if loc then
            --Insert into item
            local ppqpos = reaper.MIDI_GetPPQPosFromProjTime(take, curpos)
            reaper.MIDI_InsertCC(take, false, false, ppqpos, 176, chan, cc, val)
            if cc14bit == 1 and cc < 32 then
              local val14 = ((inval or tmp.val or 0)&127)
              reaper.MIDI_InsertCC(take, false, false, ppqpos, 176, chan, cc+32, val14)
            end
          else
            
            --Insert and maybe extend back
            local ppqpos = reaper.MIDI_GetPPQPosFromProjTime(take, curpos)
            local sppq = reaper.MIDI_GetPPQPos_StartOfMeasure(take, ppqpos)
            local eppq = reaper.MIDI_GetPPQPos_EndOfMeasure(take, ppqpos)
            if sppq == 0 or sppq == eppq then -- do not trust it - if cursor on start of measure exactly - returns 0
              sppq = reaper.MIDI_GetPPQPos_StartOfMeasure(take, ppqpos+1)
              eppq = reaper.MIDI_GetPPQPos_EndOfMeasure(take, ppqpos+1)
            end
            local spos = reaper.GetMediaItemInfo_Value(item, 'D_POSITION') 
            local epos = spos + reaper.GetMediaItemInfo_Value(item, 'D_LENGTH')
            
            local eppq_spos = reaper.MIDI_GetProjTimeFromPPQPos(take, eppq) 
            if eppq_spos >= spos then
              --merge
              reaper.MIDI_InsertCC(take, false, false, ppqpos, 176, chan, cc, val)
              if cc14bit == 1 and cc < 32 then
                local val14 = ((inval or tmp.val or 0)&127)
                reaper.MIDI_InsertCC(take, false, false, ppqpos, 176, chan, cc+32, val14)
              end
              
              local sQN = reaper.MIDI_GetProjQNFromPPQPos(take, sppq)
              local eQN = reaper.TimeMap_timeToQN(epos)
              reaper.MIDI_SetItemExtents(item, sQN, eQN)
            else
              --new item
              local sQN = reaper.TimeMap_timeToQN(curpos)
              local eQN = sQN+1
              local item = reaper.CreateNewMIDIItemInProj(track, sQN, eQN, true)
              local take = reaper.GetActiveTake(item)
  
              local ppqpos = reaper.MIDI_GetPPQPosFromProjTime(take, curpos)
              reaper.MIDI_InsertCC(take, false, false, ppqpos, 176, chan, cc, val)
              if cc14bit == 1 and cc < 32 then
                local val14 = ((inval or tmp.val or 0)&127)
                reaper.MIDI_InsertCC(take, false, false, ppqpos, 176, chan, cc+32, val14)
              end
              
              --local spos = reaper.GetMediaItemInfo_Value(item, 'D_POSITION') 
              --local epos = spos + reaper.GetMediaItemInfo_Value(item, 'D_LENGTH') 
              local sppq = reaper.MIDI_GetPPQPos_StartOfMeasure(take, ppqpos)
              local eppq = reaper.MIDI_GetPPQPos_EndOfMeasure(take, ppqpos)
              if sppq == 0 or sppq == eppq then -- do not trust it - if cursor on start of measure exactly - returns 0
                sppq = reaper.MIDI_GetPPQPos_StartOfMeasure(take, ppqpos+1)
                eppq = reaper.MIDI_GetPPQPos_EndOfMeasure(take, ppqpos+1)
              end
              local sQN = reaper.MIDI_GetProjQNFromPPQPos(take, sppq)
              local eQN = reaper.MIDI_GetProjQNFromPPQPos(take, eppq)
              
              reaper.MIDI_SetItemExtents(item, sQN, eQN)
              
            end
            
          end
        else
          --Create measure
          local sQN = reaper.TimeMap_timeToQN(curpos)
          local eQN = sQN+1
          local item = reaper.CreateNewMIDIItemInProj(track, sQN, eQN, true)
          local take = reaper.GetActiveTake(item)

          local ppqpos = reaper.MIDI_GetPPQPosFromProjTime(take, curpos)
          reaper.MIDI_InsertCC(take, false, false, ppqpos, 176, chan, cc, val)
          if cc14bit == 1 and cc < 32 then
            local val14 = ((inval or tmp.val or 0)&127)
            reaper.MIDI_InsertCC(take, false, false, ppqpos, 176, chan, cc+32, val14)
          end
          
          --local spos = reaper.GetMediaItemInfo_Value(item, 'D_POSITION') 
          --local epos = spos + reaper.GetMediaItemInfo_Value(item, 'D_LENGTH') 
          local sppq = reaper.MIDI_GetPPQPos_StartOfMeasure(take, ppqpos)
          local eppq = reaper.MIDI_GetPPQPos_EndOfMeasure(take, ppqpos)
          if sppq == 0 or sppq == eppq then -- do not trust it - if cursor on start of measure exactly - returns 0
            sppq = reaper.MIDI_GetPPQPos_StartOfMeasure(take, ppqpos+1)
            eppq = reaper.MIDI_GetPPQPos_EndOfMeasure(take, ppqpos+1)
          end
          local sQN = reaper.MIDI_GetProjQNFromPPQPos(take, sppq)
          local eQN = reaper.MIDI_GetProjQNFromPPQPos(take, eppq)
          
          reaper.MIDI_SetItemExtents(item, sQN, eQN)
          
          reaper.MarkTrackItemsDirty(track,item)
          
        end
    
      end
    end
  end
  
  function WriteFader_QFX(tmp, idx, inval)
  
    local env = GetFaderEnvelope(idx, true)
    if env then
      VisEnv(env, true, true)
      local curpos = reaper.GetCursorPosition()
      local val = (inval or tmp.val or 0) / 16383
      local pt = reaper.GetEnvelopePointByTimeEx(env, -1, curpos)
      if pt >= 0 then
        --set shape to square
        reaper.SetEnvelopePointEx(env, -1, pt, nil, nil, 1)
      end
      reaper.InsertEnvelopePoint(env, curpos, val, 0, 0, false, false)
    end
    
  end

  function WriteFader_Host(tmp, idx, inval)
  
    local env = GetFaderEnvelope(idx, true)
    if env then
      VisEnv(env, true, true)
      local curpos = reaper.GetCursorPosition()
      local val = (inval or tmp.val or 0) / 16383
      local pt = reaper.GetEnvelopePointByTimeEx(env, -1, curpos)
      if pt >= 0 then
        --set shape to square
        reaper.SetEnvelopePointEx(env, -1, pt, nil, nil, 1)
      end
      reaper.InsertEnvelopePoint(env, curpos, val, 0, 0, false, false)
    end
    
  end
  
  function WriteFader_Track(tmp, idx, inval)
    
    local tmppos = tmp
    local trn = tmppos.track
    local ttrn, trackD = Internal_GetTrack(trn, tmppos)

    local curpos = reaper.GetCursorPosition()
    if inval then
      val = inval*4
    elseif tmp.trparam ~= -1 then
      local parcode = tab_trparams_code[tmppos.trparam]
      val = denormalizetrackparam((tmp.val or 0)/16383, parcode)
    end
    --DBG(tostring(inval) .. ' ' .. tostring(val))
      
    if trackD then

      if not lvar.ctltracks[ttrn] then
        if tmppos.trparam ~= -1 then
          local parcode = tab_trparams_code[tmppos.trparam]
          local envname = tab_trparams_envnames[tmppos.trparam]
          if parcode and not track_info[parcode].mononly then
            
            local env = GetFaderEnvelope(idx, true)
            if env then
              local pt = reaper.GetEnvelopePointByTimeEx(env, -1, curpos)
              if pt >= 0 then
                --set shape to square
                reaper.SetEnvelopePointEx(env, -1, pt, nil, nil, 1)
              end
              
              if envname == 'Volume' then
                local val = reaper.ScaleToEnvelopeMode(reaper.GetEnvelopeScalingMode(env), val)
                reaper.InsertEnvelopePoint(env, curpos, val, 1, 1, false, false)
              elseif envname == 'Pan' then
                reaper.InsertEnvelopePoint(env, curpos, -(val*2-1), 1, 1, false, false)
              else
                reaper.InsertEnvelopePoint(env, curpos, val*1024, 1, 1, false, false)
              end
              VisEnv(env, true)
            end
          end
        end
      end
    end
    
    local m_shift = reaper.JS_Mouse_GetState(8)&8==8
    if not m_shift then
      local cnt = reaper.CountSelectedTracks(0)
      for t = 0, cnt-1 do
        local track = reaper.GetSelectedTrack(0, t)
        if track and track ~= trackD then
          local ttrn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
          if not lvar.ctltracks[ttrn] then
            if tmppos.trparam ~= -1 then
              local parcode = tab_trparams_code[tmppos.trparam]
              local envname = tab_trparams_envnames[tmppos.trparam]
              if parcode and not track_info[parcode].mononly then
                
                local env = GetTrackEnvelope(track, tmppos.trparam, tmppos.trsend, true)
                if env then
                  local pt = reaper.GetEnvelopePointByTimeEx(env, -1, curpos)
                  if pt >= 0 then
                    --set shape to square
                    reaper.SetEnvelopePointEx(env, -1, pt, nil, nil, 1)
                  end
  
                  if envname == 'Volume' then
                    local val = reaper.ScaleToEnvelopeMode(reaper.GetEnvelopeScalingMode(env), val)
                    reaper.InsertEnvelopePoint(env, curpos, val, 1, 1, false, false)
                  elseif envname == 'Pan' then
                    reaper.InsertEnvelopePoint(env, curpos, -(val*2-1), 1, 1, false, false)
                  else
                    reaper.InsertEnvelopePoint(env, curpos, val*1024, 1, 1, false, false)
                  end
                  VisEnv(env, true)
                end
              end
            end
          end
          
        end
      end
    end
    reaper.UpdateArrange()
    
  end
  
  function QFX_Learn()
  
    local tab
    --local ret, trnum, fxnum, pnum = reaper.GetLastTouchedFX()
    if lvar.lasttouchedparam then
      local trnum, fxnum, pnum = lvar.lasttouchedparam.trnum, lvar.lasttouchedparam.fxnum, lvar.lasttouchedparam.pnum
      local track = GetTrack(trnum)
      if track then
        tab = {}
        tab.mode = 0
        _, tab.module = reaper.BR_TrackFX_GetFXModuleName(track, fxnum)
        tab.trnum = trnum
        tab.fxnum = fxnum
        tab.pnum = pnum
        tab.trguid = reaper.GetTrackGUID(track)
        tab.fxguid = reaper.TrackFX_GetFXGUID(track, fxnum)
        _, tab.pname = reaper.TrackFX_GetParamName(track, fxnum, pnum, '')
        tab.enabled = 1
        tab.min = 0
        tab.max = 1
        --tab.sscolor 
      end
    end
    return tab
    
  end
  
  function QFX_FindFX(qfx)
  
    if qfx.trnum == -100 and lvar.readparams then
      return nil, qfx.trnum, qfx.fxnum
    end

    local fnd, ftrn, ffxnum
    if qfx.mode == 0 then

      local track = GetTrack(qfx.trnum)
      if track and reaper.GetTrackGUID(track) == qfx.trguid then
        if reaper.TrackFX_GetFXGUID(track, qfx.fxnum) == qfx.fxguid then
          qfx.enabled = 1
          return track, qfx.trnum, qfx.fxnum
        else
    
          for f = 0, reaper.TrackFX_GetCount(track)-1 do
            if reaper.TrackFX_GetFXGUID(track, f) == qfx.fxguid then
              fnd = true
              --ftrn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
              qfx.fxnum = f
              qfx.enabled = 1
              return track, qfx.trnum, qfx.fxnum
            end
          end
        end
      end
    
      if not fnd then
    
        for t = -1, reaper.CountTracks(0)-1 do
          track = GetTrack(t)
          if track then
            for f = 0, reaper.TrackFX_GetCount(track)-1 do
              if reaper.TrackFX_GetFXGUID(track, f) == qfx.fxguid then
                qfx.trnum = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
                qfx.trguid = reaper.GetTrackGUID(track)
                qfx.fxnum = f
                qfx.enabled = 1
                return track, qfx.trnum, qfx.fxnum
              end
            end    
          end
        end
      end
      
      if not fnd then
        --plugin not available
        qfx.trnum = -100
        --qfx.trguid = ''
        qfx.fxnum = -1
        qfx.enabled = 0
        return nil, qfx.trnum, qfx.fxnum
      end
  
    elseif qfx.mode == 1 then
      
      
      local track = GetTrack(qfx.trnum)

      if track and FFX then
        if qfx.trguid == FFX.trguid and qfx.fxguid == reaper.TrackFX_GetFXGUID(track, qfx.fxnum) then
          return track, qfx.trnum, qfx.fxnum
        end
      end
      
      if FFX then
        qfx.trguid = FFX.trguid
        qfx.trnum = FFX.trn
    
        local track = GetTrack(qfx.trnum)
        if track and reaper.GetTrackGUID(track) == qfx.trguid then
      
          for f = 0, reaper.TrackFX_GetCount(track)-1 do
            local _, mod = reaper.BR_TrackFX_GetFXModuleName(track, f)
            if mod == qfx.module then
              fnd = true
              --ftrn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
              qfx.fxnum = f
              qfx.fxguid = reaper.TrackFX_GetFXGUID(track, f) 
              qfx.enabled = 1
              return track, qfx.trnum, qfx.fxnum
            end
          end
        end
      end
      if not fnd then
        --plugin not available
        qfx.trnum = -100
        --qfx.trguid = ''
        qfx.fxnum = -1
        qfx.enabled = 0
        return nil, qfx.trnum, qfx.fxnum
      end      
    
    end
  end
  
  function HLGroupButtons2()

    local g = lvar.ctlgroup_select
    local gidx = lvar.groupidx[g]
    local blast
    if lvar.groupctlidx[gidx] then
      --GMFB_FFlashData(0,8,0.05,-1)
      GMFB_FFlashData(lvar.groupind[2].type,lvar.groupind[2].on,lvar.groupind[2].off,lvar.groupind[2].rep,lvar.groupind[2].invert)
      local gmem = reaper.gmem_write
      gmem(lvar.gm_fb.fflash_cnt,0)
      gmem(lvar.gm_fb.fflash_data+lvar.fflashidx_reset,1)
      local cnt = 0
      for a, b in pairs(lvar.groupctlidx[gidx]) do
        local i = b
        local tmp
        tmp = GetTemplate(i)
        --[[if permatemplate.pos[i] then
          tmp = permatemplate        
        elseif globtemplate.pos[i] and lvar.showglobalmap then
          tmp = globtemplate
        else
          tmp = template
        end]]
        if tmp and ctl_template.fader[i] and tmp.pos[i] --[[and ((tmp.pos[i].bstate and tmp.pos[i].bstate > 0) or tmp.pos[i].ledon == 1)]] then
          --gmem(lvar.gm_fb.fset+(i-1),127)
          gmem(lvar.gm_fb.fflash+cnt,i-1)
          --blast = true
        else
          --gmem(lvar.gm_fb.fset+(i-1),0)
          gmem(lvar.gm_fb.fflash+cnt,-1)
          --blast = true        
        end
        cnt = cnt + 1
      end      
      gmem(lvar.gm_fb.ignorebstate,0) --we want to flash bstate buttons only
      gmem(lvar.gm_fb.fflash_cnt,cnt)
      if blast then
        --local ctltrack = GetTrack(LBX_CTL_TRACK)
        --reaper.TrackFX_SetParam(ctltrack, 0, 58, 2)
        gmem(lvar.gm_fb.gswitch59,2)
        
        blast = nil
      end
    end  
  end
  
  function HLGroupFlash()
    lvar.grpflash_timer = lvar.grpflash_timer +1
    local g = lvar.ctlgroup_select
    local gidx = lvar.groupidx[g]
    local blast
    if lvar.grpflash_timer > #lvar.grptab*2 --[[lvar.group[gidx]] then
      lvar.grpflash_timer = nil
      HLGroupButtons2()
    else
      local on = math.floor((lvar.grpflash_timer-1) / #lvar.grptab)*127
      local gmem = reaper.gmem_write
      local i = lvar.grptab[((lvar.grpflash_timer-1) % #lvar.grptab) +1]
      gmem(lvar.gm_fb.fset+(i-1),127-on)
      blast = true
    end 
    if blast then
      --local ctltrack = GetTrack(LBX_CTL_TRACK)
      --reaper.TrackFX_SetParam(ctltrack, 0, 58, 2)
      local gmem = reaper.gmem_write
      gmem(lvar.gm_fb.gswitch59,2)
      blast = nil
    end
  end
  
  function HLGroupButtons(on)
    local blast
    if on then
      --GMFB_FFlashData(0,0.2,0.05,6)
      GMFB_FFlashData(lvar.groupind[1].type,lvar.groupind[1].on,lvar.groupind[1].off,lvar.groupind[1].rep,lvar.groupind[1].invert)
      
      lvar.grpflash_timer = reaper.time_precise()+lvar.fflash_duration
      
      local g = lvar.ctlgroup_select
      local gidx = lvar.groupidx[g]
      if lvar.groupctlidx[gidx] then
        local gmem = reaper.gmem_write
        local cnt = 0

        gmem(lvar.gm_fb.fflash_data+lvar.fflashidx_reset,1)
        for a, b in pairs(lvar.groupctlidx[gidx]) do
          local i = b
          gmem(lvar.gm_fb.fflash+cnt,i-1)
          --if tmp and ctl_template.fader[i] then
            --gmem(lvar.gm_fb.fset+(i-1),127)
            --blast = true
          --end
          cnt=cnt+1
        end
        if cnt < 8 then
          for i = cnt, 8 do
            gmem(lvar.gm_fb.fflash+i,-1)
          end
        end
        gmem(lvar.gm_fb.fflash_cnt,cnt)
        gmem(lvar.gm_fb.ignorebstate,1) --we want to flash all buttons
      end
      if blast then
        --local ctltrack = GetTrack(LBX_CTL_TRACK)
        --reaper.TrackFX_SetParam(ctltrack, 0, 58, 2)
        local gmem = reaper.gmem_write
        gmem(lvar.gm_fb.gswitch59,2)
        blast = nil
      end
    else
      local g = lvar.ctlgroup_select
      local gidx = lvar.groupidx[g]
      if lvar.groupctlidx[gidx] then
        local gmem = reaper.gmem_write
        for a, b in pairs(lvar.groupctlidx[gidx]) do
          local i = b
          --gmem(lvar.gm_fb.fflash+(i-1),-1)
          local tmp
          tmp = GetTemplate(i)
          --[[if permatemplate.pos[i] then
            tmp = permatemplate        
          elseif globtemplate.pos[i] and lvar.showglobalmap then
            tmp = globtemplate
          else
            tmp = template
          end]]
          gmem(lvar.gm_fb.fset+(i-1),0)
          if tmp and tmp.pos[i] then
            tmp.pos[i].bstate = 1 --force reread of button state
            reaper.gmem_write(lvar.gm_fb.bstate+(i-1), 1)
            
            tmp.pos[i].donotflashscribble = reaper.time_precise() + lvar.dnfs_time --prevent flashing value for button when rereading button state
            gmem(lvar.gm_fb.fset+(i-1),(tmp.pos[i].ledon or 0)*127)
          end
          blast = true
        end
        gmem(lvar.gm_fb.fflash_cnt,0)

      end    
      if blast then
        --local ctltrack = GetTrack(LBX_CTL_TRACK)
        --reaper.TrackFX_SetParam(ctltrack, 0, 58, 3)
        local gmem = reaper.gmem_write
        gmem(lvar.gm_fb.gswitch59,3)
        blast = nil
      end
    end
  end
  
  function FindFX(track, trguid, fxguid, singletracksearch)

    local fnd, ftrn, ffxnum
    if track and reaper.GetTrackGUID(track) == trguid then
      for f = 0, reaper.TrackFX_GetCount(track)-1 do
        if reaper.TrackFX_GetFXGUID(track, f) == fxguid then
          fnd = true
          ftrn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
          ffxnum = f
          return ftrn, trguid, ffxnum
        end
      end
    end
  
    if not fnd and not singletracksearch then
      for t = -1, reaper.CountTracks(0)-1 do
        track = GetTrack(t)
        if track then
          for f = 0, reaper.TrackFX_GetCount(track)-1 do
            if reaper.TrackFX_GetFXGUID(track, f) == fxguid then
              fnd = true
              ftrn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
              ffxnum = f
              return ftrn, reaper.GetTrackGUID(track), ffxnum
            end
          end    
        end
      end
    end
    
    if not fnd then
      --plugin not available
      return -100, nil, -1
    end
  
  end

  function FindFX2(track, fxmodule, fxguid)
    local fnd, ftrn, ftrguid, ffxnum, ffxguid
    --if reaper.GetTrackGUID(track) == trguid then
    if track then
      if fxguid then
        for f = 0, reaper.TrackFX_GetCount(track)-1 do
          local guid = reaper.TrackFX_GetFXGUID(track, f) 
          if guid and guid == fxguid then 
            fnd = true
            ftrn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
            ftrguid = reaper.GetTrackGUID(track)
            ffxnum = f
            ffxguid = guid
            return ftrn, ftrguid, ffxnum, ffxguid 
          end
        end
      end
      if not fnd then
        for f = 0, reaper.TrackFX_GetCount(track)-1 do
          local _, mn = reaper.BR_TrackFX_GetFXModuleName(track, f) 
          if mn and mn == fxmodule then 
            fnd = true
            ftrn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
            ftrguid = reaper.GetTrackGUID(track)
            ffxnum = f
            ffxguid = reaper.TrackFX_GetFXGUID(track, f)
            return ftrn, ftrguid, ffxnum, ffxguid 
          end
        end
      end
    --else
    end
  
    --[[if not fnd and not singletracksearch then
      for t = -1, reaper.CountTracks(0)-1 do
        track = GetTrack(t)
        if track then
          for f = 0, reaper.TrackFX_GetCount(track)-1 do
            if reaper.TrackFX_GetFXGUID(track, f) == fxguid then
              fnd = true
              ftrn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
              ffxnum = f
              return ftrn, reaper.GetTrackGUID(track), ffxnum
            end
          end    
        end
      end
    end]]
    
    if not fnd then
      --plugin not available
      return -100, nil, -1, nil
    end
  
  end

  function GetTS(take)
  
    if lvar.rrsettings.timeselection == 1 then
    
      local start_time, end_time = reaper.GetSet_LoopTimeRange2(0, false, false, 0, 0, false) 
      if start_time ~= end_time then
        local sppq = reaper.MIDI_GetPPQPosFromProjTime(take, start_time)
        local eppq = reaper.MIDI_GetPPQPosFromProjTime(take, end_time)
        
        return start_time, end_time, sppq, eppq
      end
    end
  
  end

  function RR_DefeatNotes(rrdefeat)

    reaper.PreventUIRefresh(1)

    local take = reaper.GetMediaItemTakeByGUID(0, rrdefeat.takeguid or '')
    if take and reaper.ValidatePtr(take, "MediaItem_Take*") then
      reaper.Undo_BeginBlock2(0)
  
      local gmem_wr = reaper.gmem_write
      local idxn = rrdefeat.mutednotes_cnt
      local idx = rrdefeat.mutedevents_cnt

      if lvar.rrsettings.overdubnotes ~= 1 then

        local pb = {}
        
        local ts_start, ts_end, ts_sppq, ts_eppq = GetTS(take)
        local takes = {}
        takes[0] = take
        
        local itemnum = 0
        local itemcnt = 0
        if lvar.rrsettings.timeselection == 1 and ts_sppq then
          --potential multiple items
          local item = reaper.GetMediaItemTake_Item(take)
          local item_n = reaper.GetMediaItemInfo_Value(item, 'IP_ITEMNUMBER')
          local track = reaper.GetMediaItemInfo_Value(item, 'P_TRACK')
          
          item_n = item_n + 1
          local item2 = reaper.GetTrackMediaItem(track, item_n)
          while item2 do
            itemcnt = itemcnt + 1
            local spos = reaper.GetMediaItemInfo_Value(item2, 'D_POSITION')
            if spos >= ts_end then
              break
            end
            takes[itemcnt] = reaper.GetActiveTake(item2) 
            item_n = item_n + 1
            item2 = reaper.GetTrackMediaItem(track, item_n)
          end
        end
  
        for t = 0, itemcnt do
        
          local take = takes[t]  
          local itemnum = t
          
          if take and reaper.TakeIsMIDI(take) then
        
            reaper.MIDI_DisableSort(take)
            local retval, notecnt, ccevtcnt, textsyxevtcnt = reaper.MIDI_CountEvts(take)
    
            --mute notes
            for i = 0, notecnt do
              retval, selected, muted, startppqpos, endppqpos, chan, pitch, vel = reaper.MIDI_GetNote(take, i)
              if not muted then
                local pos = reaper.MIDI_GetProjTimeFromPPQPos(take, startppqpos)
                if lvar.rrsettings.timeselection ~= 1 or ts_start == nil or (pos >= ts_start and pos <= ts_end) then
                  --mute
                  reaper.MIDI_SetNote(take, i, nil, true, nil, nil, nil, nil, nil, nil)
                end
              else
                -- should probably mute and index
                rrdefeat.mutednotes[(itemnum<<24)+i] = true
                idxn = idxn + 1
                gmem_wr(lvar.rrrec_data.mutednotesindexes + (idxn-1), (itemnum<<24)+i)
                reaper.MIDI_SetNote(take, i, nil, true, nil, nil, nil, nil, nil, nil)
              end
            end
    
            --need to mute PB and AT here?
            for i = 0, ccevtcnt do
              local retval, selected, muted, ppqpos, chanmsg, chan, msg2, msg3 = reaper.MIDI_GetCC(take, i)
              --AT PB CC's only
              --DBG(lvar.rrsettings.overdubnotes..' '..ichan..' '..chan)
              if lvar.rrsettings.overdubnotes ~= 1 --[[and ichan == chan ]]
                     and (chanmsg == 208 or chanmsg == 224) then 
                if not muted then
                  local pos = reaper.MIDI_GetProjTimeFromPPQPos(take, ppqpos)
                  if lvar.rrsettings.timeselection ~= 1 or ts_start == nil or (pos >= ts_start and pos <= ts_end) then
                    --mute
                    reaper.MIDI_SetCC(take, i, nil, true, nil, nil, nil, nil, nil, nil)
                    --Send PB reset message if necessary via loopback
                    if not pb[chan] then
                      pb[chan] = true
                    end
                  end
                else
                  -- should probably mute and index
                  rrdefeat.mutedevents[(itemnum<<24)+i] = true
                  idx = idx + 1
                  gmem_wr(lvar.rrrec_data.mutedindexes + (idx-1), (itemnum<<24)+i)
                  reaper.MIDI_SetCC(take, i, nil, true, nil, nil, nil, nil, nil, nil)
                end
              end
            end
            
            rrdefeat.mutedevents_cnt = idx
            gmem_wr(lvar.rrrec_data.mutedindexes_cnt, rrdefeat.mutedevents_cnt)
    
            rrdefeat.mutednotes_cnt = idxn
            gmem_wr(lvar.rrrec_data.mutednotesindexes_cnt, rrdefeat.mutednotes_cnt)
            
            reaper.MIDI_Sort(take)
          end
        end
        
        --reset PB
        for chan, b in pairs(pb) do
          SendMIDIMsg_ToTrack(224+chan, 0, 0x40)
        end
        
        reaper.Undo_EndBlock2(0, "Clear CC's", 0)
      end
  
    end
    
    reaper.PreventUIRefresh(-1)
    
  end
  
  function RR_DefeatCC(icc, ichan, cc14bit, playpos, rrdefeat)

    reaper.PreventUIRefresh(1)
    
    --local take = lvar.rr_ccdefeat.take
    local take = reaper.GetMediaItemTakeByGUID(0, rrdefeat.takeguid or '')
    if take and reaper.ValidatePtr(take, "MediaItem_Take*") then
      reaper.Undo_BeginBlock2(0)
  
      local gmem_wr = reaper.gmem_write
      local idx = rrdefeat.mutedevents_cnt
  
      local exception_cc = lvar.exception_cc

      local ts_start, ts_end, ts_sppq, ts_eppq = GetTS(take)
      local takes = {}
      takes[0] = take
      
      local itemnum = 0
      local itemcnt = 0
      if lvar.rrsettings.timeselection == 1 and ts_sppq then
        --potential multiple items
        local item = reaper.GetMediaItemTake_Item(take)
        local item_n = reaper.GetMediaItemInfo_Value(item, 'IP_ITEMNUMBER')
        local track = reaper.GetMediaItemInfo_Value(item, 'P_TRACK')
        
        item_n = item_n + 1
        local item2 = reaper.GetTrackMediaItem(track, item_n)
        while item2 do
          itemcnt = itemcnt + 1
          local spos = reaper.GetMediaItemInfo_Value(item2, 'D_POSITION')
          if spos >= ts_end then
            break
          end
          takes[itemcnt] = reaper.GetActiveTake(item2) 
          item_n = item_n + 1
          item2 = reaper.GetTrackMediaItem(track, item_n)
        end
      end

      for t = 0, itemcnt do
      
        local take = takes[t]  
        local itemnum = t
        
        if take and reaper.TakeIsMIDI(take) then

          reaper.MIDI_DisableSort(take)
          local retval, notecnt, ccevtcnt, textsyxevtcnt = reaper.MIDI_CountEvts(take)
          
          for i = 0, ccevtcnt do
            local retval, selected, muted, ppqpos, chanmsg, chan, msg2, msg3 = reaper.MIDI_GetCC(take, i)
            --CC's only
            if chanmsg == 176 and not exception_cc[msg2]
               and ichan == chan and (icc == msg2 or (cc14bit and icc < 32 and icc+32 == msg2)) then
              local pos = reaper.MIDI_GetProjTimeFromPPQPos(take, ppqpos)
              --DBG(pos..'  '..ts_start)
              if (pos >= playpos and (lvar.rrsettings.timeselection ~= 1 or ts_start == nil)) 
                 or (ts_start and pos >= ts_start and pos <= ts_end) then
                if not muted then
                  --mute
                  reaper.MIDI_SetCC(take, i, nil, true, nil, nil, nil, nil, nil, nil)
                else
                  -- should probably mute and index
                  rrdefeat.mutedevents[(itemnum<<24)+i] = true
                  idx = idx + 1
                  gmem_wr(lvar.rrrec_data.mutedindexes + (idx-1), (itemnum<<24)+i)
                  reaper.MIDI_SetCC(take, i, nil, true, nil, nil, nil, nil, nil, nil)
                end
              end
            end
          end
          rrdefeat.mutedevents_cnt = idx
          gmem_wr(lvar.rrrec_data.mutedindexes_cnt, rrdefeat.mutedevents_cnt)
          reaper.MIDI_Sort(take)
        end
      end
      
      reaper.Undo_EndBlock2(0, "Clear CC's", 0)
    end
    
    reaper.PreventUIRefresh(-1)
    
  end

  function RR_Undefeat(icc, ichan, cc14bit, playpos, rrdefeat)

    reaper.PreventUIRefresh(1)
    --local take = lvar.rr_ccdefeat.take
    local take = reaper.GetMediaItemTakeByGUID(0, rrdefeat.takeguid or '')
    if take and reaper.ValidatePtr(take, "MediaItem_Take*") then
      reaper.Undo_BeginBlock2(0)

      local exception_cc = lvar.exception_cc
      
      local ts_start, ts_end, ts_sppq, ts_eppq = GetTS(take)
      local takes = {}
      takes[0] = take
      
      local itemnum = 0
      local itemcnt = 0
      if lvar.rrsettings.timeselection == 1 and ts_sppq then
        --potential multiple items
        local item = reaper.GetMediaItemTake_Item(take)
        local item_n = reaper.GetMediaItemInfo_Value(item, 'IP_ITEMNUMBER')
        local track = reaper.GetMediaItemInfo_Value(item, 'P_TRACK')
        
        item_n = item_n + 1
        local item2 = reaper.GetTrackMediaItem(track, item_n)
        while item2 do
          itemcnt = itemcnt + 1
          local spos = reaper.GetMediaItemInfo_Value(item2, 'D_POSITION')
          if spos >= ts_end then
            break
          end
          takes[itemcnt] = reaper.GetActiveTake(item2) 
          item_n = item_n + 1
          item2 = reaper.GetTrackMediaItem(track, item_n)
        end
      end

      for t = 0, itemcnt do
      
        local take = takes[t]
        local itemnum = t
    
        if take and reaper.TakeIsMIDI(take) then
      
          reaper.MIDI_DisableSort(take)
          local retval, notecnt, ccevtcnt, textsyxevtcnt = reaper.MIDI_CountEvts(take)
          for i = 0, ccevtcnt do
            local retval, selected, muted, ppqpos, chanmsg, chan, msg2, msg3 = reaper.MIDI_GetCC(take, i)
            if chanmsg == 176 and not exception_cc[msg2]
               and ichan == chan and (icc == msg2 or (cc14bit and icc < 32 and icc+32 == msg2)) then
               
              local pos = reaper.MIDI_GetProjTimeFromPPQPos(take, ppqpos)
              if (pos >= playpos and (lvar.rrsettings.timeselection ~= 1 or ts_start == nil)) 
                 or (ts_start and pos >= ts_start and pos <= ts_end) then
                if muted and not rrdefeat.mutedevents[(itemnum<<24)+i] then
                  --unmute
                  reaper.MIDI_SetCC(take, i, nil, false, nil, nil, nil, nil, nil, nil)
                end
              end
          
            end
          end
        
          reaper.MIDI_Sort(take)
        end
      end
      
      reaper.Undo_EndBlock2(0, "Restore CC's", 0)
    end
    reaper.PreventUIRefresh(-1)
    
  end
  
  function RR_UndefeatNotes(rrdefeat)
    
    reaper.PreventUIRefresh(1)
    --local take = lvar.rr_ccdefeat.take
    local take = reaper.GetMediaItemTakeByGUID(0, rrdefeat.takeguid or '')
    if take and reaper.ValidatePtr(take, "MediaItem_Take*") then
      reaper.Undo_BeginBlock2(0)
  
      local ts_start, ts_end, ts_sppq, ts_eppq = GetTS(take)
      local takes = {}
      takes[0] = take
      
      local itemnum = 0
      local itemcnt = 0
      if lvar.rrsettings.timeselection == 1 and ts_sppq then
        --potential multiple items
        local item = reaper.GetMediaItemTake_Item(take)
        local item_n = reaper.GetMediaItemInfo_Value(item, 'IP_ITEMNUMBER')
        local track = reaper.GetMediaItemInfo_Value(item, 'P_TRACK')
        
        item_n = item_n + 1
        local item2 = reaper.GetTrackMediaItem(track, item_n)
        while item2 do
          itemcnt = itemcnt + 1
          local spos = reaper.GetMediaItemInfo_Value(item2, 'D_POSITION')
          if spos >= ts_end then
            break
          end
          takes[itemcnt] = reaper.GetActiveTake(item2) 
          item_n = item_n + 1
          item2 = reaper.GetTrackMediaItem(track, item_n)
        end
      end

      for t = 0, itemcnt do
      
        local take = takes[t]
        local itemnum = t
    
        if take and reaper.TakeIsMIDI(take) then
      
          reaper.MIDI_DisableSort(take)
          local retval, notecnt, ccevtcnt, textsyxevtcnt = reaper.MIDI_CountEvts(take)
          if lvar.rrsettings.overdubnotes ~= 1 then
            for i = 0, notecnt do
              retval, selected, muted, startppqpos, endppqpos, chan, pitch, vel = reaper.MIDI_GetNote(take, i)
              if muted and not rrdefeat.mutednotes[(itemnum<<24)+i] then
                --unmute
                reaper.MIDI_SetNote(take, i, nil, false, nil, nil, nil, nil, nil, nil)
              end
            end
          
            reaper.MIDI_DisableSort(take)
            for i = 0, ccevtcnt do
              local retval, selected, muted, ppqpos, chanmsg, chan, msg2, msg3 = reaper.MIDI_GetCC(take, i)
              if lvar.rrsettings.overdubnotes ~= 1 --[[and ichan == chan]] 
                     and (chanmsg == 208 or chanmsg == 224) then 
                if muted and not rrdefeat.mutedevents[(itemnum<<24)+i] then
                  --unmute
                  reaper.MIDI_SetCC(take, i, nil, false, nil, nil, nil, nil, nil, nil)
                end
              end
            end
          end
          reaper.MIDI_Sort(take)
        end
      end
      
      reaper.Undo_EndBlock2(0, "Restore Notes's", 0)
    end
    reaper.PreventUIRefresh(-1)
    
  end
  
  local function A_GetFaderBoxVals()
    if lvar.readparams ~= true or (lvar.livemode ~= 0) then return end --do not read if values not already read in
    --DBGOut('GetFaderBoxVals')
    ret = false
    if --[[FFX and]] LBX_CTL_TRACK then
      
      local rt = reaper.time_precise()
      local cctouch = false
      
      fbactive = FBActive()
      
      fbvals = {}
      local track = GetTrack(LBX_CTL_TRACK)
      local track2, fxnum2, ffxtake
      if FFX then
        track2 = GetTrack(FFX.trn)
        ffxtake = FFX.take
        fxnum2 = FFX.fxnum
      end
      local track3 = GetTrack(LBX_CC_TRACK)
      local fxnum = 0

      local gmem = reaper.gmem_read

      local playstate = reaper.GetPlayState()
      
      if lvar.rr_defeat_active then
        local resetrrdata = gmem(lvar.rrrec_data.resetdata)
        local reset 
        if resetrrdata == 1 then
          --DBG('RESET')
          lvar.rr_ccdefeat = nil
          local gmem_wr = reaper.gmem_write
          gmem_wr(lvar.rrrec_data.resetdata, 0)
          gmem_wr(lvar.rrrec_data.dataset, 0)
          reset = true
        end
        
        if lvar.rr_ccdefeat and playstate&1==1 then
          reaper.gmem_attach('LBX_RRData')
          lvar.notesplayed = gmem(lvar.rrrec_data.notes_played)
          lvar.cc64played = gmem(lvar.rrrec_data.cc64_played)
          lvar.cc1played = gmem(lvar.rrrec_data.cc1_played)
          lvar.pbplayed = gmem(lvar.rrrec_data.pb_played)
          reaper.gmem_attach('LBX_SK2_SharedMem')
          
          if lvar.notesplayed == 1 and not lvar.rr_ccdefeat.notesdefeated then
            RR_DefeatNotes(lvar.rr_ccdefeat)
            lvar.rr_ccdefeat.notesdefeated = true
          elseif lvar.notesplayed == 0 then
            lvar.rr_ccdefeat.notesdefeated = nil
          end
          if lvar.cc64played ~= -1 and not lvar.rr_ccdefeat.cc64defeated then
            local pp = reaper.GetPlayPosition()
            local cc = 64
            local chan = lvar.cc64played
            RR_DefeatCC(cc, chan, 0, reaper.GetPlayPosition(), lvar.rr_ccdefeat)
            local key = cc ..'_'..chan
            lvar.rr_ccdefeat[key] = {pp = pp, cc = cc, chan = chan, cc14bit = 0}
            --Store data for recall in Capture
            lvar.rr_ccdefeat.slotcnt = lvar.rr_ccdefeat.slotcnt + 1
            local code = (chan << 7) + 64
            local idx = lvar.rr_ccdefeat.slotcnt-1
            local gmem_wr = reaper.gmem_write
            gmem_wr(lvar.rrrec_data.slotinfo_cnt, lvar.rr_ccdefeat.slotcnt)
            gmem_wr(lvar.rrrec_data.slotinfo + idx, code)
            gmem_wr(lvar.rrrec_data.slotinfo_pp + idx, pp)
            lvar.rr_ccdefeat.cc64defeated = true
          elseif lvar.cc64played == -1 then
            lvar.rr_ccdefeat.cc64defeated = nil
          end
          if lvar.cc1played ~= -1 and not lvar.rr_ccdefeat.cc1defeated then
            local cc = 1
            local key = cc ..'_'..string.format('%i',lvar.cc1played)
            if not lvar.rr_ccdefeat[key] then
              local pp = reaper.GetPlayPosition()
              local chan = lvar.cc1played
              RR_DefeatCC(cc, chan, 0, reaper.GetPlayPosition(), lvar.rr_ccdefeat)
              --local key = cc ..'_'..string.format('%i',chan)
              lvar.rr_ccdefeat[key] = {pp = pp, cc = cc, chan = chan, cc14bit = 0}
              --Store data for recall in Capture
              lvar.rr_ccdefeat.slotcnt = lvar.rr_ccdefeat.slotcnt + 1
              local code = (chan << 7) + 1
              local idx = lvar.rr_ccdefeat.slotcnt-1
              local gmem_wr = reaper.gmem_write
              gmem_wr(lvar.rrrec_data.slotinfo_cnt, lvar.rr_ccdefeat.slotcnt)
              gmem_wr(lvar.rrrec_data.slotinfo + idx, code)
              gmem_wr(lvar.rrrec_data.slotinfo_pp + idx, pp)
            end
            lvar.rr_ccdefeat.cc1defeated = true
          elseif lvar.cc1played == -1 then
            lvar.rr_ccdefeat.cc1defeated = nil
          end
          if lvar.pbplayed ~= -1 and not lvar.rr_ccdefeat.pbdefeated then
            lvar.rr_ccdefeat.pbdefeated = true
          elseif lvar.pbplayed == -1 then
            lvar.rr_ccdefeat.pbdefeated = nil
          end
        end
        
        if (reset or playstate ~= lvar.rrplaystate) and (playstate&1==1 --[[or playstate&4==4]]) then
          --Reset enctouch
          local gmem_wr = reaper.gmem_write
          for i = 0, lvar.fcount-1 do
            gmem_wr(lvar.enctouch+i, 0)
          end
          lvar.rr_ccdefeat = {}
          --Get Item at or after PP
          local pp = reaper.GetPlayPosition()
          lvar.rr_ccdefeat.startpp = pp
          if track2 then
            local tritems = reaper.CountTrackMediaItems(track2)
            for iidx = 0, tritems-1 do
              local item = reaper.GetTrackMediaItem(track2, iidx)
              if item then
                local ipos = reaper.GetMediaItemInfo_Value(item, 'D_POSITION')
                local ilen = reaper.GetMediaItemInfo_Value(item, 'D_LENGTH')
                if (ipos <= pp and ipos + ilen > pp+lvar.defeatitem_offset) or ipos > pp then
                  --DBG(iidx..'  '..pp)
                  local take = reaper.GetActiveTake(item)
                  if reaper.ValidatePtr2(0, take, "MediaItemTake*") and reaper.TakeIsMIDI(take) then
                  
                    lvar.rr_ccdefeat.item = item
                    lvar.rr_ccdefeat.take = take
                    lvar.rr_ccdefeat.mutedevents = {}
                    lvar.rr_ccdefeat.mutednotes = {}
                    lvar.rr_ccdefeat.slotcnt = 0
                    lvar.rr_ccdefeat.mutedevents_cnt = 0
                    lvar.rr_ccdefeat.mutednotes_cnt = 0
                    --DBG('START')
                    _, lvar.rr_ccdefeat.takeguid = reaper.GetSetMediaItemTakeInfo_String(take, "GUID", '', false)
                    gmem_wr(lvar.rrrec_data.tracknum, reaper.GetMediaTrackInfo_Value(track2, 'IP_TRACKNUMBER'))
                    gmem_wr(lvar.rrrec_data.itemnum, reaper.GetMediaItemInfo_Value(item, 'IP_ITEMNUMBER'))
                    gmem_wr(lvar.rrrec_data.takenum, reaper.GetMediaItemInfo_Value(item, 'I_CURTAKE'))
                    gmem_wr(lvar.rrrec_data.slotinfo_cnt, 0)
                    gmem_wr(lvar.rrrec_data.mutedindexes_cnt, 0)
                    gmem_wr(lvar.rrrec_data.mutednotesindexes_cnt, 0)
                    gmem_wr(lvar.rrrec_data.resetdata, 0)
                    gmem_wr(lvar.rrrec_data.dataset, 1)
                    --lvar.rrrec_data.slotinfo_pp
                    --lvar.rrrec_data.mutedindexes
                    --RR_DefeatNotes(lvar.rr_ccdefeat)
                    break
                  end
                end
              end
            end
          end
          if not lvar.rr_ccdefeat.take or not lvar.rr_ccdefeat.takeguid then
            lvar.rr_ccdefeat = nil
            local gmem_wr = reaper.gmem_write
            gmem_wr(lvar.rrrec_data.dataset, 0)
            --DBG('WIPING DATA')
          end
  
        elseif playstate ~= lvar.rrplaystate and lvar.rr_ccdefeat then
          if lvar.rr_ccdefeat.takeguid then
            for a, b in pairs(lvar.rr_ccdefeat) do
              if type(b) == 'table' and tonumber(b.cc) then
                RR_Undefeat(b.cc, b.chan, b.cc14bit, b.pp, lvar.rr_ccdefeat)
              end
            end
            if lvar.rrsettings.overdubnotes ~= 1 and lvar.notesplayed == 1 then
              RR_UndefeatNotes(lvar.rr_ccdefeat)
            end
          end
          lvar.notesplayed = 0
          lvar.cc64played = -1
          lvar.rr_ccdefeat = nil
        end
      end
      
      if track then
      
        local gmem = reaper.gmem_read
        local gmem_wr = reaper.gmem_write
        for i = 1, lvar.fcount do

          local grpreset
          
          fxnum = math.floor((i-1) / 32)
          local tmp
          tmp = GetTemplate(i)

          --[[local touched = lvar.tobool[gmem(lvar.gm_fb.fadertouch + i-1)]
          if i == 1 then
          if touched and not lvar.lastuntouched_latched then
            --DBG(lvar.lastuntouched_time)
            if (lvar.lastuntouched_time or 0) >= reaper.time_precise() - 0.3 then
              DBG('DD')
            end
            lvar.lastuntouched_latched = true
            --lvar.lastuntouched_time = nil
            --lvar.lasttouched_time = reaper.time_precise()
          elseif not touched then
            if not lvar.lastuntouched_time or lvar.lastuntouched_latched then
              lvar.lastuntouched_time = reaper.time_precise()
              lvar.lastuntouched_latched = false
            end
          end
          end]]
          
          if lvar.touchrec_active then
            if lvar.touchrec_data[i] then
              MonitorTouch(i, lvar.touchrec_data[i].env)
            end
          end          

          local tmppos = tmp.pos[i]
          local lmode = ctl_template.fader[i].lmode
          local rel = gmem(lvar.gm_fb.fader_relative+(i-1));
          gmem_wr(lvar.gm_fb.fader_relative+(i-1),0);

          if tmppos then
            if recmode == 1 and lvar.rec_starttransportonfadertouch then
              if ctl_template.fader[i].ttype then
                if lvar.cclatch == false then
                  if gmem(lvar.gm_fb.fadertouch+(i-1)) == 1 then
                    cctouch = true
                    if not (playstate&1==1 or playstate&4==4) then
                      --start playback
                      reaper.Main_OnCommand(1007,0)
                      lvar.cclatch = true
                    end
                  end
                else
                  if gmem(lvar.gm_fb.fadertouch+(i-1)) == 1 then
                    cctouch = true
                  end                
                end
              end
            elseif lvar.cc_starttransportonfadertouch then
              if ctl_template.fader[i].ttype and tmppos.ptype == ptype.cc then
                if lvar.cclatch == false then
                  if gmem(lvar.gm_fb.fadertouch+(i-1)) == 1 then
                    cctouch = true
                    if not (playstate&1==1 or playstate&4==4) then
                      --start playback
                      reaper.Main_OnCommand(1007,0)
                      lvar.cclatch = true
                    end
                  end
                else
                  if gmem(lvar.gm_fb.fadertouch+(i-1)) == 1 then
                    cctouch = true
                  end                
                end
              end
            end
            
            --RR clear/mute cc's
            
            if lvar.rr_defeat_active and lvar.rr_ccdefeat and (playstate&1==1 --[[or playstate&4==4]]) then
              if tmppos.ptype == ptype.cc then
                local cc = tmppos.ccnum
                local chan = tmppos.ccchan
                local cc14bit = 0
                if tmppos.cc14bit then
                  cc14bit = 1
                end
                local key = cc..'_'..chan
                if not lvar.rr_ccdefeat[key] then
                  if ctl_template.fader[i].ttype then
                    if gmem(lvar.gm_fb.fadertouch+(i-1)) == 1 then
                      local pp = reaper.GetPlayPosition()
                      RR_DefeatCC(cc, chan, cc14bit, pp, lvar.rr_ccdefeat)
                      lvar.rr_ccdefeat[key] = {pp = pp, cc = cc, chan = chan, cc14bit = cc14bit}
                      --Store data for recall in Capture
                      lvar.rr_ccdefeat.slotcnt = lvar.rr_ccdefeat.slotcnt + 1
                      local code = (cc14bit << 11) + (chan << 7) + cc
                      local idx = lvar.rr_ccdefeat.slotcnt-1
                      gmem_wr(lvar.rrrec_data.slotinfo_cnt, lvar.rr_ccdefeat.slotcnt)
                      gmem_wr(lvar.rrrec_data.slotinfo + idx, code)
                      gmem_wr(lvar.rrrec_data.slotinfo_pp + idx, pp)
                    end
                  else --problem - encoders update values when reading data from take
                    
                    if gmem(lvar.enctouch+(i-1)) == 1 then
                      local pp = reaper.GetPlayPosition()
                      RR_DefeatCC(cc, chan, cc14bit, pp, lvar.rr_ccdefeat)
                      lvar.rr_ccdefeat[key] = {pp = pp, cc = cc, chan = chan, cc14bit = cc14bit}
                    end
                  end
                end
              end
            end
          end
         
          local val = round(gmem(lvar.gm_fb.fader_val +(i-1)),0)
          --[[if tmppos and tostring(tmppos.val) ~= tostring(val) then
            DBG(tostring(tmppos.val)..'  '..tostring(val))
          end]]
          --[[if i == 76 then
            DBG(tostring(tmppos.val)..'  '..tostring(val))
          end]]
          if tmppos and (tostring(round((tmppos.val or 0),0)) ~= tostring(val) 
             or tmppos.buttype == 5 or (lvar.relmodes[lmode] and rel ~= 0)) then            --WHAT ABOUT LMODE 2 and 6?
            --DBG(i..'  '..rel..'  '..tmppos.buttype..'  '..lmode..'  '..tostring(tmppos.val)..'  '..tostring(val))
            if lvar.latchreturn_timer and reaper.time_precise() > lvar.latchreturn_timer then
              lvar.latchreturn_set = nil
            end
            
            --maybe replace with external command
            --[[local alt = reaper.JS_Mouse_GetState(16)&16==16
            if lrnmode == true and alt and not lvar.lrn_alt_latch and lvar.fadersidx[i] then
              lvar.lrn_alt_latch = true
              --DBG(i)
              LearnPlug(i)
              
            else]] 
            if tmppos.ptype == ptype.host and (FFX or tmppos.globalhost >= 1) then
              
              tmppos.lasttweaked = reaper.time_precise()
             
              --[[if recmode == 1 then
                if fader_touch[i] == nil then
                  fader_touch[i] = true
                  if not lvar.touchrec_active then
                    local track = GetTrack(FFX.trn)
                    local env = reaper.GetFXEnvelope(track2, FFX.fxnum, tmppos.pnum, true)
                    ArmEnv(env, false)
                  end
                end
              end]]
              
              local track2 = track2
            
              local ffxtake2 = ffxtake
              
              local ok = true
              --DBG(tmppos.globalhost..'  '..tostring(tmppos.pfxguid))
              if tmppos.globalhost == 1 then
                ffxtake2 = nil
                if (tmppos.ptrack or -99) == -100 then
                  --missing fx
                  ok = false
                else
                  if (tmppos.ptrack or -99) ~= -99 then
                    track2 = GetTrack(tmppos.ptrack)
                    if track2 and ((tmppos.ptrack == 0 or reaper.GetTrackGUID(track2) == tmppos.ptrguid) and 
                       reaper.TrackFX_GetFXGUID(track2, tmppos.pfxnum) == tmppos.pfxguid) then
                      fxnum2 = tmppos.pfxnum
                    else
                      ok = false
                      --find FX
                      local trn, trguid, fxnum = FindFX(track2, tmppos.ptrguid, tmppos.pfxguid)
                      if trguid then
                        tmppos.ptrack = trn
                        tmppos.ptrguid = trguid
                        tmppos.pfxnum = fxnum

                        track2 = GetTrack(trn)
                        fxnum2 = fxnum
                        ok = true
                      else
                        tmppos.ptrack = trn -- -100
                        tmppos.pfxnum = fxnum -- -1
                      end
                    end
                  else
                    ok = false
                  end
                end
              
              elseif tmppos.globalhost == 2 then
              
                ffxtake2 = nil
                if (tmppos.ptrack or -99) == -100 then
                  --missing fx
                  ok = false
                else
                  if (tmppos.ptrack or -99) ~= -99 then
                    track2 = reaper.GetSelectedTrack2(0, 0, true)
                    
                    if reaper.TrackFX_GetFXGUID(track2, tmppos.pfxnum) == tmppos.pfxguid then
                    --[[if (tmppos.ptrack == 0 or reaper.GetTrackGUID(ffxtrack) == tmppos.ptrguid) and 
                       reaper.TrackFX_GetFXGUID(ffxtrack, tmppos.pfxnum) == tmppos.pfxguid then]]
                      fxnum2 = tmppos.pfxnum
                    else
                      ok = false
                      --find FX
                      local trn, trguid, fxnum_, fxguid_ = FindFX2(track2, tmppos.pfxmodule, tmppos.pfxguid)
                      if trguid then
                        tmppos.ptrack = trn
                        tmppos.ptrguid = trguid
                        tmppos.pfxnum = fxnum_
                        tmppos.pfxguid = fxguid_
                        track2 = GetTrack(trn)
                        fxnum2 = fxnum_
                        ok = true
                      else
                        tmppos.ptrack = trn -- -100
                        tmppos.pfxnum = fxnum_ -- -1
                      end
                    end
                  else
                    ok = false
                  end
                end
              end
              
              if recmode == 1 then
                if fader_touch[i] == nil then
                  fader_touch[i] = true
                  if not lvar.touchrec_active then
                    --local track = GetTrack(FFX.trn)
                    local env = reaper.GetFXEnvelope(track2, FFX.fxnum, tmppos.pnum, true)
                    ArmEnv(env, false)
                  end
                end
              end
              
              if ok then
                local SetParamNormalized, pointer
                if not ffxtake2 then
                  SetParamNormalized = reaper.TrackFX_SetParamNormalized
                  pointer = track2
                else
                  SetParamNormalized = reaper.TakeFX_SetParamNormalized
                  pointer = ffxtake2
                end
              
                if pointer then
                  if lmode ~= 4 then
                    if tmppos.polarity ~= 1 then
                      tmppos.val = val
                      local pnum = tmppos.pnum
                      --reaper.TrackFX_SetParamNormalized(track2, fxnum2, pnum, val/16383)
                      --min/max
                      local min, max = tmppos.min or 0, tmppos.max or 1
                      local nval = (val/16383)*(max-min)+min
                      SetParamNormalized(pointer, fxnum2, pnum, nval)
                      --gmem_wr(lvar.gm_fb.fader_val +(i-1),val)
                      fbvals[i] = val 
                      tmp.dirty[i] = true
                    else
                      local val2 = 16383-val
                      tmppos.val = val
                      local pnum = tmppos.pnum
                      --reaper.TrackFX_SetParamNormalized(track2, fxnum2, pnum, val2/16383)
                      --min/max
                      local min, max = tmppos.min or 0, tmppos.max or 1
                      local nval = 1-((val/16383)*(max-min)+min)
                      
                      SetParamNormalized(pointer, fxnum2, pnum, nval) --val2/16383)            
                      fbvals[i] = val 
                      tmp.dirty[i] = true
                    end
                  else              
                    if val/16383 > 0.5 then
                      if tmppos.buttype ~= 6 then
                        tmppos.val = 0
                      else
                        tmppos.val = val
                      end
                      local pnum = tmppos.pnum
                      local bstate
                      if tmppos.butstates == 2 then
                        bstate = round(1-(tmppos.bstate or 0),0)
                      else
                        bstate = (tmppos.bstate or 0)+(1/((tmppos.butstates or 2)-1))
                        if bstate > 1 then
                          bstate = 0
                        end
                      end  
                      
                      local vv = 0
                      if tmppos.buttype ~= 6 then
                        tmppos.bpos = (tmppos.bpos or 0) + 1
                      else
                        if tmppos.polarity ~= 1 then
                          tmppos.bpos = 2 --#tmppos.butstates_array - should it be this?
                        else
                          tmppos.bpos = 1
                        end
                      end
                      if tmppos.bpos > #tmppos.butstates_array then
                        tmppos.bpos = 1
                      end
                      if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                        vv = tmppos.butstates_array[tmppos.bpos]
                      end
                      --DBG( tmppos.bpos..'  '..vv)
                      --reaper.TrackFX_SetParamNormalized(track2, fxnum2, pnum, vv)
                      SetParamNormalized(pointer, fxnum2, pnum, vv)
                      gmem_wr(lvar.gm_fb.fader_val+(i-1),tmppos.val)
                    elseif tmppos.buttype == 6 then
                      tmppos.val = val
                      local pnum = tmppos.pnum
                      local bstate
                      if tmppos.butstates == 2 then
                        bstate = round(1-(tmppos.bstate or 0),0)
                      else
                        bstate = (tmppos.bstate or 0)+(1/((tmppos.butstates or 2)-1))
                        if bstate > 1 then
                          bstate = 0
                        end
                      end  
                      
                      local vv = 0
                      if tmppos.polarity ~= 1 then
                        tmppos.bpos = 1
                      else
                        tmppos.bpos = 2
                      end
                      if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                        vv = tmppos.butstates_array[tmppos.bpos]
                      end
                      --reaper.TrackFX_SetParamNormalized(track2, fxnum2, pnum, vv)
                      SetParamNormalized(pointer, fxnum2, pnum, vv)
                      gmem_wr(lvar.gm_fb.fader_val+(i-1),tmppos.val)
                    end
                  end
                end
                
                lupd.update_faderbar = true
                ret = true
              
                if settings.floatfxgui ~= 0 then
                  OpenFXGUI(track2, fxnum2)
                end
              end

            elseif tmppos.ptype == ptype.track then

              if recmode == 1 then
                if fader_touch[i] == nil then
                  fader_touch[i] = true
                end
                
                if lvar.autoenv_mode == 3 then
                  if lvar.recenvdata.idx2[i] and lvar.recenvdata.idx2[i].vis == false and lvar.recenvdata.idx2[i].env then
                    VisEnv(lvar.recenvdata.idx2[i].env, true, true)
                    lvar.recenvdata.idx2[i].vis = true
                  end
                end
              end
              
              local trn = tmppos.track
              local ttrn, trackD = Internal_GetTrack(trn, tmppos)

              if trackD then
                if not lvar.ctltracks[ttrn] then
                  if tmppos.trparam ~= -1 then
                    local parcode = tab_trparams_code[tmppos.trparam]
                    if parcode and not track_info[parcode].mononly then
                      
                      if lmode ~= 4 then
                        if tmppos.polarity ~= 1 then
                          tmppos.val = val
                          local pnum = tmppos.pnum
                          --reaper.TrackFX_SetParamNormalized(track2, fxnum2, pnum, val/16383)
                          --min/max
                          local min, max = tmppos.min or 0, tmppos.max or 1
                          local nval = (val/16383)*(max-min)+min
                          nval = denormalizetrackparam(nval--[[/16383]], parcode)
                          --SetParamNormalized(pointer, fxnum2, pnum, nval)
                          if tab_trparams_func[tmppos.trparam] then
                            tab_trparams_func[tmppos.trparam](trackD,nval,false)
                          else
                            reaper.SetMediaTrackInfo_Value(trackD,parcode,nval)
                          end
                          --gmem_wr(lvar.gm_fb.fader_val +(i-1),val)
                          fbvals[i] = val 
                          tmp.dirty[i] = true
                        else
                          local val2 = 16383-val
                          tmppos.val = val
                          local pnum = tmppos.pnum
                          --reaper.TrackFX_SetParamNormalized(track2, fxnum2, pnum, val2/16383)
                          --min/max
                          local min, max = tmppos.min or 0, tmppos.max or 1
                          local nval = 1-((val/16383)*(max-min)+min)
                          nval = denormalizetrackparam(nval--[[/16383]], parcode)
                          --SetParamNormalized(pointer, fxnum2, pnum, nval) --val2/16383)            
                          if tab_trparams_func[tmppos.trparam] then
                            tab_trparams_func[tmppos.trparam](trackD,nval,false)
                          else
                            reaper.SetMediaTrackInfo_Value(trackD,parcode,nval)
                          end
                          fbvals[i] = val 
                          tmp.dirty[i] = true
                        end
                      else              
                        if val/16383 > 0.5 then
                          if tmppos.buttype ~= 6 then
                            tmppos.val = 0
                          else
                            tmppos.val = val
                          end
                          local bstate
                          if tmppos.butstates == 2 then
                            bstate = round(1-(tmppos.bstate or 0),0)
                          else
                            bstate = (tmppos.bstate or 0)+(1/((tmppos.butstates or 2)-1))
                            if bstate > 1 then
                              bstate = 0
                            end
                          end  
                          
                          local vv = 0
                          if tmppos.buttype ~= 6 then
                            tmppos.bpos = (tmppos.bpos or 0) + 1
                          else
                            if tmppos.polarity ~= 1 then
                              tmppos.bpos = 2 --#tmppos.butstates_array - should it be this?
                            else
                              tmppos.bpos = 1
                            end
                          end
                          if tmppos.bpos > #tmppos.butstates_array then
                            tmppos.bpos = 1
                          end

                          if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                            vv = tmppos.butstates_array[tmppos.bpos]
                          end
                          vv = denormalizetrackparam(vv--[[/16383]], parcode)
                          if tab_trparams_func[tmppos.trparam] then
                            tab_trparams_func[tmppos.trparam](trackD,vv,false)
                          else
                            if parcode == 'I_SELECTED' and lvar.trackselectmode then
                              reaper.SetOnlyTrackSelected(trackD)
                            else
                              reaper.SetMediaTrackInfo_Value(trackD,parcode,vv)
                            end
                          end
                          gmem_wr(lvar.gm_fb.fader_val+(i-1),tmppos.val)
                        
                        elseif tmppos.buttype == 6 then
                          tmppos.val = val
                          local pnum = tmppos.pnum
                          local bstate
                          if tmppos.butstates == 2 then
                            bstate = round(1-(tmppos.bstate or 0),0)
                          else
                            bstate = (tmppos.bstate or 0)+(1/((tmppos.butstates or 2)-1))
                            if bstate > 1 then
                              bstate = 0
                            end
                          end  
                          
                          local vv = 0
                          if tmppos.polarity ~= 1 then
                            tmppos.bpos = 1
                          else
                            tmppos.bpos = 2
                          end
                          if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                            vv = tmppos.butstates_array[tmppos.bpos]
                          end
                          vv = denormalizetrackparam(vv--[[/16383]], parcode)
                          if tab_trparams_func[tmppos.trparam] then
                            tab_trparams_func[tmppos.trparam](trackD,vv,false)
                          else
                            if parcode == 'I_SELECTED' and lvar.trackselectmode then
                              reaper.SetOnlyTrackSelected(trackD)
                            else
                              reaper.SetMediaTrackInfo_Value(trackD,parcode,vv)
                            end
                            --reaper.SetMediaTrackInfo_Value(trackD,parcode,vv)
                          end
                          gmem_wr(lvar.gm_fb.fader_val+(i-1),tmppos.val)
                        end
                      end
                      
                      lupd.update_faderbar = true
                      ret = true
                      
                      
                      --[[if track_info[parcode].btype < 4 then
                        --local val = round(denormalizetrackparam(val, parcode),5)
                        --tmppos.val = val
                        local skip
                        if lmode == 4 then
                          
                          if val/16383 > 0.5 then
                            --if tmppos.buttype ~= 6 then
                              tmppos.val = 0
                            --else
                            --  tmppos.val = val
                            --end
                            local bstate
                            if tmppos.butstates == 2 then
                              bstate = round(1-(tmppos.bstate or 0),0)
                            else
                              bstate = (tmppos.bstate or 0)+(1/((tmppos.butstates or 2)-1))
                              if bstate > 1 then
                                bstate = 0
                              end
                            end  
                            
                            local vv = 0
                            if tmppos.buttype ~= 6 then
                              tmppos.bpos = (tmppos.bpos or 0) + 1
                            else
                              if tmppos.polarity ~= 1 then
                                tmppos.bpos = 2 --#tmppos.butstates_array - should it be this?
                              else
                                tmppos.bpos = 1
                              end
                            end
                            if tmppos.bpos > #tmppos.butstates_array then
                              tmppos.bpos = 1
                            end
                            if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                              vv = tmppos.butstates_array[tmppos.bpos]
                            end
                            val = math.floor(vv*16383)
                            gmem_wr(lvar.gm_fb.fader_val+(i-1),--[[tmppos.] ]val)
                            
                          elseif tmppos.buttype == 6 then
                            --DBG(val)
                            
                            DBG('L')
                            tmppos.val = 0
                            local bstate
                            if tmppos.butstates == 2 then
                              bstate = round(1-(tmppos.bstate or 0),0)
                            else
                              bstate = (tmppos.bstate or 0)+(1/((tmppos.butstates or 2)-1))
                              if bstate > 1 then
                                bstate = 0
                              end
                            end  
                            
                            local vv = 0
                            if tmppos.polarity ~= 1 then
                              tmppos.bpos = 1
                            else
                              tmppos.bpos = 2
                            end
                            if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                              vv = tmppos.butstates_array[tmppos.bpos]
                            end
                            val = math.floor(vv*16383)
                            --gmem_wr(lvar.gm_fb.fader_val+(i-1),--[[tmppos.] ]val)
                            --skip = true
                          else
                            skip = true
                          end
                        end
                        
                        if not skip then
                          if tmppos.polarity ~= 1 then
                            gmem_wr(lvar.gm_fb.fader_val +(i-1),val)
                            local val = denormalizetrackparam(val/16383, parcode)
                            tmppos.val = val
                            tmp.dirty[i] = true
                            lupd.update_faderbar = true
                            if tab_trparams_func[tmppos.trparam] then
                              tab_trparams_func[tmppos.trparam](trackD,val,false)
                            else
                              reaper.SetMediaTrackInfo_Value(trackD,parcode,val)
                            end
                          else
                            local val2 = 16383-val
                            gmem_wr(lvar.gm_fb.fader_val +(i-1),val)
                            local val = denormalizetrackparam(val2/16383, parcode)
                            tmppos.val = val
                            tmp.dirty[i] = true
                            lupd.update_faderbar = true
                            if tab_trparams_func[tmppos.trparam] then
                              tab_trparams_func[tmppos.trparam](trackD,val,false)
                            else
                              reaper.SetMediaTrackInfo_Value(trackD,parcode,val)
                            end
                          end
                        end
                      else --switch
                        tmppos.val = val
                        tmp.dirty[i] = true
                        lupd.update_faderbar = true
                        if val/16383 > 0.5 then
                          local bstate = 16383-(tmppos.bstate or 0)
                          local v
                          if tmppos.buttype ~= 6 then
                            if math.floor(bstate)/16383 == 0 then
                              v = track_info[parcode].min
                            else
                              v = track_info[parcode].max                        
                            end
                          else
                            if tmppos.polarity ~= 1 then
                              v = track_info[parcode].max
                            else
                              v = track_info[parcode].min
                            end
                          end
                          if tmppos.buttype == 6 then
                            gmem_wr(lvar.gm_fb.fader_val + (i-1), 16383)
                          else
                            gmem_wr(lvar.gm_fb.fader_val + (i-1), 0)
                          end

                          if tab_trparams_func[tmppos.trparam] then
                            tab_trparams_func[tmppos.trparam](trackD,v,false)
                          else
                            reaper.SetMediaTrackInfo_Value(trackD,parcode,v)
                          end
                          --reaper.SetMediaTrackInfo_Value(trackD,parcode,v)
                          
                          grpreset = true
                          
                        elseif tmppos.buttype == 6 then
                          local bstate = 16383-(tmppos.bstate or 0)
                          local v
                          if tmppos.polarity ~= 1 then
                            v = track_info[parcode].min
                          else
                            v = track_info[parcode].max
                          end
                          --if tmppos.buttype == 6 then
                            gmem_wr(lvar.gm_fb.fader_val + (i-1), 0)
                          --end
                          if tab_trparams_func[tmppos.trparam] then
                            tab_trparams_func[tmppos.trparam](trackD,v,false)
                          else
                            reaper.SetMediaTrackInfo_Value(trackD,parcode,v)
                          end
                          --reaper.SetMediaTrackInfo_Value(trackD,parcode,v)
                          
                          grpreset = true
                        
                        end
                      end]]
                    end
                    
                  elseif tmppos.trsend ~= -1 then
                
                    local snd_type = ((tmppos.trsend-1) % 3) + 1
                    local si = math.floor((tmppos.trsend-1) / 3)
                    
                    local guid = reaper.GetTrackGUID(trackD)
                    local scnt = reaper.GetTrackNumSends(trackD,0) + reaper.GetTrackNumSends(trackD,1)
                    
                    if not tab_SendIdx or not tab_SendIdx[guid] or tab_SendIdx[guid].count ~= scnt then
                      GetSendIdxTable(ttrn)
                    end
                    local snd_idx 
                    if tab_SendIdx[guid][si] then
                      snd_idx = tab_SendIdx[guid][si].idx
                    end
                    
                    if snd_idx and snd_idx <= scnt-1 then
                      if --[[snd_type == 3]] lmode == 4 then
                        
                        if snd_type == 3 then
                        
                          --mute
                          tmppos.val = val
                          tmp.dirty[i] = true
                          lupd.update_faderbar = true
                          if val/16383 > 0.5 then
                            local bstate = 16383-(tmppos.bstate or 0)
                            if tmppos.buttype == 6 then
                              if tmppos.polarity ~= 1 then
                                bstate = 16383
                              else
                                bstate = 0
                              end
                              gmem_wr(lvar.gm_fb.fader_val + (i-1), 16383)
                            else
                              gmem_wr(lvar.gm_fb.fader_val + (i-1), 0)
                            end
                            local hw = 0
                            if tab_SendIdx[guid][si].hw == true then
                              hw = 1
                            else
                              snd_idx = snd_idx - tab_SendIdx[guid].hwcount
                            end
                            reaper.SetTrackSendInfo_Value(trackD,hw,snd_idx,'B_MUTE',math.floor(bstate)/16383)
                            
                            grpreset = true
                          
                          elseif tmppos.buttype == 6 then
                            local bstate = 16383-(tmppos.bstate or 0)
                            if tmppos.buttype == 6 then
                              if tmppos.polarity ~= 1 then
                                bstate = 0
                              else
                                bstate = 16383
                              end
                            end
                            gmem_wr(lvar.gm_fb.fader_val + (i-1), 0)
                            local hw = 0
                            if tab_SendIdx[guid][si].hw == true then
                              hw = 1
                            else
                              snd_idx = snd_idx - tab_SendIdx[guid].hwcount
                            end
                            reaper.SetTrackSendInfo_Value(trackD,hw,snd_idx,'B_MUTE',math.floor(bstate)/16383)
                            
                            grpreset = true
                          end
                          
                        else
                        
                          if val/16383 > 0.5 then
                            if tmppos.buttype ~= 6 then
                              tmppos.val = 0
                            else
                              tmppos.val = val
                            end
                            local bstate
                            if tmppos.butstates == 2 then
                              bstate = round(1-(tmppos.bstate or 0),0)
                            else
                              bstate = (tmppos.bstate or 0)+(1/((tmppos.butstates or 2)-1))
                              if bstate > 1 then
                                bstate = 0
                              end
                            end  
                            
                            local vv = 0
                            if tmppos.buttype ~= 6 then
                              tmppos.bpos = (tmppos.bpos or 0) + 1
                            else
                              if tmppos.polarity ~= 1 then
                                tmppos.bpos = 2 --#tmppos.butstates_array - should it be this?
                              else
                                tmppos.bpos = 1
                              end
                            end
                            if tmppos.bpos > #tmppos.butstates_array then
                              tmppos.bpos = 1
                            end

                            if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                              vv = tmppos.butstates_array[tmppos.bpos]
                            end
                            vv = denormalizetracksend(vv--[[/16383]], snd_type)
                            local func = tab_trsnds_coderec[snd_type] 
                            func(trackD, snd_idx, vv, 0)
                            gmem_wr(lvar.gm_fb.fader_val+(i-1),tmppos.val)
                          
                          elseif tmppos.buttype == 6 then
                            tmppos.val = val
                            local pnum = tmppos.pnum
                            local bstate
                            if tmppos.butstates == 2 then
                              bstate = round(1-(tmppos.bstate or 0),0)
                            else
                              bstate = (tmppos.bstate or 0)+(1/((tmppos.butstates or 2)-1))
                              if bstate > 1 then
                                bstate = 0
                              end
                            end  
                            
                            local vv = 0
                            if tmppos.polarity ~= 1 then
                              tmppos.bpos = 1
                            else
                              tmppos.bpos = 2
                            end
                            if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                              vv = tmppos.butstates_array[tmppos.bpos]
                            end
                            vv = denormalizetracksend(vv--[[/16383]], snd_type)
                            local func = tab_trsnds_coderec[snd_type] 
                            func(trackD, snd_idx, vv, 0)
                            gmem_wr(lvar.gm_fb.fader_val+(i-1),tmppos.val)
                          end
                        end
                      
                        lupd.update_faderbar = true
                        ret = true
                      else
                        if tmppos.polarity ~= 1 then
                          local val = denormalizetracksend(val/16383, snd_type)
                          tmppos.val = val
                          tmp.dirty[i] = true
                          lupd.update_faderbar = true
                          local func = tab_trsnds_coderec[snd_type] 
                          func(trackD, snd_idx, val, 0)
                        else
                          local val2 = 16383-val
                          local val = denormalizetracksend(val2/16383, snd_type)
                          tmppos.val = val
                          tmp.dirty[i] = true
                          lupd.update_faderbar = true
                          local func = tab_trsnds_coderec[snd_type] 
                          func(trackD, snd_idx, val, 0)
                        end
                      end
                    else
                      gmem_wr(lvar.gm_fb.fader_val + (i-1), 0)
                      tmppos.bstate = 1 --force button led off
                    end
                  end
                else --ctl track
                  gmem_wr(lvar.gm_fb.fader_val + (i-1), 0)
                  tmppos.bstate = 1 --force button led off                  
                end
              end
              
            elseif tmppos.ptype == ptype.action then
              if tmppos.actionid then
                local actid = tonumber(tmppos.actionid)
                if actid and actid ~= -1 then
                  tmppos.val = val
                  if val/16383 > 0.5 then

                    tmp.dirty[i] = true
                    lupd.update_faderbar = true

                    --reaper.TrackFX_SetParamNormalized(track, fxnum, (i-1) % 32, 0)

                    if tmppos.buttype ~= 5 then
                      gmem_wr(lvar.gm_fb.fader_val+(i-1),0)
                    end
                    if not tmppos.reptimer or reaper.time_precise() > tmppos.reptimer then 
                      reaper.Main_OnCommand(actid,0)
                      tmppos.reptimer = reaper.time_precise() + lvar.reptimer
                    end
                    
                    if ctl_template.fader[i].ssnum and lvar.readparams and lvar.fadervaluefb and rt >= (tmppos.donotflashscribble or 0) then
                      local dispval = tmppos.name or tmppos.pname
                      if dispval then
                        local dv
                        if tmppos.actionmon == 1 and tmppos.actionid ~= -1 then
                          local actid = tonumber(tmppos.actionid)
                          local val
                          if actid and actid ~= -1 then
                            val = reaper.GetToggleCommandStateEx(0, actid)
                          else
                            val = reaper.GetToggleCommandStateEx(0, reaper.NamedCommandLookup(tmppos.actionid))                
                          end
                          if val ~= -1 then
                            if val == 0 then
                              dv = 'off'
                            else
                              dv = 'on'                            
                            end
                          end
                        end
                        Scribble_FlashVal(i, dv)
                      end
                    end
                    grpreset = true
                  end

                  --[[if tmppos.buttype == 5 and val == 0 then
                    gmem_wr(lvar.gm_fb.fader_val+(i-1),0)
                  end]]
                  tmppos.bstate = 1
                  
                elseif not actid then
                  tmppos.val = val
                  tmp.dirty[i] = true
                  lupd.update_faderbar = true
                  if val/16383 > 0.5 then
                    --reaper.TrackFX_SetParamNormalized(track, fxnum, (i-1) % 32, 0)
                    if tmppos.buttype ~= 5 then
                      gmem_wr(lvar.gm_fb.fader_val+(i-1),0)
                    end
                    
                    if not tmppos.reptimer or reaper.time_precise() > tmppos.reptimer then 
                      reaper.Main_OnCommand(reaper.NamedCommandLookup(tmppos.actionid),0)
                      tmppos.reptimer = reaper.time_precise() + lvar.reptimer
                    end

                    if ctl_template.fader[i].ssnum and lvar.readparams and lvar.fadervaluefb and rt >= (tmppos.donotflashscribble or 0) then
                      local dispval = tmppos.name or tmppos.pname
                      if dispval then
                        local dv
                        if tmppos.actionmon == 1 and tmppos.actionid ~= -1 then
                          local actid = tonumber(tmppos.actionid)
                          local val
                          if actid and actid ~= -1 then
                            val = reaper.GetToggleCommandStateEx(0, actid)
                          else
                            val = reaper.GetToggleCommandStateEx(0, reaper.NamedCommandLookup(tmppos.actionid))                
                          end
                          if val ~= -1 then
                            if val == 0 then
                              dv = 'off'
                            else
                              dv = 'on'                            
                            end
                          end
                        end
                        Scribble_FlashVal(i, dv)
                      end
                    end
                    grpreset = true
                  end
                  tmppos.bstate = 1

                  --[[if tmppos.ledon then
                    SendMIDIFB(i, 127)
                  end]]
                end
                
              end

            elseif tmppos.ptype == ptype.internal then

              if tmppos.code then 
                --if tmppos.code == 1 then
                local skip
                if lmode ~= 4 then
                  skip = true
                  if lmode ~= 0 then

                    --relative
                    --local rel = gmem(lvar.gm_fb.fader_relative+(i-1))
                    if rel ~= 0 or (rel == 0 and tostring(round((tmppos.val or 0),0)) ~= tostring(val) 
                       and tmppos.code == 18 and tmppos.codeval <= lvar.qfx_faders) then
                      --Special case for qfx faders
                      
                      tmp.dirty[i] = true
                      tmppos.internal_val = val
                      --tmppos.val = val
                      ProcessInternal(tmppos,i,rel)
  
                      --lvar.readparams = nil
                      --lvar.readparams2 = nil
                                      
                      gmem_wr(lvar.gm_fb.fader_relative+(i-1),0)
                      gmem_wr(lvar.gm_fb.fader_val+(i-1),val)
                    end
                  
                  elseif lvar.PI_Cont[(tmppos.code << 16)+tmppos.codeval] then 
                    --continuous
                    if tmppos.polarity == 1 then
                      tmppos.internal_val = 16383-val
                    else
                      tmppos.internal_val = val
                    end
                    gmem_wr(lvar.gm_fb.fader_val+(i-1),val)
                    ProcessInternal(tmppos,i)                    
                  
                  else
                    --continuous but treat as on/off button
                    skip = nil                    
                  end
                
                end
                
                if lmode == 4 or not skip then
                  tmppos.val = 0
                  --DBG(tmppos.buttype..'  '..val)
                  if val/16383 > 0.5 then
                    local fixstate
                    if tmppos.buttype == 6 then
                      gmem_wr(lvar.gm_fb.fader_val+(i-1),16383)
                      tmppos.val = 16383
                      if tmppos.polarity ~= 1 then
                        fixstate = 1
                      else
                        fixstate = 0
                      end
                    else--if tmppos.buttype ~= 5 then
                      gmem_wr(lvar.gm_fb.fader_val+(i-1),0)
                    end
                    if not tmppos.reptimer or reaper.time_precise() > tmppos.reptimer then 
                      
                      local bstate
                      if tmppos.butstates == 2 then
                        bstate = fixstate or round(1-(tmppos.bstate or 0),0)
                      else
                        bstate = fixstate or (tmppos.bstate or 0)+(1/((tmppos.butstates or 2)-1))
                        if bstate > 1 then
                          bstate = 0
                        end
                      end  
                      
                      local vv, vv2 = 0, 0
                      if tmppos.code == 5 then
                        tmppos.bpos = (tmppos.bpos or 1) + 1
                      else
                        tmppos.bpos = (tmppos.bpos or 0) + 1
                      end
                      if tmppos.bpos > tmppos.butstates --[[#tmppos.butstates_array]] then
                        tmppos.bpos = 1
                      end
                      if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                        vv = tmppos.butstates_array[tmppos.bpos]
                        vv2 = tmppos.butstates_array_ext[tmppos.bpos]
                      end
                      --DBG(tmppos.butstates..'  '..#tmppos.butstates_array)
                      tmppos.internal_val = vv or 0
                      tmppos.internal_val2 = vv2 or 0
                      
                      tmp.dirty[i] = true
                      tmppos.bstate = bstate
                      
                      ProcessInternal(tmppos,i)

                      --lvar.readparams = nil
                      lvar.readparams2 = nil

                      lupd.update_forceflash = true
                      tmppos.reptimer = reaper.time_precise() + lvar.reptimer
                    end
                    
                    grpreset = true
                    
                  elseif tmppos.buttype == 6 then
                    local fixstate
                    tmppos.val = 0
                    if tmppos.polarity ~= 1 then
                      fixstate = 0
                    else
                      fixstate = 1
                    end
                    gmem_wr(lvar.gm_fb.fader_val+(i-1),0)
                    --if not tmppos.reptimer or reaper.time_precise() > tmppos.reptimer then 
                      
                      local bstate
                      if tmppos.butstates == 2 then
                        bstate = fixstate or round(1-(tmppos.bstate or 0),0)
                      else
                        bstate = fixstate or (tmppos.bstate or 0)+(1/((tmppos.butstates or 2)-1))
                        if bstate > 1 then
                          bstate = 0
                        end
                      end  
                      
                      local vv, vv2 = 0, 0
                      if tmppos.code == 5 then
                        tmppos.bpos = (tmppos.bpos or 1) + 1
                      else
                        tmppos.bpos = (tmppos.bpos or 0) + 1
                      end
                      if tmppos.bpos > tmppos.butstates --[[#tmppos.butstates_array]] then
                        tmppos.bpos = 1
                      end
                      if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                        vv = tmppos.butstates_array[tmppos.bpos]
                        vv2 = tmppos.butstates_array_ext[tmppos.bpos]
                      end
                      
                      tmppos.internal_val = vv or 0
                      tmppos.internal_val2 = vv2 or 0
                      
                      tmp.dirty[i] = true
                      tmppos.bstate = bstate
                      ProcessInternal(tmppos,i)

                      --lvar.readparams = nil
                      lvar.readparams2 = nil

                      lupd.update_forceflash = true
                    --  tmppos.reptimer = reaper.time_precise() + lvar.reptimer
                    --end
                    
                    grpreset = true
                  
                  end          
                end
              end
              
            elseif track3 then
              --CCs
              if ctl_template.fader[i].lmode == 4 --[[and tmppos.val ~= 0]] then
                
                tmppos.bpos = reaper.gmem_read(lvar.gm_fb.fbutstate+(i-1))
                if val ~= 0 then
                  reaper.gmem_write(lvar.gm_fb.fader_val +(i-1),0)
                  tmp.dirty[i] = true
                  tmppos.val = 0
                end
                
                fbvals[i] = val
                
                lupd.update_faderbar = true

              elseif tmppos.val ~= val then
                --DBG(tostring(tmppos.val)..'  '..tostring(val))
 
                tmppos.val = val
                --SetCCVal(i, val)
                if fbactive == 1 and not lvar.fbcconseek then
                  fbvals[i] = val
                  SendMIDIFB(i,val>>7, val & 127)
                end
                
                --DBG(val)
                --gmem(lvar.gm_fb.fset+(i-1),math.floor((math.min(val,16383)/16383)*16383)|16384)
                
                --reaper.gmem_write(lvar.gm_fb.fader_val +(i-1),val)
                --if ctl_template.fader[i].lmode == 0 then
                  tmp.dirty[i] = true
                  lupd.update_faderbar = true
                --end
              end
              ret = true
            end
          
          --[[else
            if not tmppos and (val or 0) ~= 0 then
              gmem_wr(lvar.gm_fb.fader_val+(i-1),0)
            end]]
            tmppos.scribgui = true
            if lvar.overtemp_latchreturn and not lvar.latchreturn_set and lmode == 4 and tmppos.buttype ~= 5 then
              lvar.overtemplate = lvar.overtemp_latchreturn
              lvar.overtemplate_active = lvar.overtemp_latchreturn_active
              TemplateChanged()
              lvar.overtemp_latchreturn = nil
              lvar.overtemp_latchreturn_active = nil
              lupd.update_gfx = true 
            end 
          
          --elseif tmppos and track3 and lmode == 4 and tmppos.ptype == ptype.cc then
            --deal with cc buttons
          
            --[[tmppos.val = val
            fbvals[i] = val
            tmp.dirty[i] = true
            
            lupd.update_faderbar = true
            ret = true]]
            
          end
      
          
          --if ctl_template.fader[i] and ctl_template.fader[i].lmode == 4 and (val or 0) ~= 0 then
            --force buttons to 0
            --gmem_wr(lvar.gm_fb.fader_val+(i-1),0)
          --end
          if grpreset then
            if lvar.groupctlidx2[lvar.groupidx[lvar.ctlgroup_select]] and lvar.groupctlidx2[lvar.groupidx[lvar.ctlgroup_select]][i] then
              lvar.grpflash_timer = reaper.time_precise()+0.3
            end
          end
        end
        
        lvar.rrplaystate = playstate
      end
    
      if lvar.cclatch == true and cctouch == false and not (playstate&1==1 or playstate&4==4) then
        lvar.cclatch = false
      end
    end
    
    --DBGOut('exit func: GetFaderBoxVals')
    return ret
    
  end

  function FlipParams_Tmp(tmp)

    for i = 1, #ctl_template.flip do
      local f1 = ctl_template.flip[i].f1
      local f2 = ctl_template.flip[i].f2

      --flip layer
      for l = 1, lvar.overtmp_cnt do
        if tmp.layer and tmp.layer[l] then
          local tmp2 = tmp.layer[l]
          if tmp2 then
            local cpy = tmp2.pos[f1]
            tmp2.pos[f1] = tmp2.pos[f2]
            tmp2.pos[f2] = cpy
          end            
        end
      end
      
      if tmp then
        local cpy = tmp.pos[f1]
        tmp.pos[f1] = tmp.pos[f2]
        tmp.pos[f2] = cpy
        
      end
    end
      
  end
  
  function FlipParams()
    lvar.readparams = nil
    lvar.flip = 1 - lvar.flip

    for i = 1, #ctl_template.flip do
      local f1 = ctl_template.flip[i].f1
      local f2 = ctl_template.flip[i].f2

      --flip stripper overlay ???
      local tmp
      tmp = strippertemplate
      
      if tmp then
        local cpy = tmp.pos[f1]
        tmp.pos[f1] = tmp.pos[f2]
        tmp.pos[f2] = cpy
        
      end

      --flip takeover ???
      --local tmp
      tmp = totemplate
      
      if tmp then
        local cpy = tmp.pos[f1]
        tmp.pos[f1] = tmp.pos[f2]
        tmp.pos[f2] = cpy
        
      end

      --flip globals      
      tmp = globtemplate
      
      if tmp then
        local cpy = tmp.pos[f1]
        tmp.pos[f1] = tmp.pos[f2]
        tmp.pos[f2] = cpy
        
      end

      --flip layer
      for l = 1, lvar.overtmp_cnt do
        if template.layer and template.layer[l] then
          tmp = template.layer[l]
          if tmp then
            local cpy = tmp.pos[f1]
            tmp.pos[f1] = tmp.pos[f2]
            tmp.pos[f2] = cpy
          end            
        end
      end
            
      --flip normal
      tmp = template
      if tmp then
        local cpy = tmp.pos[f1]
        tmp.pos[f1] = tmp.pos[f2]
        tmp.pos[f2] = cpy
        
      end
      
      if recmode == 1 then
        REC_EnvelopeData_SlipAssignments(true, true)
      end            
    end
    lupd.update_gfx = true
    TemplateChanged()
    updatetravellingtracknames(true)
  
  end
  
  function SetCCVal(i, v, track, tmp)
  
     if LBX_CC_TRACK then
      local track = track or GetTrack(LBX_CC_TRACK)
      if track then
        local tmppos
        if tmp then
          tmppos = tmp.pos[i]
        end
        v = math.floor(v*16383)
        if tmppos.polarity == 1 then
          v = 16383-v
        end
        reaper.gmem_write(lvar.man_val,(v&16256)/16256)
        reaper.gmem_write(lvar.man_msg,tmp.pos[i].ccnum)
        reaper.gmem_write(lvar.man_send,1)
        if tmppos and tmppos.ptype == ptype.cc and tmppos.cc14bit == 1 then
          reaper.gmem_write(lvar.man_val2,(v&127)/127)
          reaper.gmem_write(lvar.man_send2,1)
        end
        --reaper.TrackFX_SetParamNormalized(track, 0, 11, v)
      end
    end
  end
  
  function DBGTab(t)
    if t==nil then t="nil" end
    for i = 1, #t do
      reaper.ShowConsoleMsg(tostring(t[i])..' ')
    end
    reaper.ShowConsoleMsg('\n')
  end        
   
  ------------------------------------------------------------
      
  local function f_Get_SSV(s)
    if not s then return end
    local t = {}
    for i in s:gmatch("[%d%.]+") do 
      t[#t+1] = tonumber(i) / 255
    end
    gfx.r, gfx.g, gfx.b = t[1], t[2], t[3]
    lvar.current_colour = s
  end

  local function f_Get_SSV_dim(s, p)
    if not s then return end
    local t = {}
    for i in s:gmatch("[%d%.]+") do 
      t[#t+1] = tonumber(i) / 255
    end
    gfx.r, gfx.g, gfx.b = t[1]*p, t[2]*p, t[3]*p
  end

  local function Color_dim(s, p)
    if not s then return end
    local t = {}
    for i in s:gmatch("[%d%.]+") do 
      t[#t+1] = tonumber(i)
    end
    return string.format('%i',math.floor(t[1]*p))..' '..string.format('%i',math.floor(t[2]*p))..' '..string.format('%i',math.floor(t[3]*p))
  end
  
  local function f_Get_SSV_fade(s1, s2, p)
    if not s1 or not s2 then return end
    local t, d = {}, {}
    for i in s1:gmatch("[%d%.]+") do 
      t[#t+1] = tonumber(i) / 255
    end
    for i in s2:gmatch("[%d%.]+") do
      local x = #d+1 
      d[x] = (tonumber(i) / 255) - t[x]
    end
    gfx.r, gfx.g, gfx.b = t[1]+d[1]*p, t[2]+d[2]*p, t[3]+d[3]*p
  end
  ------------------------------------------------------------
    
  local function GUI_text(gui, xywh, text, flags, col, tsz, flags2, padx, justifyiftoobig, zoom, zoomlimit, multiline, allowshrink, forcemultiline)

    if col == nil then col = gui.color.white end
    if tsz == nil then tsz = 0 end
    
    f_Get_SSV(col)  
    gfx.a = 1
    --[[local zmdiv = (lvar.guizoom-1)*5
    local nzm = 1
    repeat
      nzm = (1+(lvar.guizoom-1)/zmdiv)
      gfx.setfont(1, gui.fontname, (gui.fontsz_knob+tsz)*nzm, flags2)
      DBG('REAPER')
      zmdiv = zmdiv - (lvar.guizoom-1)
    until gfx.measurestr(text) < xywh.w or zmdiv > (lvar.guizoom-1)
    DBG((gui.fontsz_knob+tsz)*nzm..'  '..nzm)
    ]]
    local fo = lvar.fontoffset
    local nzm = 0
    local zoom = zoom or (math.min(lvar.fontzoom,zoomlimit or lvar.fontzoom))
    if zoom then
      nzm = (zoom-1) * (gui.fontsz_knob+tsz)/2
    end
    gfx.setfont(1, gui.fontname, (gui.fontsz_knob+tsz)+nzm, flags2)
    local ml
    local ww = xywh.w-(padx or 0)*2-4
    if multiline and gfx.measurestr(text) > ww then
      local tab = mysplit(text,'%s')
      if #tab > 1 then

        local tabline = {}
        local tl, maxh, maxline = 1, 0, 1
        for i = 1, #tab do
          if tabline[tl] and gfx.measurestr(tabline[tl].text ..' '.. tab[i]) <= ww then
            local _, h = gfx.measurestr(tabline[tl].text ..' '.. tab[i])
            tabline[tl] = {text = tabline[tl].text ..' '.. tab[i], h = h}
            maxh = math.max(maxh, h)
          elseif not tabline[tl] then
            local _, h = gfx.measurestr(tab[i])
            tabline[tl] = {text = tab[i], h = h}
            maxh = math.max(maxh, h)
          else
            local _, h = gfx.measurestr(tab[i])
            tl = tl + 1
            tabline[tl] = {text = tab[i], h = h}
            maxh = math.max(maxh, h)
          end
        end
        maxh = maxh - 2
        if maxh * #tabline < xywh.h then
          ml = true
          local y = math.floor(xywh.y + (xywh.h / 2) - ((maxh * #tabline) / 2))
          local nw = xywh.w - (padx or 0)*2
          for i = 1, #tabline do
          
            gfx.x, gfx.y = xywh.x+(padx or 0), y+fo
            local text = tabline[i].text
            --[[if justifyiftoobig then
              local tx = gfx.measurestr(text)
              if tx > nw - 4 then
                flags = justifyiftoobig or 4
              end 
              gfx.drawstr(text, flags, xywh.x+nw, y+maxh)
            else]]
              gfx.drawstr(text, flags, xywh.x+nw, y+maxh+fo)
            --end
            y = y + maxh
          end
        elseif forcemultiline then
          ml = true
          local maxline = 1
          for i = 2, #tabline do
            if i * maxh < xywh.h then
              maxline = i
            else
              break
            end
          end
          local y = math.floor(xywh.y + (xywh.h / 2) - ((maxh * maxline) / 2))
          local nw = xywh.w - (padx or 0)*2
          for i = 1, maxline do
          
            gfx.x, gfx.y = xywh.x+(padx or 0), y+fo
            --if i * maxh < xywh.h then
              local text = tabline[i].text
              --[[if justifyiftoobig then
                local tx = gfx.measurestr(text)
                if tx > nw - 4 then
                  flags = justifyiftoobig or 4
                end 
                gfx.drawstr(text, flags, xywh.x+nw, y+maxh)
              else]]
                gfx.drawstr(text, flags, xywh.x+nw, y+maxh+fo)
              --end
              y = y + maxh
            --else
            --  break
            --end
          end
        
        end
      end
    end
    --[[if zoom then
      local sub = 0
      while gfx.measurestr(text) > xywh.w-6 and sub < nzm do
        sub = math.min(sub + 1, nzm)
        gfx.setfont(1, gui.fontname, (gui.fontsz_knob+tsz)+nzm - sub, flags2)
      end
    end]]
    --local text_len = gfx.measurestr(text)
    if not ml then
      if allowshrink then
        local sub = 0
        while gfx.measurestr(text) > ww and sub < nzm do
          sub = math.min(sub + 1, nzm)
          gfx.setfont(1, gui.fontname, (gui.fontsz_knob+tsz)+nzm - sub, flags2)
        end
      end
      gfx.x, gfx.y = xywh.x+(padx or 0),xywh.y+fo
      local nw = xywh.w - (padx or 0)
      if justifyiftoobig then
        local tx = gfx.measurestr(text)
        if tx > nw - 4 then
          flags = justifyiftoobig or 4
        end 
        gfx.drawstr(text, flags, xywh.x+nw, xywh.y+xywh.h+fo)
      else
        gfx.drawstr(text, flags, xywh.x+nw, xywh.y+xywh.h+fo)
      end
    end
  end
  
  function GUI_DrawOverlay(obj, gui)
  
    local iidx = lvar.bmp.overlay
    local data = lvar.display_overlay
    --local dataidx = lvar.display_overlay_idx
    local dc = #data
    
    gfx.dest = iidx
    local ww = math.min(300, gfx1.main_w-20)
    gfx.setimgdim(iidx, -1, -1)
    gfx.setimgdim(iidx, ww, dc * 70)
    
    dflag = 0
    local xywh = {x = 0, y = 0, w = ww, h = 30}
    for d = 1, dc do
      --DBG(data .. '  '..dd)
      if data[d] then
     
        xywh.y = (d-1)*70 + 4
        f_Get_SSV('0 0 0') --colours.buttcol--[[colours.mainbg]])
        gfx.a = 0.9
        gfx.rect(0,(d-1)*70,ww,60,1)
        gfx.a = 1
        --[[gfx.x = 0
        gfx.y = (d-1)*70
        gfx.blurto(ww,(d)*70)
        gfx.x = 0
                gfx.y = (d-1)*70
                gfx.blurto(ww,(d)*70)]]
        --local col = gui.color.white
        --if data[d].sscolor > 0 then
        local col = tab_xtouch_colors[data[d].sscolor % 64].c
        --end
        f_Get_SSV(col)
        gfx.rect(2,(d-1)*70+2,ww-4,60-4,0)
        -- DBG(data[d].gmr)
        if data[d].gmr == 1 then
          f_Get_SSV('255 0 0')
          gfx.rect(4,(d-1)*70+4,8,8,1)      
        end
        GUI_text(gui, xywh, data[d].str, 5, col, 2)
        xywh.y = xywh.y + 22
        GUI_text(gui, xywh, data[d].str2, 5, col, 5)
        xywh.y = xywh.y + 30
        
      end
    end
    
  end
  
  ------------------------------------------------------------
  
  local function GUI_draw(obj, gui)
    
    --lvar.update_dest1 = true
    --[[if lupd.update_gfx then
    DBG(lupd.update_gfx)
    end]]
    --DBG(lupd.update_faderbar)
    --DBG(next(lupd))
    gfx.mode = 4
    gfx.dest = 1

    if lupd.update_gfx or lupd.resize_display then    
      gfx.setimgdim(1, -1, -1)  
      gfx.setimgdim(1, gfx1.main_w,gfx1.main_h)
      
      f_Get_SSV(colours.mainbg)
      gfx.rect(0,
               0,
               gfx1.main_w,
               gfx1.main_h, 1)  
    end
    
    local maplocked
    if lvar.livemode == 0 or lvar.livemode == 2 or lvar.livemode == 3 or lvar.livemode == 4 or lvar.livemode == 5 then
      if lupd.update_gfx or lupd.update_fader or lupd.update_faderbar or lupd.update_header then    

        if lupd.update_gfx or lupd.update_header then
          GUI_DrawFXHeader(obj, gui)
          GUI_DrawButtons(obj, gui)
        end
        --DBG(math.random(1))
        GUI_DrawFaders(obj, gui)
  
      end
      if lvar.display_overlay_active then
        if lupd.update_overlay then
          GUI_DrawOverlay(obj, gui)
        end
      end
      
      if reaper.gmem_read(lvar.props.visible) ~= 0 then
        maplocked = true
      end
      
      if LBX_CTL_TRACK == nil then
      
        xywh = {x = obj.sections[4].x, y = obj.sections[4].y, w = obj.sections[1].x+obj.sections[1].w-obj.sections[4].x, h = obj.sections[4].h}
        GUI_DrawButton(gui, xywh, 'CONTROL TRACK NOT FOUND', '25 25 25', '255 0 0', true, 4)
      
      end
    
      if lvar.msg then
        GUI_DrawButton(gui, obj.sections[400], lvar.msg, '25 25 25', '255 0 0', true, 4)
        f_Get_SSV('255 0 0')
        gfx.rect(obj.sections[400].x,
                 obj.sections[400].y,
                 obj.sections[400].w,
                 obj.sections[400].h, 0)  
                
      end
    
    end
    
    if lvar.livemode ~= 0 then
      if lvar.livemode == 1 then        
        if lupd.update_gfx then
          if lvar.midifilteredit then
            --GUI_DrawSetUp(obj, gui)
            GUI_DrawMIDIFiltSetUp(obj, gui)
            
            yoff = -lvar.SetupOffs        
            gfx.blit(2,1,0,0,yoff,gfx1.main_w,gfx1.main_h,0,0)
            gfx.blit(3,1,0,0,0,obj.sections[10000].w,obj.sections[10000].h,obj.sections[10000].x,obj.sections[10000].y)
          else
            GUI_DrawSetUp(obj, gui)
            yoff = -lvar.SetupOffs        
            gfx.blit(2,1,0,0,yoff,gfx1.main_w,gfx1.main_h,0,0)
            
            --SB
            local gh = gfx1.main_h - 4
            local swh = (obj.sections[100].y + obj.sections[100].h + 30)
            local max = -math.min(gfx1.main_h-swh,0)
            local sbh = math.min((gh/swh)*gh,gh)
            local sby = 2 + (-lvar.SetupOffs/max)*(gh-sbh)
            --DBG(sby..'  '..max..'  '..sbh..'  '..gh..'  '..swh..'  '..lvar.SetupOffs)
            if mouse.context == contexts.vscrollb or lvar.hlsb then
              f_Get_SSV(colours.buttcollit)
            else
              f_Get_SSV(colours.faderbg2)
            end
            gfx.rect(gfx1.main_w-8,
                     sby,
                     6,
                     sbh, 1)      
          end   
        end
      elseif lvar.livemode == 2 then
        GUI_DrawColorSelector(obj, gui)
      elseif lvar.livemode == 3 then
        GUI_DrawGroupSetUp(obj, gui)
      elseif lvar.livemode == 4 then
        GUI_DrawTags(obj, gui)
      elseif lvar.livemode == 5 then
        GUI_DrawTagSlots(obj, gui)
      end
    end    
    
    --if lvar.update_dest1 == true then

    gfx.dest = -1
    if lvar.mainfade then
      GUI_DrawMsg(obj, gui, nil, nil, true) 
      gfx.dest = -1
      local aa = inSine(math.min(1-(lvar.mainfade-reaper.time_precise()) / lvar.mainfade_time,1))
      if aa >= 1 then
        lvar.mainfade = nil
        aa = 1
      end
      gfx.a = aa
    else
      gfx.a = 1
    end
    gfx.blit(1, 1, 0, 
      0,0, gfx1.main_w,gfx1.main_h,
      0,0, gfx1.main_w,gfx1.main_h, 0,0)
    
    if maplocked then
      f_Get_SSV('160 0 0')
      gfx.rect(math.floor(obj.sections[10018].x),
                math.floor(obj.sections[10018].y),
                math.floor(obj.sections[10018].w),
                math.floor(obj.sections[10018].h-4), 0)
    end
    lvar.maplocked = maplocked
    
    if lvar.display_overlay_active then
      local data = lvar.display_overlay
      local oc = #data
      if oc > 0 then
        --DBG(#lvar.display_overlay)
        local w, h = gfx.getimgdim(lvar.bmp.overlay)
        local x = math.floor((gfx1.main_w/2)-(w/2))
        --local y = math.floor((gfx1.main_h/2)-(30) - 70*math.floor((oc-1) / 2))
        --local y = obj.sections[50].y + 10
        local y = gfx1.main_h - oc*70 - 10
        local tt = 0.5
        local tti = 0.15
        local hold = lvar.display_overlay_hold
        for d = oc, 1, -1 do
        
          gfx.a = 1
          local data2 = data[d]
          if reaper.time_precise() > data2.timeout-tt then
          --DBG(reaper.time_precise() - (data[d].timeout-0.8))
            local a = math.max(tt-(reaper.time_precise() - (data2.timeout-tt)),0)*(1/tt)
            gfx.a = a
          elseif reaper.time_precise() < data2.ontime+tti then
            local a = ((data2.ontime+tti) - reaper.time_precise())/tti
            gfx.a = 1-a
          end
        
          local yo = (d-1)*70
          local yy = y + ((oc-1)*70)-yo
          
          gfx.blit(lvar.bmp.overlay,1,0,0,yo,w,70,x,yy)
                  
        end
        --[[
        
        local w, h = gfx.getimgdim(lvar.bmp.overlay)
        local x = math.floor((gfx1.main_w/2)-(w/2))
        local y = math.floor((gfx1.main_h/2)-(30) - 70*math.floor(oc / 2))
        gfx.blit(lvar.bmp.overlay,1,0,0,0,w,h,x,y)]]
      end
    end
    --end
    
    --[[lupd.update_gfx = false
    lupd.update_dialog = false
    lupd.update_fader = false
    lupd.update_faderbar = false
    lupd.update_header = false
    lupd.update_forceflash = false
    lupd.resize_display = false
    lupd.update_overlay = false]]
  
  if next(lupd) ~= nil then
    gfx.update()  
  end
  lupd = {}
    
  end

  function GUI_DrawGroupSetUp(obj, gui)

    gfx.dest = 1
    f_Get_SSV('0 0 0')
    gfx.rect(obj.sections[300].x-3,
             obj.sections[300].y-3,
             obj.sections[300].w+6,
             obj.sections[300].h+6,1)
    f_Get_SSV(colours.mainbg)
    gfx.rect(obj.sections[300].x,
             obj.sections[300].y,
             obj.sections[300].w,
             obj.sections[300].h,1)

    local xywh = {x = obj.sections[300].x, y = obj.sections[301].y-butt_h-10, w = obj.sections[300].w, h = butt_h}
    GUI_text(gui, xywh, 'GROUP HIGHLIGHT (ON ACTIVATE)', 5, '205 205 205', -1, nil, nil, nil, nil, nil, nil, true)
    
    local c, tc = colours.buttcol, '205 205 205'
    GUI_DrawButton(gui, obj.sections[301], groupind_tab[lvar.groupind[1].type+1], c, tc, true, 0, 'Type', tc, 0, nil, true)
    GUI_DrawButton(gui, obj.sections[302], lvar.groupind[1].rep, c, tc, true, 0, 'Repeats', tc, 0, nil, true)
    GUI_DrawButton(gui, obj.sections[303], lvar.groupind[1].on, c, tc, true, 0, 'On time', tc, 0, nil, true)
    GUI_DrawButton(gui, obj.sections[304], lvar.groupind[1].off, c, tc, true, 0, 'Off time', tc, 0, nil, true)

    local txt = 'INVERT'
    if lvar.groupind[1].invert == 1 then
      c, tc = '205 205 205', colours.buttcol
    end
    GUI_DrawButton(gui, obj.sections[309], txt, c, tc, true, 0, nil, nil, nil, nil, true)

    local xywh = {x = obj.sections[300].x, y = obj.sections[305].y-butt_h-10, w = obj.sections[300].w, h = butt_h}
    GUI_text(gui, xywh, 'GROUP HIGHLIGHT (WHEN ACTIVE)', 5, '205 205 205', -1, nil, nil, nil, nil, nil, nil, true)

    local c, tc = colours.buttcol, '205 205 205'
    GUI_DrawButton(gui, obj.sections[305], groupind_tab[lvar.groupind[2].type+1], c, tc, true, 0, 'Type', tc, 0, nil, true)
    --GUI_DrawButton(gui, obj.sections[306], lvar.groupind[2].rep, c, tc, true, 0, 'Repeats', tc, 0)
    GUI_DrawButton(gui, obj.sections[307], lvar.groupind[2].on, c, tc, true, 0, 'On time', tc, 0, nil, true)
    GUI_DrawButton(gui, obj.sections[308], lvar.groupind[2].off, c, tc, true, 0, 'Off time', tc, 0, nil, true)
    
    local txt = 'INVERT'
    if lvar.groupind[2].invert == 1 then
      c, tc = '205 205 205', colours.buttcol
    end
    GUI_DrawButton(gui, obj.sections[310], txt, c, tc, true, 0, nil, nil, nil, nil, true)

    local c, tc = colours.buttcol, '205 205 205'
    GUI_DrawButton(gui, obj.sections[311], 'TEST', c, tc, true, 0, nil, nil, nil, nil, true)
    
  end

  function GUI_DrawTags(obj, gui)
  
    if lupd.update_gfx or lupd.update_tags then
    
      gfx.dest = lvar.bmp.tags
      if lupd.update_gfx then
        --gfx.setimgdim(lvar.bmp.tags, -1, -1)
        gfx.setimgdim(lvar.bmp.tags, obj.sections[2000].w, obj.sections[2000].h)

        f_Get_SSV('0 0 0')
        gfx.rect(0,
                 0,
                 obj.sections[2000].w,
                 obj.sections[2000].h,1)
      end

      f_Get_SSV('0 0 0')
      gfx.rect(obj.sections[2001].x,
               obj.sections[2001].y,
               obj.sections[2001].w,
               obj.sections[2001].h,1)
      
      f_Get_SSV('99 99 99')
      gfx.rect(obj.sections[2001].x,
               obj.sections[2001].y,
               obj.sections[2001].w,
               obj.sections[2001].h,0)
      
      GUI_text(gui, obj.sections[2001], lvar.tags.filter or '', 5, '99 99 99', 5)

      --draw filtered tag list

      f_Get_SSV('0 0 0')
      gfx.rect(obj.sections[2002].x,
               obj.sections[2002].y,
               obj.sections[2002].w,
               obj.sections[2002].h,1)

      local ftags = lvar.tagfilt
      local rows = math.floor(obj.sections[2002].h / butt_h)
      local xywh = {x = obj.sections[2002].x,
                    y = obj.sections[2002].y,
                    w = obj.sections[2002].w,
                    h = butt_h}
      for i = 1, rows do
        local ii = (i) + ftags.offset
        if ftags[ii] then

          local c = '99 99 99'
          if ftags[ii].tag == lvar.tagfilt.selected then
            c = '205 205 205'
          end
          GUI_text(gui, xywh, ftags[ii].tag, 5, c, 5)
          if lvar.tags.tags[ftags[ii].tag] and lvar.tags.tags[ftags[ii].tag].slot and lvar.tags.tags[ftags[ii].tag].slot ~= '' then
            GUI_text(gui, xywh, 'SLOT', 6, c, -2)
          end
          
        else
          break
        end
        xywh.y = xywh.y + butt_h
      end

      gfx.dest = 1
      gfx.blit(lvar.bmp.tags,1,0,0,0,obj.sections[2000].w,obj.sections[2000].h,obj.sections[2000].x,obj.sections[2000].y)
      
    end

  end

  function GUI_DrawTagSlots(obj, gui)
  
    if lupd.update_gfx or lupd.update_tags then
    
      gfx.dest = lvar.bmp.tags
      if lupd.update_gfx then
        --gfx.setimgdim(lvar.bmp.tags, -1, -1)
        gfx.setimgdim(lvar.bmp.tags, obj.sections[2000].w, obj.sections[2000].h)

        f_Get_SSV('0 0 0')
        gfx.rect(0,
                 0,
                 obj.sections[2000].w,
                 obj.sections[2000].h,1)
      end

      f_Get_SSV('0 0 0')
      gfx.rect(obj.sections[2001].x,
               obj.sections[2001].y,
               obj.sections[2001].w,
               obj.sections[2001].h,1)
      
      f_Get_SSV('99 99 99')
      gfx.rect(obj.sections[2001].x,
               obj.sections[2001].y,
               obj.sections[2001].w,
               obj.sections[2001].h,0)
      
      GUI_text(gui, obj.sections[2001], lvar.tagslots.tag, 5, '99 99 99', 5)

      --draw filtered tag list

      f_Get_SSV('0 0 0')
      gfx.rect(obj.sections[2002].x,
               obj.sections[2002].y,
               obj.sections[2002].w,
               obj.sections[2002].h,1)

      local tagslots = lvar.tagslots
      local rows = math.floor(obj.sections[2002].h / butt_h)
      local xywh = {x = obj.sections[2002].x,
                    y = obj.sections[2002].y,
                    w = obj.sections[2002].w,
                    h = butt_h}
      for i = 1, math.min(rows,32) do
        local ii = (i) + tagslots.offset
        if tagslots[ii] then

          local c = '99 99 99'
          if tagslots[ii].selected == true then
            c = '205 205 205'
          end
          GUI_text(gui, xywh, tagslots[ii].name, 5, c, 5)
        else
          break
        end
        xywh.y = xywh.y + butt_h
      end

      gfx.dest = 1
      gfx.blit(lvar.bmp.tags,1,0,0,0,obj.sections[2000].w,obj.sections[2000].h,obj.sections[2000].x,obj.sections[2000].y)
      
    end

  end
  
  
  function GUI_DrawColorSelector(obj, gui)
  
    gfx.dest = 1
    f_Get_SSV('0 0 0')
    gfx.rect(obj.sections[201].x-3,
             obj.sections[201].y-3,
             obj.sections[201].w+6,
             obj.sections[201].h+6,1)
    f_Get_SSV(colours.mainbg)
    gfx.rect(obj.sections[201].x,
             obj.sections[201].y,
             obj.sections[201].w,
             obj.sections[201].h,1)
    
    --left side
    
    local btnsize = lvar.colorsel_btnsize
    local xywh = {x = math.floor(obj.sections[200].x + obj.sections[200].w/2 - lvar.colorsel_btnsize_w/2),
                  y = obj.sections[200].y + 20,
                  w = lvar.colorsel_btnsize_w,
                  h = btnsize}
    for i = 1, #ptype_info do
    
      f_Get_SSV(ptype_info[i].col)
      gfx.rect(xywh.x,
               xywh.y,
               xywh.w,
               xywh.h,1)
    
      ccv = ptype_txt[i]
      GUI_text(gui, xywh, ccv, 5, ptype_info[i].btntxt, ptype_info[i].tsz, nil, nil, nil, nil, nil, nil, true)
      xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
      
    end

    f_Get_SSV(colours.mainfader)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'MAIN LAYER', 5, colours.mainfader_txt, -5, nil, nil, nil, nil, nil, nil, true)
    
    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(colours.layerfader)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'OVERLAY LAYER', 5, colours.layerfader_txt, -5, nil, nil, nil, nil, nil, nil, true)
    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(colours.globalfader)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'GLOBAL', 5, colours.globalfader_txt, -5, nil, nil, nil, nil, nil, nil, true)
    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(colours.permafader)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'PERMANENT', 5, colours.permafader_txt, -5, nil, nil, nil, nil, nil, nil, true)
    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(colours.faderunassigned)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, '-', 5, colours.faderunassigned_txt, -2, nil, nil, nil, nil, nil, nil, true)
    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(colours.mainbg)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'MAIN BG', 5, colours.faderunassigned_txt, -2, nil, nil, nil, nil, nil, nil, true)
    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(colours.buttcol)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'BTN OFF/ON', 5, colours.buttcollit, -5, nil, nil, nil, nil, nil, nil, true)

    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(colours.devctlunassigned)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'DEV SLOT UNASS', 5, colours.devctlname, -6, nil, nil, nil, nil, nil, nil, true)

    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(colours.devctlassigned)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'DEV SLOT', 5, colours.faderunassigned_txt, -5, nil, nil, nil, nil, nil, nil, true)

    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(colours.faderbg2)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w/2,
             xywh.h,1)
    f_Get_SSV(colours.faderborder)
    gfx.rect(xywh.x+xywh.w/2,
             xywh.y,
             xywh.w/2,
             xywh.h,1)
    GUI_text(gui, xywh, 'FDR BG/BORDER', 5, colours.faderunassigned_txt, -6, nil, nil, nil, nil, nil, nil, true)

    
    --right side
    local xywh = {x = math.floor(obj.sections[202].x + obj.sections[202].w/2 - lvar.colorsel_btnsize_w/2),
                  y = obj.sections[200].y + 20,
                  w = lvar.colorsel_btnsize_w,
                  h = btnsize}
    f_Get_SSV(colours.ibox)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'INFO BOX', 5, colours.iboxT, -2, nil, nil, nil, nil, nil, nil, true)

    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(tab_xtouch_colors[lvar.ss_color_override_color].c)
    local tc = tab_xtouch_colors[lvar.ss_color_override_color].tc or '0 0 0' 
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'AUTO OVERRIDE', 5, tc, -5, nil, nil, nil, nil, nil, nil, true)
    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(tab_xtouch_colors[lvar.ss_color_override_nonautomatable_color].c)
    local tc = tab_xtouch_colors[lvar.ss_color_override_nonautomatable_color].tc or '0 0 0'     
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'AO OFF', 5, tc, -5, nil, nil, nil, nil, nil, nil, true)

    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(tab_xtouch_colors[lvar.rec_automap_color_vol].c)
    local tc = tab_xtouch_colors[lvar.rec_automap_color_vol].tc or '0 0 0'     
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'AUTOMAP VOL', 5, tc, -5, nil, nil, nil, nil, nil, nil, true)
    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(tab_xtouch_colors[lvar.rec_automap_color_pan].c)
    local tc = tab_xtouch_colors[lvar.rec_automap_color_pan].tc or '0 0 0'     
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'AUTOMAP PAN', 5, tc, -5, nil, nil, nil, nil, nil, nil, true)
    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(tab_xtouch_colors[lvar.rec_automap_color_mute].c)
    local tc = tab_xtouch_colors[lvar.rec_automap_color_mute].tc or '0 0 0'     
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'AUTOMAP MUTE', 5, tc, -5, nil, nil, nil, nil, nil, nil, true)
    xywh.y = xywh.y + btnsize + lvar.colorsel_btnsize_spacer
    f_Get_SSV(tab_xtouch_colors[lvar.rec_automap_color_plug].c)
    local tc = tab_xtouch_colors[lvar.rec_automap_color_plug].tc or '0 0 0'     
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h,1)
    GUI_text(gui, xywh, 'AUTOMAP PLUG', 5, tc, -5, nil, nil, nil, nil, nil, nil, true)
    
    
    local t1, t2, t3 = '', '', ''
    if lvar.colordesc_disp then
      t1 = lvar.colordesc_disp[1] or ''
      t2 = lvar.colordesc_disp[2] or ''
      t3 = lvar.colordesc_disp[3] or ''   
    end
    local xywh = {x = obj.sections[203].x,
                  y = obj.sections[203].y-8,
                  w = obj.sections[203].w,
                  h = 18}
    GUI_text(gui, xywh, t1, 5, '205 205 205', -3)
    xywh.y = xywh.y+15
    GUI_text(gui, xywh, t2, 5, '205 205 205', -3)    
    xywh.y = xywh.y+15
    GUI_text(gui, xywh, t3, 5, '205 205 205', -3)
    
  end
  
  function GUI_DrawMsg(obj, gui, txt, fsz, blit)

    if not blit then
      gfx.setimgdim(lvar.bmp.msg,-1,-1)
      gfx.setimgdim(lvar.bmp.msg,gfx1.main_w,gfx1.main_h)
      
      gfx.dest = lvar.bmp.msg
      f_Get_SSV(colours.mainbg)
      gfx.rect(0,0,gfx1.main_w,
                gfx1.main_h,1)
  
      local f = 2
      if not fsz then fsz = {} end
      
      local xywh = {x = 0, y = math.floor(0-(#txt*butt_h)/2), w = gfx1.main_w, h = gfx1.main_h}
      for i = 1, #txt do
        f = fsz[i] or f
        GUI_text(gui, xywh, txt[i], 5, '205 205 205', f)
        xywh.y = xywh.y + butt_h
      end
    end
    
    gfx.dest = -1
    gfx.a = 1
    gfx.blit(lvar.bmp.msg, 1, 0, 
          0,0, gfx1.main_w,gfx1.main_h,
          0,0, gfx1.main_w,gfx1.main_h, 0,0)
    if not blit then
      gfx.update()
    end
  
    --gfx.dest = 1
  end

  function GUI_DrawMIDIFiltSetUp(obj, gui)
  
    gfx.dest = 3
    if lupd.update_gfx or lupd.resize_display then    
      gfx.setimgdim(3, -1, -1)  
      gfx.setimgdim(3, obj.sections[10000].w,obj.sections[10000].h)
      
      f_Get_SSV('0 0 0')
      gfx.rect(0,
               0,
               obj.sections[10000].w,
               obj.sections[10000].h, 1)  

      f_Get_SSV(colours.mainbg)
      local ins = 2
      gfx.rect(ins,
               ins,
               obj.sections[10000].w-ins*2,
               obj.sections[10000].h-ins*2, 1)  
      
      GUI_text(gui, obj.sections[10001], 'MIDI Filter: '..tostring(lvar.midifilteredit), 5, '205 205 205', 0)
               
      local txt = 'No'
      local bcol = '0 0 0'
      local tcol = '205 205 205'
      local v = false
      if lvar.midiinput_filt[lvar.midifilteredit].all_cc == 1 then
        txt = 'Yes'
        bcol = colours.faderlitcc
        tcol = '0 0 0'
        v = true
      end
      GUI_DrawButton(gui, obj.sections[10002], txt, bcol, tcol, v, 0, "Filter: All CC's", '205 205 205', 0)

      local txt = 'No'
      local bcol = '0 0 0'
      local tcol = '205 205 205'
      local v = false
      if lvar.midiinput_filt[lvar.midifilteredit].pb == 1 then
        txt = 'Yes'
        bcol = colours.faderlitcc
        tcol = '0 0 0'
        v = true
      end
      GUI_DrawButton(gui, obj.sections[10003], txt, bcol, tcol, v, 0, "Filter: Pitchbend", '205 205 205', 0)

      local txt = 'No'
      local bcol = '0 0 0'
      local tcol = '205 205 205'
      local v = false
      if lvar.midiinput_filt[lvar.midifilteredit].pc == 1 then
        txt = 'Yes'
        bcol = colours.faderlitcc
        tcol = '0 0 0'
        v = true
      end
      GUI_DrawButton(gui, obj.sections[10004], txt, bcol, tcol, v, 0, "Filter: Program Change", '205 205 205', 0)

      local txt = 'No'
      local bcol = '0 0 0'
      local tcol = '205 205 205'
      local v = false
      
      if lvar.midiinput_filt[lvar.midifilteredit].sysx == 1 then
        txt = 'Yes'
        bcol = colours.faderlitcc
        tcol = '0 0 0'
        v = true
      end
      GUI_DrawButton(gui, obj.sections[10005], txt, bcol, tcol, v, 0, "Filter: SysEx", '205 205 205', 0)

      local txt = 'No'
      local bcol = '0 0 0'
      local tcol = '205 205 205'
      local v = false
      if lvar.midiinput_filt[lvar.midifilteredit].at_poly == 1 then
        txt = 'Yes'
        bcol = colours.faderlitcc
        tcol = '0 0 0'
        v = true
      end
      GUI_DrawButton(gui, obj.sections[10006], txt, bcol, tcol, v, 0, "Filter: Aftertouch Poly", '205 205 205', 0)

      local txt = 'No'
      local bcol = '0 0 0'
      local tcol = '205 205 205'
      local v = false
      if lvar.midiinput_filt[lvar.midifilteredit].at_chan == 1 then
        txt = 'Yes'
        bcol = colours.faderlitcc
        tcol = '0 0 0'
        v = true
      end
      GUI_DrawButton(gui, obj.sections[10007], txt, bcol, tcol, v, 0, "Filter: Aftertouch Channel", '205 205 205', 0)

      local xywh = {x = obj.sections[10008].x, y = obj.sections[10008].y - butt_h, w = obj.sections[10008].w, h = butt_h}
      GUI_text(gui, xywh, 'Individual CC Filters', 5, '205 205 205')

      f_Get_SSV('0 0 0')
      local rows = math.min(math.floor(obj.sections[10008].h / obj.sections[10008].ch),16)
      gfx.rect(obj.sections[10008].x-2,
               obj.sections[10008].y-2,
               (8 * obj.sections[10008].cw) +3,
               (rows * obj.sections[10008].ch)+3, 1)  
      local xywh = {w = obj.sections[10008].cw-1,
                    h = obj.sections[10008].ch-1}
      local breakloop = false
      for y = 0, rows-1 do
        for x = 0, 7 do 
          local cc = y * 8 + x + lvar.midifilter_ccoffs
          if cc > 127 then
            breakloop = true
            break
          end
          xywh.x = obj.sections[10008].x + x * obj.sections[10008].cw
          xywh.y = obj.sections[10008].y + y * obj.sections[10008].ch
          local v = false
          local bcol = '64 64 64'
          local tcol = '205 205 205'
          if lvar.midiinput_filt[lvar.midifilteredit].ccs[cc] == 1 then
            bcol = colours.faderlitcc
            tcol = '0 0 0'
            v = true
          end
          local txt = string.format('%i',cc)
          GUI_DrawButton(gui, xywh, txt, bcol, tcol, v, -4) --, '', '205 205 205', 0)
        end
        if breaakloop then
          break
        end
      end
    end  
    gfx.dest = 1
    
  end
  
  function GUI_DrawSetUp(obj, gui)
  
    gfx.dest = 2
    if lupd.update_gfx or lupd.resize_display then    
      gfx.setimgdim(2, -1, -1)  
      gfx.setimgdim(2, gfx1.main_w,2048)
      
      f_Get_SSV(colours.mainbg)
      gfx.rect(0,
               0,
               gfx1.main_w,
               2048, 1)  
    end  
  
    GUI_DrawButton(gui, obj.sections[100], 'CLOSE', '205 205 205', '99 99 99', true, -1)
  
    local butt_h = butt_h-8
    if not mididevices then
      mididevices = GetMIDIDevices()
    end
    f_Get_SSV('0 0 0')
    gfx.rect(obj.sections[101].x,
             obj.sections[101].y,
             obj.sections[101].w,
             obj.sections[101].h, 1)
    local xywh = {x = obj.sections[101].x,
                  y = obj.sections[101].y - 70,
                  w = obj.sections[101].w,
                  h = butt_h}
    GUI_text(gui, xywh, 'Hardware MIDI Inputs', 5, '205 205 205', 0)

    local xywh = {x = obj.sections[101].x,
                  y = obj.sections[101].y - 45,
                  w = obj.sections[101].w,
                  h = butt_h}
    GUI_text(gui, xywh, 'L-Click - Select MIDI controller input(s)', 5, colours.faderlitcc, -2)
    xywh.y = xywh.y + 20
    GUI_text(gui, xywh, 'R-Click - Select other used MIDI input(s) (OPTIONAL)', 5, colours.faderlit, -2)    

    local xywh = {x = obj.sections[102].x,
                  y = obj.sections[102].y - 50,
                  w = obj.sections[102].w,
                  h = butt_h}
    GUI_text(gui, xywh, 'Hardware MIDI Outputs', 5, '205 205 205', 0)

    local xywh = {x = obj.sections[102].x,
                  y = obj.sections[102].y - 25,
                  w = obj.sections[102].w,
                  h = butt_h}
    GUI_text(gui, xywh, 'Select MIDI controller output(s)', 5, colours.faderlitcc, -2)
                 
    local xywh = {x = obj.sections[101].x+5,
                  y = obj.sections[101].y,
                  w = obj.sections[101].w-10,
                  h = butt_h}
    offs = lvar.MIoffs
    for i = 1, 8 do
      if mididevices.input[i + offs] then
        local name = mididevices.input[i + offs].name
        local tcol = '205 205 205'
        if lvar.midiinput_gen[name] then
          f_Get_SSV(colours.faderlit)          
          gfx.rect(xywh.x-2,xywh.y,xywh.w+4,xywh.h,1)
          
          xywh2 = {x = xywh.x+xywh.w-38,
                   y = xywh.y,
                   w = 40,
                   h = xywh.h}

          local ttcol = '205 205 205'
          if lvar.midiinput_filt[name] and lvar.midiinput_filt[name].active then
            f_Get_SSV('0 150 0')
            ttcol = '0 0 0'
          else
            f_Get_SSV_dim(colours.faderlit, 0.8)
          end
          gfx.rect(xywh2.x,
                   xywh2.y,
                   xywh2.w,
                   xywh2.h,1)
          f_Get_SSV('0 0 0')
          gfx.line(xywh2.x,
                   xywh2.y,
                   xywh2.x,
                   xywh2.y+xywh2.h)
          GUI_text(gui, xywh2, 'MIDI FILT', 5, ttcol, -8, nil, nil, nil, nil, nil, nil, true)
          
        elseif lvar.midiinput_ctl[name] then
          local bus = lvar.midiinput_ctl[name].bus
          f_Get_SSV(colours.faderlitcc)          
          gfx.rect(xywh.x-2,xywh.y,xywh.w+4,xywh.h,1)
          xywh2 = {x = xywh.x+xywh.w-78,
                   y = xywh.y,
                   w = 40,
                   h = xywh.h}
          f_Get_SSV(colours.faderlitcc_chasefail)
          gfx.rect(xywh2.x,
                   xywh2.y,
                   xywh2.w,
                   xywh2.h,1)
          f_Get_SSV('0 0 0')
          gfx.line(xywh2.x,
                   xywh2.y,
                   xywh2.x,
                   xywh2.y+xywh2.h)
          
          tcol = '0 0 0'
          GUI_text(gui, xywh2, string.format('%i',bus+1), 5, tcol, 0)
        
          xywh2.x = xywh2.x + 40
          if lvar.midiinput_filt[name] and lvar.midiinput_filt[name].active then
            f_Get_SSV('0 150 0')
          else
            f_Get_SSV(colours.faderlitcc_chasefail)
          end
          gfx.rect(xywh2.x,
                   xywh2.y,
                   xywh2.w,
                   xywh2.h,1)
          f_Get_SSV('0 0 0')
          gfx.line(xywh2.x,
                   xywh2.y,
                   xywh2.x,
                   xywh2.y+xywh2.h)
          GUI_text(gui, xywh2, 'MIDI FILT', 5, tcol, -8, nil, nil, nil, nil, nil, nil, true)
          
        end 
        GUI_text(gui, xywh, name, 4, tcol, -2)
        xywh.y = xywh.y + butt_h
      else
        break
      end
    end

    if lvar.enablegroupinputs then
      local txt = 'No'
      local bcol = '0 0 0'
      local tcol = '205 205 205'
      if settings.groupinputs then
        txt = 'Yes'
        bcol = colours.faderlit
        tcol = '205 205 205'
      end
      GUI_DrawButton(gui, obj.sections[124], txt, bcol, tcol, settings.groupinputs, 0, 'Group inputs:', '205 205 205', 0)
    end
    
    local txt = 'GLOBAL MIDI FILTER'
    local bcol = colours.faderlit
    local tcol = '205 205 205'
    if lvar.midiinput_filt['GLOBAL FILTER'] and lvar.midiinput_filt['GLOBAL FILTER'].active then
      bcol = '0 150 0'
      tcol = '0 0 0'
    end
    GUI_DrawButton(gui, obj.sections[126], txt, bcol, tcol, true, -6, '', '205 205 205', 0, nil, true)

    f_Get_SSV('0 0 0')
    gfx.rect(obj.sections[102].x,
             obj.sections[102].y,
             obj.sections[102].w,
             obj.sections[102].h, 1)
    local xywh = {x = obj.sections[102].x+5,
                  y = obj.sections[102].y,
                  w = obj.sections[102].w-10,
                  h = butt_h}
    offs = lvar.MOoffs
    for i = 1, 8 do
      if mididevices.output[i + offs] then
        local name = mididevices.output[i + offs].name
        local bus = mididevices.output[i + offs].bus
        local tcol = '205 205 205'
        if lvar.midioutput_ctl[name] then
          local bus = lvar.midioutput_ctl[name].bus
          f_Get_SSV(colours.faderlitcc)          
          gfx.rect(xywh.x-2,xywh.y,xywh.w+4,xywh.h,1)
          xywh2 = {x = xywh.x+xywh.w-38,
                   y = xywh.y,
                   w = 40,
                   h = xywh.h}
          f_Get_SSV(colours.faderlitcc_chasefail)
          gfx.rect(xywh2.x,
                   xywh2.y,
                   xywh2.w,
                   xywh2.h,1)

          f_Get_SSV('0 0 0')
          gfx.line(xywh2.x,
                   xywh2.y,
                   xywh2.x,
                   xywh2.y+xywh2.h)

          tcol = '0 0 0'
          GUI_text(gui, xywh2, string.format('%i',bus+1), 5, tcol, 0)
        end 
        GUI_text(gui, xywh, name, 4, tcol, -2)
        xywh.y = xywh.y + butt_h
      else
        break
      end
    end

    local xywh = {x = obj.sections[120].x,
                  y = obj.sections[120].y - 30,
                  w = obj.sections[120].w,
                  h = butt_h}
    GUI_text(gui, xywh, 'Controller MIDI Maps', 5, '205 205 205', 0)

    f_Get_SSV('0 0 0')
    gfx.rect(obj.sections[120].x,
             obj.sections[120].y,
             obj.sections[120].w,
             obj.sections[120].h, 1)
    local tcol = '205 205 205'
    if lvar.midimap[1] then
      f_Get_SSV(colours.faderlitcc)          
      gfx.rect(obj.sections[120].x+3,obj.sections[120].y+2,obj.sections[120].w-6,obj.sections[120].h-4,1)
      tcol = '0 0 0'
    end
    GUI_text(gui, obj.sections[120], lvar.midimap[1] or '<device 1>', 5, tcol, 0)

    f_Get_SSV('0 0 0')
    gfx.rect(obj.sections[121].x,
             obj.sections[121].y,
             obj.sections[121].w,
             obj.sections[121].h, 1)
    local tcol = '205 205 205'
    if lvar.midimap[2] then
      f_Get_SSV(colours.faderlitcc)          
      gfx.rect(obj.sections[121].x+3,obj.sections[121].y+2,obj.sections[121].w-6,obj.sections[121].h-4,1)
      tcol = '0 0 0'
    end
    GUI_text(gui, obj.sections[121], lvar.midimap[2] or '<device 2>', 5, tcol, 0)

    f_Get_SSV('0 0 0')
    gfx.rect(obj.sections[122].x,
             obj.sections[122].y,
             obj.sections[122].w,
             obj.sections[122].h, 1)
    local tcol = '205 205 205'
    if lvar.midimap[3] then
      f_Get_SSV(colours.faderlitcc)          
      gfx.rect(obj.sections[122].x+3,obj.sections[122].y+2,obj.sections[122].w-6,obj.sections[122].h-4,1)
      tcol = '0 0 0'
    end
    GUI_text(gui, obj.sections[122], lvar.midimap[3] or '<device 3>', 5, tcol, 0)

    f_Get_SSV('0 0 0')
    gfx.rect(obj.sections[123].x,
             obj.sections[123].y,
             obj.sections[123].w,
             obj.sections[123].h, 1)
    local tcol = '205 205 205'
    if lvar.midimap[4] then
      f_Get_SSV(colours.faderlitcc)          
      gfx.rect(obj.sections[123].x+3,obj.sections[123].y+2,obj.sections[123].w-6,obj.sections[123].h-4,1)
      tcol = '0 0 0'
    end
    GUI_text(gui, obj.sections[123], lvar.midimap[4] or '<device 4>', 5, tcol, 0)

    local bc = '0 0 0'
    local tc = gui.color.white
    f_Get_SSV('0 0 0')
    gfx.rect(obj.sections[125].x,
             obj.sections[125].y,
             obj.sections[125].w,
             obj.sections[125].h, 1)

    local xywh = {x = obj.sections[125].x, y = obj.sections[125].y - obj.sections[125].h, w = obj.sections[125].w, h = obj.sections[125].h}
    GUI_text(gui, xywh, 'MIDI Loopback', 5, tcol, -2)
    
    local txt
    if lvar.midiloopbackdev ~= nil then
      bc = colours.faderlitcc
      tc = '0 0 0'
      local idx = mididevices.outidx2[lvar.midiloopbackdev]
      if mididevices.output[idx] then
        txt = mididevices.output[idx].name
      else
        bc = gui.color.red
        txt = '< Device not found >'
      end
    else
      txt = 'SK2 Routing'
    end
    local xywh = {x = obj.sections[125].x+3, y = obj.sections[125].y+2, w = obj.sections[125].w-6, h = obj.sections[125].h-4}
    GUI_DrawButton(gui, xywh, txt, bc, tc, true, 0)

    GUI_DrawButton(gui, obj.sections[104], string.format('%i',lvar.fcount), colours.faderlit, '255 255 255', true, 0, 'No. controls:', '205 205 205', 0)
    local txt = 'No'
    local bcol = '0 0 0'
    local tcol = '205 205 205'
    if settings.rrmode then
      txt = 'Yes'
      bcol = colours.faderlitcc
      tcol = '0 0 0'
    end
    GUI_DrawButton(gui, obj.sections[106], txt, bcol, tcol, settings.rrmode, 0, 'Retro. record mode:', '205 205 205', 0)
    --[[local txt = 'No'
    local bcol = '0 0 0'
    local tcol = '205 205 205'
    if settings.ccsend then
      txt = 'Yes'
      bcol = colours.faderlitcc
      tcol = '0 0 0'
    end
    GUI_DrawButton(gui, obj.sections[107], txt, bcol, tcol, settings.ccsend, 0, 'Send CC to sel. track:', '205 205 205', 0)]]
    local txt = 'No'
    local bcol = '0 0 0'
    local tcol = '205 205 205'
    if settings.sort then
      txt = 'Yes'
      bcol = colours.faderlitcc
      tcol = '0 0 0'
    end
    GUI_DrawButton(gui, obj.sections[109], txt, bcol, tcol, settings.touchctl, 0, 'Sort Controls:', '205 205 205', 0)
    local txt = 'No'
    local bcol = '0 0 0'
    local tcol = '205 205 205'
    if settings.hidectltrack then
      txt = 'Yes'
      bcol = colours.faderlitcc
      tcol = '0 0 0'
    end
    GUI_DrawButton(gui, obj.sections[108], txt, bcol, tcol, settings.hidectltrack, 0, 'Hide control tracks:', '205 205 205', 0)

    local txt = 'No'
    local bcol = '0 0 0'
    local tcol = '205 205 205'
    if settings.liveccfb then
      txt = 'Yes'
      bcol = colours.faderlitcc
      tcol = '0 0 0'
    end
    GUI_DrawButton(gui, obj.sections[113], txt, bcol, tcol, settings.liveccfb, 0, 'Live CC Feedback:', '205 205 205', 0)

    if settings.liveccfb then
      GUI_text(gui, obj.sections[111], '(Will create sends)', 5, '205 205 205', -4, nil, nil, nil, nil, nil, nil, true)
    end
    --[[local txt = 'No'
    local bcol = '0 0 0'
    local tcol = '205 205 205'
    if lvar.createsends then
      txt = 'Yes'
      bcol = colours.faderlitcc
      tcol = '0 0 0'
    end]]
    --GUI_DrawButton(gui, obj.sections[111], txt, bcol, tcol, lvar.createsends, 0, 'Create all sends:', '205 205 205', 0)
    GUI_DrawButton(gui, obj.sections[112], string.format('%i',lvar.dummyfaders), colours.faderlit, '255 255 255', true, 0, 'No. dummy faders:', '205 205 205', 0)

    GUI_DrawButton(gui, obj.sections[105], 'Create Set Up', '205 205 205', '99 99 99', true, 0)

    gfx.dest = 1
  end
  
  function GetMIDIDevices()
    
    local tmp = {input = {}, output = {}, inidx = {}, outidx = {}, inidx2 = {}, outidx2 = {}}

    local incnt = reaper.GetNumMIDIInputs()
    
    for i = 0, incnt do
      local present, name = reaper.GetMIDIInputName(i, '')
      if present then
        local idx = #tmp.input+1
        tmp.input[idx] = {name = name, present = present, dev = i, bus = 0}
        tmp.inidx[name] = i
        tmp.inidx2[name] = idx
      end
    end

    local outcnt = reaper.GetNumMIDIOutputs()
    
    for i = 0, outcnt do
      local present, name = reaper.GetMIDIOutputName(i, '')
      if present == true then
        local idx = #tmp.output+1
        tmp.output[idx] = {name = name, present = present, dev = i, bus = 0}
        --DBG(idx..'  '..i..'  '..name)
        tmp.outidx[name] = i
        tmp.outidx2[name] = idx
      end
    end
  
    return tmp
  end
  
  function GUI_FlashButton(obj, gui, butt, txt, flashtime, col, tsz)

    gfx.dest = 1
    GUI_DrawButton(gui, obj.sections[butt], txt, col, '99 99 99', true, tsz or -1)
    gfx.dest = -1
    gfx.a = 1
    gfx.blit(1, 1, 0, 
      0,0, gfx1.main_w,gfx1.main_h,
      0,0, gfx1.main_w,gfx1.main_h, 0,0)
    refresh_gfx = reaper.time_precise() + flashtime
      
  end
  
  function GUI_DrawButtons(obj, gui)

    --[[if flashctl[5] == true then
      flashctl[5] = nil
      c = '255 0 0'
    end]]
    local fb = 0
    if LBX_CTL_TRACK then
      local tr = GetTrack(LBX_CTL_TRACK)
      if tr then
        fb = reaper.TrackFX_GetParam(tr,0,47)
      end
    end
    local c = colours.buttcol
    local tc = '99 99 99'
    if fb == 1 then
      if lvar.fbcconseek == true then
        c = colours.faderlit
      else
        if settings.liveccfb then
          c = '0 192 0'
        else
          c = colours.faderlitcc
        end
      end
      tc = '0 0 0'
    end
    GUI_DrawButton2(gui, obj.sections[150], 'FB', c, tc, fb, -2, nil, nil, nil, nil, nil, nil, true)
    
    local c = colours.buttcol
    local tag
    if lvar.save_highlight then
      if lvar.mode == 3 and FFX then
        tag = lvar.tags.trackassoc[FFX.trname]
      end
      if lvar.mode ~= 3 or not tag then
        c = colours.buttcollit
      end
    end
    GUI_DrawButton(gui, obj.sections[5], 'SAVE', c, '99 99 99', true, -1, nil, nil, nil, nil, true)
    
    --if lvar.mode ~= 3 then
      local bc = colours.buttcol
      local c = '99 99 99'
      if recmode == 0 then
      elseif recmode == 1 then
        bc = '255 0 0'
        c = '0 0 0'
      end
      GUI_DrawButton(gui, obj.sections[6], 'REC', bc, c, true, -1, nil, nil, nil, nil, true)
    --end

    ---TAGS
    if lvar.mode == 3 then
      local bc = colours.buttcol
      GUI_DrawButton(gui, obj.sections[1004], 'LOAD TAG', bc, '99 99 99', true, -4+gui.fontsz_special, nil, nil, nil, true, true)
      local c = colours.buttcol
      if lvar.save_highlight and tag then
        c = colours.buttcollit
      end
      GUI_DrawButton(gui, obj.sections[1003], 'SAVE TAG', c, '99 99 99', true, -4+gui.fontsz_special, nil, nil, nil, true, true)
    end  
    
    local bc = colours.buttcol
    if lrnmode == false then
    elseif lrnmode == true then
      if lvar.fxlearnmode == 0 then
        bc = '255 0 0'
      else
        bc = '128 255 255'
      end
    end
    GUI_DrawButton(gui, obj.sections[8], 'LEARN FX', bc, '99 99 99', true, -4, nil, nil, nil, nil, true)
    local bc = colours.buttcol
    GUI_DrawButton(gui, obj.sections[9], 'SETTINGS', bc, '99 99 99', true, -4, nil, nil, nil, nil, true)

    local c1, c2, c3 = colours.buttcol, colours.buttcol, colours.buttcol
    local tc1, tc2, tc3 = '99 99 99', '99 99 99', '99 99 99'
    local m1, m2, m3 = 0, 0, 0
    if lvar.mode == 1 then
      c1 = colours.modebtnhl
      tc1 = '0 0 0'
      m1 = 1
    elseif lvar.mode == 2 then
      c2 = colours.modebtnhl
      tc2 = '0 0 0'
      m2 = 1
    elseif lvar.mode == 3 then
      c3 = colours.modebtnhl
      tc3 = '0 0 0'
      m3 = 1    
    end
    GUI_DrawButton2(gui, obj.sections[12], 'TRACK', c3, tc3, m3, -4, nil, nil, nil, nil, nil, nil, true)
    GUI_DrawButton2(gui, obj.sections[13], 'INSTANCE', c2, tc2, m2, -4, nil, nil, nil, nil, nil, nil, true)
    GUI_DrawButton2(gui, obj.sections[14], 'PLUGIN', c1, tc1, m1, -4, nil, nil, nil, nil, nil, nil, true)

    local c, tc, m = colours.buttcol, '99 99 99', 0
    if lvar.flip == 1 then
      c = colours.modebtnhl
      tc = '0 0 0'
      m = 1        
    end
    GUI_DrawButton2(gui, obj.sections[19], 'FLIP', c, tc, m, -4, nil, nil, nil, nil, nil, nil, true)

    local c, tc, m = colours.buttcol, '99 99 99', 0    
    if lvar.ccstamp_active == 1 then
      c = colours.modebtnhl
      tc = '0 0 0'
      m = 1    
    end
    GUI_DrawButton2(gui, obj.sections[20], 'PRINT VAL', c, tc, m, -4, nil, nil, nil, nil, nil, true, true)
    
    local c, tc, m = colours.buttcol, '99 99 99', 0    
    local txt
    if lvar.ctlgroup_select > 0 then
      c = colours.modebtnhl
      tc = '0 0 0'
      m = 1
      txt = string.format('%i',lvar.ctlgroup_select or 0) 
    else
      txt = 'OFF'  
    end
    GUI_DrawButton2(gui, obj.sections[21], 'HL GRP', c, tc, m, -4, nil, nil, nil, nil, nil, true ,true)
    GUI_DrawButton2(gui, obj.sections[22], txt, c, tc, m, -4, nil, nil, nil, nil, nil, nil, true)

    local c, tc, m = colours.buttcol, '99 99 99', 0
    local txt = 'TO'
    if obj.sections[27].w > 56 then
      txt = 'TAKEOVER'
    end
    if lvar.takeover.active > -1 then
      txt = txt..' '..string.format('%i',lvar.takeover.active)
      c = colours.modebtnhl
      tc = '0 0 0'
      m = 1
    end
    GUI_DrawButton2(gui, obj.sections[27], txt, c, tc, m, -4, nil, nil, nil, nil, nil, true, true)

    local c, tc, m = colours.buttcol, '99 99 99', 0    
    if lvar.midieditor_cclanes == true then
      c = colours.modebtnhl
      tc = '0 0 0'
      m = 1    
    end
    GUI_DrawButton2(gui, obj.sections[23], 'AUTO LANES', c, tc, m, -4, nil, nil, nil, nil, nil, true, true)

    local c, tc, m = colours.buttcol, '99 99 99', 0
    --local track = reaper.GetSelectedTrack2(0,0,true)
    local track, trnm = GetCCLanesTrack()
    if track then
      --local trnm = reaper.GetTrackState(track)
      if lvar.midieditor_cclanes == true and lvar.lanes_ov_tab[trnm] and lvar.lanes_ov_enable then
        c = colours.modebtnhl
        tc = '0 0 0'
        m = 1    
      end
    end
    GUI_DrawButton2(gui, obj.sections[24], 'CC LANE PRESETS', c, tc, m, -4, nil, nil, nil, nil, nil, true, true)

    local bw = math.floor(obj.sections[25].w/8)
    local xywh = {x = obj.sections[25].x,
                  y = obj.sections[25].y,
                  w = bw-2,
                  h = obj.sections[25].h}
    local _, trnm = GetCCLanesTrack()
    for i = 1, 8 do
      local c, m = colours.buttcol, 0
      local tc = '99 99 99'
      if lvar.lanes_presets[trnm] then
        if lvar.lanes_presets[trnm].select == i then
          c = colours.modebtnhl
          tc = '0 0 0'
          if not (lvar.midieditor_cclanes == true and lvar.lanes_ov_tab[trnm] and lvar.lanes_ov_enable) then
            c = Color_dim(c,0.5)
          end
          m = 1
        elseif lvar.lanes_presets[trnm][i] then
          tc = colours.modebtnhl
        end
      end
      GUI_DrawButton2(gui, xywh, string.format('%i',i), c, tc, m, -4, nil, nil, nil, nil, nil, nil, true)      
      xywh.x = xywh.x + bw
    end

    local c, tc, m = colours.buttcol, '99 99 99', 0    
    if lvar.autoenv == true then
      c = colours.modebtnhl
      tc = '0 0 0'
      m = 1    
    end
    GUI_DrawButton2(gui, obj.sections[28], 'AUTO ENV', c, tc, m, -4, nil, nil, nil, nil, nil, true, true)

    local c, tc, m = colours.buttcol, '99 99 99', 0    
    if lvar.showcontrolname == true then
      c = colours.modebtnhl
      tc = '0 0 0'
      m = 1    
    end
    GUI_DrawButton2(gui, obj.sections[31], 'SHOW CTL', c, tc, m, -4, nil, nil, nil, nil, nil, true, true)

    local c, tc, m = colours.buttcol, '99 99 99', 0   
    if lvar.finetune_active then
      c = colours.modebtnhl
      tc = '0 0 0'
      m = 1
    end
    GUI_DrawButton2(gui, obj.sections[33], 'FINETUNE', c, tc, m, -4, nil, nil, nil, nil, nil, true, true)

    local c, tc, m = colours.buttcol, '99 99 99', 0   
    if LBX_RR_TRACK then
      if lvar.rr_defeat_active then
        if lvar.rrsettings.overdubnotes == 1 then
          c = '0 160 0'
          tc = '0 0 0'
          m = 1
        else
          c = '200 100 0'
          tc = '0 0 0'
          m = 1
        end
      else
        c = '128 0 0'
        tc = '0 0 0'
        m = 1
      end
    end
    GUI_DrawButton2(gui, obj.sections[32], 'RETRO REC', c, tc, m, -4, nil, nil, nil, nil, nil, true, true)
    
    if not lvar.hide_globalshortcuts2 then
      local c, tc, m = colours.buttcol, '99 99 99', 0
      if lvar.showglobalmap then
        m, tc = 1, colours.globalfader
        c = colours.globalfader
      end
      local txt = lvar.globmapnames[lvar.currentglobalmap] or ''
      if txt  == '' then
        txt = 'GLOBAL MAP '..string.format('%i',lvar.currentglobalmap)
      end
      txt = CheckTXT(txt, string.format('%i',lvar.currentglobalmap), -4, obj.sections[15].w-12)
      GUI_DrawButton2(gui, obj.sections[15], txt, c, tc, m, -4, nil, nil, nil, nil, nil, true, true)
    end
    
    local c, tc, m = colours.buttcol, '99 99 99', 0
    if lvar.saveglob_highlight then
      m, c, tc = 1, colours.globalfader, colours.globalfader_txt
    end
    GUI_DrawButton(gui, obj.sections[16], 'GLOBAL SAVE', c, tc, m, -4, nil, nil, nil, true, true)
    if lvar.saveperm_highlight then
      f_Get_SSV(colours.permafader)
      local xywh = obj.sections[16]
      gfx.rect(xywh.x,
               xywh.y,
               xywh.w,
               xywh.h, 0)
      gfx.rect(xywh.x+1,
               xywh.y+1,
               xywh.w-2,
               xywh.h-2, 0)
    end
    
    if not lvar.hide_globalshortcuts then
      local ww = ((obj.sections[17].w+2) / (lvar.gbc/2))
      local hh = obj.sections[17].h / 2
      
      local xywh = {x = obj.sections[17].x,
                    y = obj.sections[17].y,
                    w = math.floor(ww-2),
                    h = 22*lvar.guizoom}
      for x = 0, (lvar.gbc/2)-1 do
        xywh.y = obj.sections[17].y
        for y = 0, 1 do
          local c, tc, m = colours.buttcol, '99 99 99', 0
          local p = (x+1)+y*(lvar.gbc/2)
          --local flags2
          if p == lvar.currentglobalmap then
            m = 1
            c = colours.globalfader
            tc = colours.globalfader
            if not lvar.showglobalmap then
              c = Color_dim(c,0.5)
            end
            --flags2 = string.byte('B')
          end
          local txt = CheckTXT(lvar.globmapnames[p] or string.format('%i',p), string.format('%i',p), -4, ww-12)
          GUI_DrawButton2(gui, xywh, txt, c, tc, m, -4, nil, nil, nil, flags, nil, nil, true)
          --c, m = colours.buttcol, 0
          m=0
          tc = '99 99 99'
          xywh.y = xywh.y + 22*lvar.guizoom + 2
        end
        xywh.x = xywh.x + ww
      end
    end    

    local c, tc, m = colours.buttcol, '99 99 99', 0
    local txt --= 'LAYER OFF'    
    if lvar.overtemplate_active then
      m = 1
      c = colours.layerfader
      tc = colours.layerfader_txt
    end
    if template.layer and template.layer[lvar.overtemplate] then
      txt = template.layer[lvar.overtemplate].name or ('LAYER '..string.format('%i', lvar.overtemplate))
    else 
      txt = ('LAYER '..string.format('%i', lvar.overtemplate))
    end
    GUI_DrawButton2(gui, obj.sections[29], txt, c, tc, m, -4, nil, nil, nil, nil, nil, true, true)
    
    local bw = math.floor(obj.sections[26].w/lvar.overtmp_cnt)
    local xywh = {x = obj.sections[26].x,
                  y = obj.sections[26].y,
                  w = bw-2,
                  h = obj.sections[26].h}
    for i = 1, lvar.overtmp_cnt do
      local c, m = colours.buttcol, 0
      local tc = '99 99 99'
      if lvar.overtemplate == i then
        c = colours.layerfader
        tc = colours.layerfader_txt --'0 0 0'
        if not lvar.overtemplate_active then
          c = Color_dim(c,0.5)
          --tc = Color_dim(tc,0.3)
        end
        m = 1
      elseif template.layer and template.layer[i] then
        tc = colours.layerfader
      end
      GUI_DrawButton2(gui, xywh, string.format('%i',i), c, tc, m, -4, nil, nil, nil, nil, nil, nil, true)      
      xywh.x = xywh.x + bw
      
    end

    local c, tc, m = colours.buttcol, '99 99 99', 0
    local ftxt = 'Filter off'
    if lvar.userfilter.select then
      ftxt = lvar.userfilter[lvar.userfilter.select].name
    elseif #lvar.lstfilt > 1 then
      ftxt = 'MULTI FILTER'
    elseif lvar.filtidx then
      ftxt = string.gsub((tab_filters[lvar.lstfilt[1]] or 'User '..string.format('%i',p)),'|','')
    end
    if lvar.filtidx then
      c = colours.filterbox
      tc = '0 0 0'
      m = 1
    end
    
    GUI_DrawButton2(gui, obj.sections[1001], string.upper(ftxt), c, tc, m, -4, nil, nil, nil, nil, nil, true, true)

    local bw = math.floor(obj.sections[1002].w/8)
    local xywh = {x = obj.sections[1002].x,
                  y = obj.sections[1002].y,
                  w = bw-2,
                  h = obj.sections[1002].h}
    
    for i = 1, 8 do
      local c, m = colours.buttcol, 0
      local tc = '99 99 99'
      if lvar.userfilter.select == i then
        c = colours.filterbox
        tc = '0 0 0'
        if not lvar.filtidx then
          c = Color_dim(c,0.5)
        end
        m = 1
      elseif lvar.userfilter[i] then
        tc = colours.filterbox
      end 
      GUI_DrawButton2(gui, xywh, string.format('%i',i), c, tc, m, -4, nil, nil, nil, nil, nil, nil, true)      
      xywh.x = xywh.x + bw
    end

  end

  function CheckTXT(txt, alt, tsz, size)
    gfx.setfont(1, gui.fontname, gui.fontsz_knob+tsz)
    local w, h = gfx.measurestr(txt)
    if w < size then
      return txt
    else
      return alt
    end
  end
  
  function GUI_DrawButton(gui, xywh, txt, bcol, tcol, val, tsz, addtxt, addtxtcol, addtxtpos, multiline, allowshrink)
  
    f_Get_SSV(bcol)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h, 1)
    GUI_text(gui, xywh, txt, 5, tcol, tsz, nil, nil, nil, nil, nil, multiline, allowshrink)
    
    if addtxt then
      local xywh2 = {x = xywh.x, y = xywh.y, w = xywh.w, h = xywh.h}
      xywh2.w = 200
      local jus
      if addtxtpos == 0 then
        jus = 6
        xywh2.x = xywh2.x - xywh2.w - 10
      else
        jus = 4
        xywh2.x = xywh2.x + xywh2.w + 10
      end
      GUI_text(gui, xywh2, addtxt, jus, addtxtcol or '205 205 205', tsz-2)
    end
  end

  function GUI_DrawButton2(gui, xywh, txt, bcol, tcol, val, tsz, addtxt, addtxtcol, addtxtpos, flags, flags2, multiline, allowshrink)

    flags = flags or 5
    local fill = 1
    if val == 1 then
      fill = 0
      tcol = bcol
    end
    f_Get_SSV(bcol)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h, fill)
    GUI_text(gui, xywh, txt, flags, tcol, tsz, flags2, nil, nil, nil, nil, multiline, allowshrink)
    
    if addtxt then
      local xywh2 = {x = xywh.x, y = xywh.y, w = xywh.w, h = xywh.h}
      xywh2.w = 200
      local jus
      if addtxtpos == 0 then
        jus = 6
        xywh2.x = xywh2.x - xywh2.w - 10
      else
        jus = 4
        xywh2.x = xywh2.x + xywh2.w + 10
      end
      GUI_text(gui, xywh2, addtxt, jus, addtxtcol or '205 205 205', tsz-2)
    end
  end

  function GUI_DrawButton3(gui, xywh, txt, bcol, tcol, val, tsz, flags, txt2, padx, justifyiftoobig)
  
    f_Get_SSV(bcol)
    gfx.rect(xywh.x,
             xywh.y,
             xywh.w,
             xywh.h, 1)
    local xywh2 = {x = xywh.x+(padx or 0), y = xywh.y, w = xywh.w-(padx or 0)*2, h = xywh.h}
    GUI_text(gui, xywh2, txt, flags or 5, tcol, tsz, justifyiftoobig)
    if txt2 then
      xywh2.x = xywh2.x - 100
      xywh2.w = 90
      GUI_text(gui, xywh2, txt2, 6, tcol, tsz)
    end
        
  end
  
  
  function GUI_DrawFXHeader(obj, gui)

    if FFX then
      f_Get_SSV(colours.ibox)
      gfx.rect(obj.sections[18].x,
               obj.sections[18].y-2,
               obj.sections[18].w,
               obj.sections[18].h, 1)
      local layertxt, c
      if lvar.overtemplate_active then
        c = colours.layerfader
        if template.layer and template.layer[lvar.overtemplate] then
          layertxt = template.layer[lvar.overtemplate].name or ('LAYER '..string.format('%i', lvar.overtemplate))
        else 
          layertxt = ('LAYER '..string.format('%i', lvar.overtemplate))
        end
      else
        c = '205 205 205'
        layertxt = 'MAIN LAYER'  
      end
      if lvar.mode ~= 3 then
        --track
        
        GUI_text(gui, obj.sections[7], '('..FFX.trname..')    ('..(FFX.fxtype or '')..')', 5, '99 99 99', -5)
        GUI_text(gui, obj.sections[11], FFX.fxname, 5, tab_amcol[LBX_FX_TRACK_AM+1], 2, nil, nil, 4)
        GUI_text(gui, obj.sections[30], layertxt, 5, c, -3, nil, nil, 4)
        GUI_text(gui, obj.sections[1005], '-', 5, c, -3, nil, nil, 4)
      else
        local deflout = '(TRACK)'
        if lvar.deflayout then
          deflout = '(TRACK - DEFAULT MAP)'
        end
        GUI_text(gui, obj.sections[7], deflout, 5, '99 99 99', -5)      
        GUI_text(gui, obj.sections[3], FFX.trname, 5, tab_amcol[LBX_FX_TRACK_AM+1], 2, nil, nil, 4)
        GUI_text(gui, obj.sections[30], layertxt, 5, c, -3, nil, nil, 4)
        local tag = 'NO TAG'
        c = '99 99 99'
        if lvar.tags.trackassoc[FFX.trname] then
          tag = lvar.tags.trackassoc[FFX.trname].tag
          c = '205 205 205'
        end
        GUI_text(gui, obj.sections[1005], tag, 5, c, -3, nil, nil, 4)
      end    
    else
      f_Get_SSV(colours.ibox)
      gfx.rect(obj.sections[18].x,
               obj.sections[18].y-2,
               obj.sections[18].w,
               obj.sections[18].h, 1)
      local txt
      if lvar.mode == 3 then
        txt = '< No Focused Track >'
      else
        txt = '< No Focused Plugin >'
      end
      GUI_text(gui, obj.sections[3], txt, 5, '196 0 0', 2, nil, nil, 4)
    end

  end    
  
  local function GUI_DrawFader(obj, gui, i)

    if lvar.livemode == 4 or lvar.livemode == 5 then return end

    local y = (i-1) * (fader_h+fader_space)
    local fv = 0
    local ii = i+control_offs
    local ttcol
    
    gfx.a = 1
    
    if lvar.filtidx then
      ii = lvar.filtidx[ii]
    end
    
    local tmp, glob, pglob
    tmp, gflag = GetTemplate(ii)
    local tmppos = tmp.pos[ii]
    
    if tmppos then
      fv = F_limit((tmppos.val or 0)/16383,0,1)
    end
    
    local fw = fader_w - 10
    
    local clm, rw, pxywh3_w
    local pxywh1, pxywh2, pxywh3
    if lvar.pcolumns > 1 or lvar.display_mini then
      ycnt = math.floor(obj.sections[50].h / (fader_h+fader_space))
      local clm = math.floor((i-1) / ycnt)
      local rw = ((i-1) % ycnt)*(fader_h+fader_space)
      --slot
      pxywh1 = {x = obj.sections[50].x + clm*(pname_w),
               y = obj.sections[50].y + rw,
               w = box_w,
               h = fader_h}
      pxywh2 = {x = pxywh1.x+pxywh1.w+2,
               y = obj.sections[50].y + rw,
               w = box_w,
               h = fader_h}
      pxywh3 = {x = pxywh2.x+pxywh2.w+8,
               y = obj.sections[50].y + rw,
               w = pname_w - (box_w+10)*2 - 10,
               h = fader_h}
               
      --[[pxywh3 = {x = pxywh2.x+pxywh2.w+8,
                y = obj.sections[50].y + rw,
                w = pname_w - (box_w)*2+18 -ccw - 18,
                h = fader_h}]]
               
      pxywh3_w = pxywh3.w
    else
      rw = (i-1)*(fader_h+fader_space)
      pxywh1 = {x = obj.sections[50].x,
               y = obj.sections[50].y + rw,
               w = box_w,
               h = fader_h}
      pxywh2 = {x = pxywh1.x+pxywh1.w+2,
               y = obj.sections[50].y + rw,
               w = box_w,
               h = fader_h}
      pxywh3 = {x = pxywh2.x+pxywh2.w+8,
               y = obj.sections[50].y + rw,
               w = pname_w - (box_w+10)*2+18,
               h = fader_h}
      pxywh3_w = pxywh3.w
    end
    
    local drawbtn
    local dbw = 0
    if tmppos and ctl_template.fader[ii].lmode == 4 and (lvar.pcolumns > 1 or lvar.display_mini) then
      drawbtn = true
      dbw = pxywh3.h
      pxywh3 = {x = pxywh3.x, y = pxywh3.y, w = pxywh3.w-dbw, h = pxywh3.h}
    end
    
    --[[if lvar.pcolumns == 1 and not lvar.display_mini then
      f_Get_SSV(colours.faderbg)
      gfx.rect(obj.sections[1].x,
               obj.sections[1].y + y,
               fw,
               fader_h, 1)
    end]]
                     
    local pname, c, f, tsz, col
    
    local pt = -1
    if tmppos then
      pt = tmppos.ptype or -1
    end

    if pt ~= -1 then
      if (tmppos.scribov or tmppos.name or '') ~= '' then
        pname = tmppos.name or tmppos.scribov  
      else
        pname = tmppos.host_pname or tmppos.pname
      end
      ccv = ptype_txt[tmppos.ptype or -1] or '-'
      --col = gui.color.blue      
      bcol = colours.devctlassigned
      f = 1
    else
      pname = ''
      col = colours.faderunassigned
      ttcol = colours.faderunassigned_txt 
      bcol = colours.devctlunassigned
      f = 1            
      ccv = '-'
    end
    
    if pt >= 1 then
      --tsz = -4
    --elseif pt > 1 then
      tsz = ptype_info[pt].tsz
      col = ptype_info[pt].col
      ttcol = ptype_info[pt].btntxt 
      
      --unassigned
      if tmppos.ptype == ptype.internal and tmppos.code == -1 then
        pname = ''
        col = colours.faderunassigned
        ttcol = colours.faderunassigned_txt 
        bcol = colours.devctlunassigned
        f = 1            
        ccv = '-'
      end
    end

    if tmppos and tmppos.ptype == ptype.cc and tmppos.cc14bit == 1 then
      ccv = 'CC14'
      tsz = -4      
    end
    
    local ccw = 60
    f_Get_SSV(bcol)
    gfx.rect(pxywh3.x,
             pxywh3.y,
             pxywh3_w-ccw,
             pxywh3.h, f)
    gfx.rect(pxywh3.x+pxywh3_w-(ccw-1),
             pxywh3.y,
             ccw-1,
             pxywh3.h, f)

    local ww = lvar.sscolbox_w             
    if tmppos and ctl_template.fader[ii].sscolor then
      local p = 0.7
      --local ww = lvar.sscolbox_w --math.floor(pxywh3.h/2)
      local hh = fader_h
      local cc = tmppos.sscolor or 7
      local xx = pxywh3.x
      if cc&16 == 16 and cc&32 == 32 then
        f_Get_SSV_dim(tab_xtouch_colors[cc&7].c, p)
        gfx.rect(xx,
                 pxywh3.y,
                 ww,
                 hh, 1)      
      else        
        f_Get_SSV_dim(tab_xtouch_colors[cc&7].c, p)
        gfx.rect(xx,
                 pxywh3.y,
                 ww,
                 hh, 1)      
        if cc&16 == 0 then
          f_Get_SSV(bcol)
          gfx.rect(xx+1,
                   pxywh3.y+1,
                   ww-2,
                   math.floor(hh/2)-1, 1)                
        end
        if cc&32 == 0 then
          f_Get_SSV(bcol)
          gfx.rect(xx+1,
                   pxywh3.y+math.floor(hh/2),
                   ww-2,
                   math.floor(hh/2)-1, 1)
        end
        
      end
      
      pxywh3.x = pxywh3.x + ww + 2
      pxywh3.w = pxywh3.w - ww - 2
    end
    
    local btnoff = 0
    if tmppos and tmppos.ptype == ptype.cc then
      local pname
      if tmppos.ccchan == -1 then
        pname = '<Please select>'
      elseif tmppos.name then
        pname = tmppos.name
      else
        pname = 'Chan '..string.format('%i',tmppos.ccchan+1)..' CC '..string.format('%i',tmppos.ccnum)
      end
      
      local xywh = pxywh3
      gfx.a = 0.25
      if lvar.ccstamp_active == 1 then
        gfx.a = 1
      end
      local gmem = reaper.gmem_read
      local ccval = tmppos.defcc_val or gmem(lvar.gm_ccstamp.defcc_val+tmp.pos[ii].ccnum)
      
      if (ccval or -1) ~= -1 then
        local xywh2 = {x = pxywh3.x+pxywh3.w-ccw+1, y = pxywh3.y+1, w = ccw-2, h = pxywh3.h-2}
        local enabled = gmem(lvar.gm_ccstamp.cc_enabled+tmp.pos[ii].ccnum)
        if enabled ~= 1 then 
          gfx.a = 0.25
        end
        f_Get_SSV(col)
        local f, tc = 1, '0 0 0'
        if not tmppos.defcc_val then
          f = 0
          if lvar.ccstamp_active == 1 and enabled == 1 then
            tc = col
          else
            tc = Color_dim(col, 0.25)
          end
        end
        gfx.rect(xywh2.x,xywh2.y,xywh2.w,xywh2.h,f)
        GUI_text(gui, xywh2, string.format('%i',ccval), 5, tc, -2, nil, nil, nil, nil, 1)
        if enabled ~= 1 then
          --gfx.a = 1
          gfx.a = 0.25
          if lvar.ccstamp_active == 1 then
            gfx.a = 1
          end
          f_Get_SSV('255 0 0')
          gfx.rect(xywh2.x,xywh2.y,xywh2.w,xywh2.h,0)
        end

        --xywh = {x = pxywh3.x, y = pxywh3.y, w = pxywh3.w-30, h = pxywh3.h}
        
      end
      gfx.a = 1

      xywh.w = xywh.w - ccw
      btnoff = 30
      local col = col
      if lvar.showcontrolname then
        local txt = ''
        if ctl_template.fader[ii].devbus ~= -1 then
          txt = '['..string.format('%i', ctl_template.fader[ii].devbus+1)..'] - '
        end
        pname = txt..ctl_template.fader[ii].devctl --..' '..pname
        if lvar.overtemplate_active and gflag == 1 then
          col = colours.devctlname
        end
      end
      GUI_text(gui, xywh, pname, 5, col, -1, nil, 0, 4, lvar.fontzoom2, nil, true, nil, true)      

      if tmppos.polarity == 1 then
        f_Get_SSV('255 0 0')
        gfx.rect(xywh.x, xywh.y, 8, 8, 1)
      end
      
    elseif tmppos then
      local xywh = {x = pxywh3.x, y = pxywh3.y, w = pxywh3.w, h = pxywh3.h}
      if not drawbtn then
        xywh.w = xywh.w - ccw
      end
      local pname = pname
      local col = col
      if lvar.showcontrolname then
        local txt = ''
        if ctl_template.fader[ii].devbus ~= -1 then
          txt = '['..string.format('%i', ctl_template.fader[ii].devbus+1)..'] - '
        end
        pname = txt..ctl_template.fader[ii].devctl --..' '..pname
        if lvar.overtemplate_active and gflag == 1 then
          col = colours.devctlname
        end
      end
      GUI_text(gui, xywh, pname, 5, col, -1, nil, 0, 4, lvar.fontzoom2, nil, true, nil, true)      
    
      if tmppos.polarity == 1 then
        f_Get_SSV('255 0 0')
        gfx.rect(xywh.x, xywh.y, 8, 8, 1)
      end
      
      gfx.a = 0.25
      if lvar.ccstamp_active == 1 then
        gfx.a = 1
      end
      if tmppos.printval and (tmppos.ptype == ptype.host or tmppos.ptype == ptype.track) then
        local xywh2 = {x = pxywh3.x+pxywh3.w-ccw+1, y = pxywh3.y+1, w = ccw-2, h = pxywh3.h-2}
        f_Get_SSV(col)
        local f, tc = 1, '0 0 0'
        gfx.rect(xywh2.x,xywh2.y,xywh2.w,xywh2.h,f)
        GUI_text(gui, xywh2, tmppos.printvaldv, 5, tc, -2, nil, nil, nil, nil, 1)
      end
      gfx.a = 1
      
    elseif ctl_template.fader[ii] then
      if ctl_template.fader[ii].devctl then
        local txt = ''
        if ctl_template.fader[ii].devbus ~= -1 then
          txt = '['..string.format('%i', ctl_template.fader[ii].devbus+1)..'] - '
        end
        local xywh = {x = pxywh3.x, y = pxywh3.y, w = pxywh3.w-ccw, h = pxywh3.h}
        GUI_text(gui, xywh, txt..ctl_template.fader[ii].devctl, 5, colours.devctlname, -1, nil, 0, 4, lvar.fontzoom2, nil, true, nil, true)      
      end
    end    
    
    
    local oset
    if recmode == 1 then
      --[[DBG(ii..'  '..tostring(lvar.ss_color_override[ii])..'  '..tostring(lvar.ss_color_override_color))
      for a, b in pairs(lvar.ss_color_override) do 
        DBG(a..'  '..tostring(b))
      end]]
      if (lvar.ss_color_override_enabled and lvar.ss_color_override[ii] == lvar.ss_color_override_color) then        
        col = tab_xtouch_colors[lvar.ss_color_override_color].c
        ttcol = tab_xtouch_colors[lvar.ss_color_override_color].tc or ttcol
        oset = true
      elseif (lvar.ss_color_override_nonautomatable and lvar.ss_color_override[ii] == lvar.ss_color_override_nonautomatable_color) then        
        col = tab_xtouch_colors[lvar.ss_color_override_nonautomatable_color].c
        ttcol = tab_xtouch_colors[lvar.ss_color_override_nonautomatable_color].tc or ttcol
        oset = true        
      elseif fader_touch[ii] then
        col = '205 205 205'
        oset = true
      end
    end
    
    f_Get_SSV(col)
    gfx.rect(pxywh2.x+1,
             pxywh2.y+1,
             pxywh2.w-2,
             pxywh2.h-2, 1)
    f_Get_SSV_dim(col,0.5)
    gfx.rect(pxywh2.x,
             pxywh2.y,
             pxywh2.w,
             pxywh2.h, 0)
    GUI_text(gui, pxywh2, ccv, 5, ttcol, tsz, nil, nil, nil, nil, 1)

    if oset then
      f_Get_SSV(col)
    else
      if gflag == 3 then
        f_Get_SSV(colours.permafader)
        ttcol = colours.permafader_txt    
      elseif gflag == 2 then
        f_Get_SSV(colours.globalfader)
        ttcol = colours.globalfader_txt
      elseif gflag == 4 then
        f_Get_SSV(colours.layerfader)
        ttcol = colours.layerfader_txt
      elseif gflag == 1 then
        --f_Get_SSV(col)
        if tmppos then
          f_Get_SSV(colours.mainfader)
          ttcol = colours.mainfader_txt
        else
          f_Get_SSV(col)
        end
      elseif gflag == 6 then
        if tmppos then
          f_Get_SSV(col)
        else
          f_Get_SSV(colours.faderunassigned)
        end
      else
        if tmppos and tmppos.ptype == ptype.internal and tmppos.code == -1 then
          f_Get_SSV(colours.faderunassigned)
        else
          f_Get_SSV(colours.layerfader)
        end
      end
    end
    local fr = 1
    local frcol = ttcol
    local iii = ii
    if lvar.remap.ctl[ii] then
      fr = 0
      if lvar.remap_active then
        frcol = lvar.current_colour
      else
        frcol = gui.color.red
      end
    elseif lvar.remap.ctl2[ii] then
      if lvar.remap_active then
        fr = 0
        frcol = gui.color.red
        f_Get_SSV(frcol)
        --iii = lvar.remap.ctl2[ii]
      end
    end
    gfx.rect(pxywh1.x,
             pxywh1.y,
             pxywh1.w,
             pxywh1.h, fr)
    --[[gfx.rect(pxywh1.x+1,
             pxywh1.y+1,
             pxywh1.w-2,
             pxywh1.h-2, fr)
    f_Get_SSV_dim(col,0.5)
    gfx.rect(pxywh1.x,
             pxywh1.y,
             pxywh1.w,
             pxywh1.h, 0)]]
    GUI_text(gui, pxywh1, string.format('%i',round(iii)), 5, frcol, 1, nil, nil, nil, nil, 1)

    --[[if lvar.pcolumns > 1 or lvar.display_mini then
      f_Get_SSV('24 24 24')
      gfx.rect(pxywh3.x+1, 
               pxywh3.y + pxywh3.h - 3,
               (pxywh3.w-2),
               2, 1)
    end]]
        
    if tmppos and pt ~= -1 then
      
      local bordcol = colours.faderborder
      local flit, fdim --= colours.faderlit, colours.faderdim 
      if tmppos.ptype == ptype.cc then
        if lvar.chasedok ~= false then
          flit = ptype_info[pt].col
          fdim = ptype_info[pt].dimcol        
        else
          flit = '128 0 0'
          fdim = ptype_info[pt].dimcol
          bordcol = '64 0 0'
        end
      else
        flit = ptype_info[pt].col
        fdim = ptype_info[pt].dimcol
      --[[elseif tmppos.ptype == ptype.track then
        flit = colours.faderlittr
      elseif tmppos.ptype == ptype.host then
        flit = colours.faderlit
      elseif tmppos.ptype == ptype.action then
        flit = colours.faderlitac
      elseif tmppos.ptype == ptype.internal then
        flit = colours.faderlitint  ]]    
      end
      
      if lvar.pcolumns == 1 and not lvar.display_mini then
        if ctl_template.fader[ii].lmode == 4 then
          f_Get_SSV(colours.faderbg2)
          gfx.rect(obj.sections[1].x,
                   obj.sections[1].y + y,
                   fw,
                   fader_h, 1)        
        else
          f_Get_SSV(bordcol)
          gfx.rect(obj.sections[1].x,
                   obj.sections[1].y + y,
                   fw,
                   fader_h, 1)
          f_Get_SSV(colours.faderbg2)
          gfx.rect(obj.sections[1].x+2,
                   obj.sections[1].y + y+2,
                   fw-4,
                   fader_h-4, 1)
        end
      end

      if (lupd.update_gfx ~= true or lupd.update_forceflash) and tmp.dirty[ii] == true then
        f_Get_SSV(flit)
        tmp.sft[ii] = reaper.time_precise() + fadedel_s
        tmp.eft[ii] = reaper.time_precise() + fadedel_e
        tmp.dirty[ii] = nil
        
      elseif tmp.sft[ii] and tmp.sft[ii] > reaper.time_precise() then
        f_Get_SSV(flit)
    
      elseif tmp.sft[ii] and tmp.sft[ii] <= reaper.time_precise() and tmp.eft[ii] > reaper.time_precise() then
        local fade = inSine((reaper.time_precise() - tmp.sft[ii]) / (tmp.eft[ii] - tmp.sft[ii]))
        f_Get_SSV_fade(flit, fdim, fade)
    
      elseif tmp.eft[ii] and tmp.eft[ii] <= reaper.time_precise() then
      
        tmp.sft[ii] = nil
        tmp.eft[ii] = nil
        sfade = nil
        efade = nil
        f_Get_SSV(fdim)
        tmp.dirty[ii] = nil
      else
    
        f_Get_SSV(fdim)
        tmp.dirty[ii] = nil
      end
      if lupd.update_gfx ~= true and tmp.dirty[ii] == true then
        col = colours.pnamelit
      else
        col = gui.color.blue      
      end      

      if lvar.pcolumns == 1 and not lvar.display_mini then
        if ctl_template.fader[ii].lmode == 4 then
          gfx.rect(obj.sections[1].x+4,
                   obj.sections[1].y + y+4,
                   (fw-8),
                   fader_h-8, 0)
          if tmppos.valind then
            gfx.rect(obj.sections[1].x+6,
                     obj.sections[1].y + y+6,
                     (fw-12),
                     fader_h-12, 1)
          end
        else
          gfx.rect(obj.sections[1].x+4,
                   obj.sections[1].y + y+4,
                   (fw-8)*(fv or 0),
                   fader_h-8, 1)
        end
      else
        if ctl_template.fader[ii].lmode == 4 then
          if drawbtn then 
            local xywh2 = {x = pxywh3.x+pxywh3.w+btnoff, y = pxywh3.y+1, w = dbw, h = pxywh3.h-2}
            --f_Get_SSV(col)
            gfx.rect(xywh2.x,xywh2.y,xywh2.w,xywh2.h,0)
            if tmppos.valind then
              gfx.rect(xywh2.x+2,xywh2.y+2,xywh2.w-4,xywh2.h-4,1)            
            end 
          end
        else
          --DBG('a'..pxywh3.w)
          pxywh3.w = pxywh3.w - ccw
          gfx.rect(pxywh3.x+1,
                   pxywh3.y + pxywh3.h - 3,
                   (pxywh3.w-2)*(fv or 0),
                   2, 1)     
        end
      end
    elseif ctl_template.fader[ii] and not (lvar.pcolumns > 1 or lvar.display_mini) then
      local lmodestr
      local xywh2 = {x = obj.sections[1].x,
                     y = obj.sections[1].y + y,
                     w = fw,
                     h = fader_h}
      if ctl_template.fader[ii].lmode == 4 then
        lmodestr = 'BUTTON'
      else
        lmodestr = 'FADER'
      end
      GUI_text(gui, xywh2, lmodestr, 5, colours.devctlname, -1, nil, 0, 4, lvar.fontzoom2, nil, true, nil, true)
    end
    --DBG(tmp.dirty[ii])
  end   

  local function GUI_DrawFader_bar(obj, gui, i)

    if lvar.livemode == 4 or lvar.livemode == 5 then return end
    
    local y = (i-1) * (fader_h+fader_space)
    local fv = 0
    local ii = i+control_offs
    local ttcol
    
    gfx.a = 1
    --gfx.dest = -1
    if lvar.filtidx then
      ii = lvar.filtidx[ii]
    end
    
    local tmp, gflag
    tmp, gflag = GetTemplate(ii)
    --[[if permatemplate.pos[ii] then
      tmp = permatemplate        
      pglob = true
    elseif globtemplate.pos[ii] and lvar.showglobalmap then
      tmp = globtemplate
      glob = true
    else
      tmp = template
      glob = false
    end]]
    local tmppos = tmp.pos[ii]
    
    if tmppos then
      fv = F_limit((tmppos.val or 0)/16383,0,1)
      --DBG(fv)
    end
    
    local pt = -1
    if tmppos then
      pt = tmppos.ptype or -1
    end
    
    local fw = fader_w - 10
    
    local clm, rw
    local pxywh1, pxywh2, pxywh3
    local ccw = 60
    
    if lvar.pcolumns > 1 or lvar.display_mini then
      ycnt = math.floor(obj.sections[50].h / (fader_h+fader_space))
      local clm = math.floor((i-1) / ycnt)
      local rw = ((i-1) % ycnt)*(fader_h+fader_space)
      local xx = obj.sections[50].x + clm*(pname_w) +(box_w*2)+10 
      pxywh3 = {x = xx,
               y = obj.sections[50].y + rw,
               --w = pname_w - (box_w)*2+18 -ccw - 18,
               w = pname_w - (box_w+10)*2 - 10,
               h = fader_h}
               
               
    else
      rw = (i-1)*(fader_h+fader_space)
      local xx = obj.sections[50].x + box_w*2 + 18
      --[[pxywh3 = {x = xx,
               y = obj.sections[50].y + rw,
               w = pname_w - (box_w+10)*2,
               h = fader_h}]]
      pxywh3 = {x = xx,
                 y = obj.sections[50].y + rw,
                 w = pname_w - (box_w+10)*2+18,
                 h = fader_h}
    end
    local drawbtn
    local dbw = 0
    if tmppos and ctl_template.fader[ii].lmode == 4 and (lvar.pcolumns > 1 or lvar.display_mini) then
      drawbtn = true
      dbw = pxywh3.h
      pxywh3 = {x = pxywh3.x, y = pxywh3.y, w = pxywh3.w-dbw, h = pxywh3.h}
      
    end
    
    --[[if lvar.pcolumns == 1 and not lvar.display_mini then
      f_Get_SSV(colours.faderbg)
      gfx.rect(obj.sections[1].x,
               obj.sections[1].y + y,
               fw,
               fader_h, 1)
    --[ [else
      f_Get_SSV('24 24 24')
      gfx.rect(pxywh3.x+1,
               pxywh3.y + pxywh3.h - 3,
               (pxywh3.w-2),
               2, 1)]]
    --end

    local btnoff = 0
    if tmppos then
      
      local bordcol = colours.faderborder
      local flit, fdim --= colours.faderlit, colours.faderlit 
      if tmppos.ptype == ptype.cc then
        if lvar.chasedok ~= false then
          flit = ptype_info[pt].col
          fdim = ptype_info[pt].dimcol
        else
          flit = '128 0 0'
          fdim = ptype_info[pt].dimcol
          bordcol = '64 0 0'
        end
        btnoff = 30
        pxywh3.w = pxywh3.w - 30
      else
        flit = ptype_info[pt].col
        fdim = ptype_info[pt].dimcol
      
      --[[elseif tmppos.ptype == ptype.track then
        flit = colours.faderlittr
      elseif tmppos.ptype == ptype.host then
        flit = colours.faderlit
      elseif tmppos.ptype == ptype.action then
        flit = colours.faderlitac
      elseif tmppos.ptype == ptype.internal then
        flit = colours.faderlitint      ]]
      end
      
      if lvar.pcolumns == 1 and not lvar.display_mini then
        if ctl_template.fader[ii].lmode == 4 then
          f_Get_SSV(colours.faderbg2)
          gfx.rect(obj.sections[1].x,
                   obj.sections[1].y + y,
                   fw,
                   fader_h, 1)        
        else
          f_Get_SSV(bordcol)
          gfx.rect(obj.sections[1].x,
                   obj.sections[1].y + y,
                   fw,
                   fader_h, 1)
          f_Get_SSV(colours.faderbg2)
          gfx.rect(obj.sections[1].x+2,
                   obj.sections[1].y + y+2,
                   fw-4,
                   fader_h-4, 1)
        end
      else
        if tmppos and ctl_template.fader[ii].sscolor then
          local ww = lvar.sscolbox_w --math.floor(pxywh3.h/2)
          pxywh3.x = pxywh3.x+ww+2
          pxywh3.w = pxywh3.w-ww-2
        end
        f_Get_SSV('25 25 25')
        gfx.rect(pxywh3.x+1,
                 pxywh3.y + pxywh3.h - 3,
                 (pxywh3.w-ccw-2),
                 2, 1)
      end
      
      if lupd.update_gfx ~= true and tmp.dirty[ii] == true then
        f_Get_SSV(flit)
        tmp.sft[ii] = reaper.time_precise() + fadedel_s
        tmp.eft[ii] = reaper.time_precise() + fadedel_e
        tmp.dirty[ii] = nil
        
      elseif tmp.sft[ii] and tmp.sft[ii] > reaper.time_precise() then
        f_Get_SSV(flit)
    
      elseif tmp.sft[ii] and tmp.sft[ii] <= reaper.time_precise() and tmp.eft[ii] > reaper.time_precise() then
        local fade = inSine((reaper.time_precise() - tmp.sft[ii]) / (tmp.eft[ii] - tmp.sft[ii]))
        f_Get_SSV_fade(flit, fdim, fade)
    
      elseif tmp.eft[ii] and tmp.eft[ii] <= reaper.time_precise() then
      
        tmp.sft[ii] = nil
        tmp.eft[ii] = nil
        sfade = nil
        efade = nil
        f_Get_SSV(fdim)
        tmp.dirty[ii] = nil
      else
    
        f_Get_SSV(fdim)
        tmp.dirty[ii] = nil
      end
      if lupd.update_gfx ~= true and tmp.dirty[ii] == true then
        col = colours.pnamelit
      else
        col = gui.color.blue      
      end      

      if lvar.pcolumns == 1 and not lvar.display_mini then
        if ctl_template.fader[ii].lmode == 4 then
          gfx.rect(obj.sections[1].x+4,
                   obj.sections[1].y + y+4,
                   (fw-8),
                   fader_h-8, 0)
          if tmppos.valind then
            gfx.rect(obj.sections[1].x+6,
                     obj.sections[1].y + y+6,
                     (fw-12),
                     fader_h-12, 1)
          end
        else
          gfx.rect(obj.sections[1].x+4,
                   obj.sections[1].y + y+4,
                   (fw-8)*(fv or 0),
                   fader_h-8, 1)
        end
      else
        if ctl_template.fader[ii].lmode == 4 then
          if drawbtn then
            local xywh2 = {x = pxywh3.x+pxywh3.w+btnoff, y = pxywh3.y+1, w = dbw, h = pxywh3.h-2}
            --f_Get_SSV(col)
            gfx.rect(xywh2.x,xywh2.y,xywh2.w,xywh2.h,0)
            if tmppos.valind then
              gfx.rect(xywh2.x+2,xywh2.y+2,xywh2.w-4,xywh2.h-4,1)
            end 
          end
        else
          --DBG('b '..pxywh3.w)
          gfx.rect(pxywh3.x+1,
                   pxywh3.y + pxywh3.h - 3,
                   (pxywh3.w-ccw-2)*(fv or 0),
                   2, 1)      
        end
      end
    end
    --gfx.dest = 1
  end

  function GUI_DrawSelectMarker(obj, gui)

    if lvar.gfxselectedfader --[[and lvar.oselectedfader ~= lvar.selectedfader]] then
      local i = lvar.gfxselectedfader
      if lvar.filtidx2 then
        i = lvar.filtidx2[i] or -1
      end
      i = i-control_offs

      local pxywh1
      if lvar.pcolumns > 1 or lvar.display_mini then
        ycnt = math.floor(obj.sections[50].h / (fader_h+fader_space))
        local clm = math.floor((i-1) / ycnt)
        local rw = ((i-1) % ycnt)*(fader_h+fader_space)
        pxywh1 = {x = obj.sections[50].x + clm*(pname_w),
                 y = obj.sections[50].y + rw,
                 w = box_w,
                 h = fader_h}
      else
        rw = (i-1)*(fader_h+fader_space)
        pxywh1 = {x = obj.sections[50].x,
                 y = obj.sections[50].y + rw,
                 w = box_w,
                 h = fader_h}
      end
    
      if (i-1) >= 0 then
        f_Get_SSV(colours.mainbg)
        gfx.rect(pxywh1.x-8,
                 pxywh1.y+2,
                 7,
                 pxywh1.h-4, 1)        
      end
    end
    if lvar.selectedfader then
      local i = lvar.selectedfader
      if lvar.filtidx2 then
        i = lvar.filtidx2[i] or -1
      end
      i = i-control_offs
     
      local pxywh1
      if lvar.pcolumns > 1 or lvar.display_mini then
        ycnt = math.floor(obj.sections[50].h / (fader_h+fader_space))
        local clm = math.floor((i-1) / ycnt)
        local rw = ((i-1) % ycnt)*(fader_h+fader_space)
        pxywh1 = {x = obj.sections[50].x + clm*(pname_w),
                 y = obj.sections[50].y + rw,
                 w = box_w,
                 h = fader_h}
      else
        rw = (i-1)*(fader_h+fader_space)
        pxywh1 = {x = obj.sections[50].x,
                 y = obj.sections[50].y + rw,
                 w = box_w,
                 h = fader_h}
      end

      if (i-1) >= 0 then
        f_Get_SSV('205 205 205')
        gfx.rect(pxywh1.x-8,
                 pxywh1.y+2,
                 6,
                 pxywh1.h-4, 1)
      end
    end
  
  end

  function GUI_DrawFaders(obj, gui)
  
    --lvar.update_dest1 = true
    
    local DrawFader
    --DBG(tostring(lupd.update_gfx)..' '..tostring(lupd.update_fader)..' '..tostring(lupd.update_faderbar))
    if lupd.update_gfx or lupd.update_fader then
      DrawFader = GUI_DrawFader
    else
      DrawFader = GUI_DrawFader_bar
      --lvar.update_dest1 = false
    end

    if lvar.selectedfader ~= lvar.gfxselectedfader or lupd.update_gfx then
      GUI_DrawSelectMarker(obj, gui)
      lvar.gfxselectedfader = lvar.selectedfader
    end    
  
    if lvar.pcolumns > 1 or lvar.display_mini then
      local viscnt = math.floor(obj.sections[50].h/(fader_h + fader_space)) * lvar.pcolumns
      
      for i = 1, viscnt do
      
        if lvar.filtidx then
          ii = lvar.filtidx[i+control_offs]
        else
          ii = i+control_offs
        end
      
        local tmp
        tmp = GetTemplate(ii)
        --[[if permatemplate.pos[ii] then
          tmp = permatemplate
        elseif globtemplate.pos[ii] and lvar.showglobalmap == true then
          tmp = globtemplate
        else
          tmp = template
        end]]
      
        if ii and ii <= lvar.fcount and (lupd.update_gfx == true or lupd.update_header == true or (tmp.dirty[ii] == true) 
           or tmp.sft[ii]) then
          DrawFader(obj, gui, i)
        end
        
      end    
    else
      local viscnt = math.floor(obj.sections[1].h/(fader_h + fader_space))
      for i = 1, viscnt do

        if lvar.filtidx then
          ii = lvar.filtidx[i+control_offs]
        else
          ii = i+control_offs
        end

        local tmp
        tmp = GetTemplate(ii)
        --[[if permatemplate.pos[ii] then
          tmp = permatemplate        
        elseif globtemplate.pos[ii] and lvar.showglobalmap == true then
          tmp = globtemplate
        else
          tmp = template
        end]]
      
        if ii and ii <= lvar.fcount and (lupd.update_gfx == true or lupd.update_header == true or (tmp.dirty[ii] == true) 
           or tmp.sft[ii]) then
          DrawFader(obj, gui, i)
        end
        
      end
      
      local fc = lvar.fcountfilt or lvar.fcount
      if viscnt < fc then
        local bh = viscnt/(fc)
        local bt = math.floor((control_offs/(fc))*(obj.sections[1000].h-bh))
  
        if mouse.context == contexts.vscrollb or lvar.hlsb then
          f_Get_SSV(colours.buttcollit)
        else
          f_Get_SSV(colours.ibox)
        end
        gfx.rect(obj.sections[1000].x,
                 math.min(obj.sections[1000].y+bt, obj.sections[1000].y+obj.sections[1000].h-(bh*obj.sections[1000].h)),
                 obj.sections[1000].w,
                 bh*obj.sections[1000].h, 1)
      end
    end

  end

  function inCubic(t)
    return t^3
  end
  
  function outCubic(t)
    if t < 0 then
      t = -t - 1
      return -(t^3 + 1)
    else
      t = t - 1
      return t^3 + 1
    end
  end
  
  function inSine(t)
    if t < 0 then
      return -(-1 * math.cos(-t * (pi / 2)) + 1)
    else
      return -1 * math.cos(t * (pi / 2)) + 1
    end
  end
  
  function outSine(t)
    return 1 * math.sin(t * (pi / 2))
  end
    
  ------------------------------------------------------------
  
  function Lokasenna_Window_At_Center (w, h)
    -- thanks to Lokasenna 
    -- http://forum.cockos.com/showpost.php?p=1689028&postcount=15    
    local l, t, r, b = 0, 0, w, h    
    local __, __, screen_w, screen_h = reaper.my_getViewport(l, t, r, b, l, t, r, b, 1)    
    local x, y = (screen_w - w) / 2, (screen_h - h) / 2    
    gfx.init(lvar.wintit, w, h, 0, x, y)  
  end

 -------------------------------------------------------------     
      
  function F_limit(val,min,max)
      if val == nil or min == nil or max == nil then return end
      local val_out = val
      if val < min then val_out = min end
      if val > max then val_out = max end
      return val_out
    end   
  ------------------------------------------------------------
  
  --[[function MOUSE_slider(b)
    if mouse.mx > b.x and mouse.mx < b.x+b.w
      --and mouse.my > b.y and mouse.my < b.y+b.h 
      and mouse.LB then
     return math.floor(100*(mouse.mx-40) / (b.w-80))/100
    end 
  end]]
  
  function MOUSE_slider_horiz(b,xoff)
    if mouse.LB then
      if xoff == nil then xoff = 0 end
      local mx = mouse.mx - (b.x-200) + xoff
     return (mx) / (b.w+400)
    end 
  end
  
  function MOUSE_slider_horiz2(b,xoff)
    if mouse.LB then
      if xoff == nil then xoff = 0 end
      local mx = mouse.mx - (b.x)
     return (mx) / (b.w)
    end 
  end
  
  function MOUSE_slider(b,yoff)
    if mouse.LB then
      if yoff == nil then yoff = 0 end
      local my = mouse.my - (b.y-200) + yoff
     return (my) / (b.h+400)
      --local my = mouse.my - b.y - yoff
      --return (my+200) / 400
    end 
  end
    
  function MOUSE_click(b)
    if mouse.mx > b.x and mouse.mx < b.x+b.w
      and mouse.my > b.y and mouse.my < b.y+b.h 
      and mouse.LB 
      and not mouse.last_LB then
     return true 
    end 
  end

  function MOUSE_clickX(b, mx, my)
    if mx > b.x and mx < b.x+b.w
      and my > b.y and my < b.y+b.h 
      and mouse.LB 
      and not mouse.last_LB then
     return true 
    end 
  end

  function MOUSE_click_RB(b)
    if mouse.mx > b.x and mouse.mx < b.x+b.w
      and mouse.my > b.y and mouse.my < b.y+b.h 
      and mouse.RB 
      and not mouse.last_RB then
     return true 
    end 
  end

  function MOUSE_over(b)
    if mouse.mx > b.x and mouse.mx < b.x+b.w
      and mouse.my > b.y and mouse.my < b.y+b.h 
      then
     return true 
    end 
  end

  function MOUSE_overX(b, mx, my)
    if mx > b.x and mx < b.x+b.w
      and my > b.y and my < b.y+b.h 
      then
     return true 
    end 
  end
  
  ------------------------------------------------------------

  function GetTrackChunk(track,usefix)
 
    if not track then return end
    if usefix then
      local fast_str, track_chunk
      fast_str = reaper.SNM_CreateFastString("")
      if reaper.SNM_GetSetObjectState(track, fast_str, false, false) then
      track_chunk = reaper.SNM_GetFastString(fast_str)
      end
      reaper.SNM_DeleteFastString(fast_str)  
      return track_chunk
    else
      local _, chunk = reaper.GetTrackStateChunk(track,'',false)
      return chunk
    end
  end

  function SetTrackChunk(track, track_chunk)
    if not (track and track_chunk) then return end
    if usefix then
      local fast_str, ret
      fast_str = reaper.SNM_CreateFastString("")
      if reaper.SNM_SetFastString(fast_str, track_chunk) then
        ret = reaper.SNM_GetSetObjectState(track, fast_str, true, false)
      end
      reaper.SNM_DeleteFastString(fast_str)
      return ret
    else
      return reaper.SetTrackStateChunk(track,track_chunk,false)
    end
  end
  
  function GetCtlTrackFound()

    --find non monitored tracks
    CheckFOLGUID()
    CheckOUTGUID()
    CheckINPUTCCGUID()
    
    --DBG('FOUND TRACKS')
    --DBG(LBX_CTL_TRACK)
    --DBG(LBX_CC_TRACK)
    --DBG(LBX_RR_TRACK)
    --DBG(LBX_IN_TRACK)
    local found = {}
    found[LBX_CTL_TRACK or -1] = true
    found[LBX_CC_TRACK or -1] = true
    found[LBX_RR_TRACK or -1] = true
    found[LBX_IN_TRACK or -1] = true
    found[LBX_FOL_TRACK or -1] = true
    
    for i = 1, #LBX_OUT_TRACKS do
      found[LBX_OUT_TRACKS[i]] = true
      --DBG(LBX_OUT_TRACKS[i])
    end
    for i = 1, #LBX_INPUT_TRACKS do
      found[LBX_INPUT_TRACKS[i]] = true
      --DBG(LBX_INPUT_TRACKS[i])
    end
    for i = 1, #LBX_INPUTCC_TRACKS do
      found[LBX_INPUTCC_TRACKS[i]] = true
      --DBG(LBX_INPUTCC_TRACKS[i])
    end
    
    lvar.ctltracks = found
    --lvar.track_internal_min = #found+1
    lvar.ctltracks.count = lvar.trackinfo.count
    
  end
  
  function GetFocusedFX(force)
  
    local FFX
    local ret, trn, itmnum, fxnum, lostfocus
    
    if lvar.js_avail == true and lvar.automodeswitch == 1 then
      local hwnd = reaper.JS_Window_GetForeground()
      if hwnd then
        local tit = reaper.JS_Window_GetTitle(hwnd,'')
        local fhwnd = reaper.JS_Window_GetFocus()
        local sw = ''
        if fhwnd then
          sw = reaper.JS_Window_GetTitle(fhwnd,'')
        end
        --DBG(sw)
        if sw ~= lvar.wintit and sw ~= 'SK2 FADER PROPERTIES' and sw ~= '- LBX Stripper -' then
          if string.match(tit,'VST.*: ') or string.match(tit,'JS: ') then
            if lvar.mode == 3 then
              SetMode(1)
            end
          else
            if lvar.mode ~= 3 then
              SetMode(3)
            end
          end
        else
          --is script window
          
        end
      end
      --DBG(reaper.JS_Window_GetTitle(hwnd,''))
    end
    
    local found = lvar.ctltracks

    if lvar.mode ~= 3 then
      if lvar.fxsel_mode == 1 then

        local track = reaper.GetSelectedTrack2(0, 0, true)
        ret = 0
        if track then
          trn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
          local fxc = reaper.TrackFX_GetCount(track)
          local guid
          if lvar.fxsel_focusedfx_fxnum then
            guid = reaper.TrackFX_GetFXGUID(track, lvar.fxsel_focusedfx_fxnum)
          end
          if trn ~= lvar.fxsel_trn or fxc ~= lvar.fxsel_cnt or (guid and guid ~= lvar.fxsel_focusedfx_guid) then
            local guid
            if trn == lvar.fxsel_trn then
              guid = lvar.fxsel_focusedfx_guid
            end
            lvar.fxsel_trn = trn
            lvar.fxsel_cnt = fxc
            if lvar.fxsel_plugtype == 1 and lvar.fxsel_focusedfx then
              lvar.fxsel_slot = -1
              local fnd
              if guid then
                for f = 0, reaper.TrackFX_GetCount(track)-1 do
                  if guid == reaper.TrackFX_GetFXGUID(track, f) then
                    lvar.fxsel_slot = f
                    fnd = true
                    break
                  end
                end
              end
              if not fnd then
                for f = 0, reaper.TrackFX_GetCount(track)-1 do
                  local _, fxname = reaper.TrackFX_GetFXName(track, f, '')
                  local _, fx = reaper.BR_TrackFX_GetFXModuleName(track, f, '', 128)
                  if lvar.mode == 1 then
                    if fx == lvar.fxsel_focusedfx_module then
                      lvar.fxsel_slot = f
                      break
                    end
                  elseif lvar.mode == 2 then
                    if fxname == lvar.fxsel_focusedfx then
                      lvar.fxsel_slot = f
                      break
                    end
                  end
                end
              end
            end
          end
          fxnum = math.min(lvar.fxsel_slot, reaper.TrackFX_GetCount(track)-1)
          if fxnum >= 0 then
            ret = 1
            local _, fxname = reaper.TrackFX_GetFXName(track, fxnum, '')
            local _, fx = reaper.BR_TrackFX_GetFXModuleName(track, fxnum, '', 128)
            if lvar.pluginblacklist[(fxname or '-')] or lvar.pluginblacklist[(fx or '-')] then
              return nil, 2
            end
          end
        end
      else
        
        if lvar.automodeswitch == 2 then
        
          --last touched not safe - as SK2 always touches it's own control plugins
          --For Stripper - use stripper set extstate
          reaper.gmem_attach('LBX_SK2_SharedMem')
          trn = tonumber(reaper.GetExtState('LBX_TOUCHED_FX','TRNUM'))
          if trn then
            fxnum = tonumber(reaper.GetExtState('LBX_TOUCHED_FX','FXNUM'))
            local track = GetTrack(trn)
            if track and fxnum then
              ret = 1
              local fxguid = reaper.GetExtState('LBX_TOUCHED_FX','FXGUID')
              local trguid = reaper.GetExtState('LBX_TOUCHED_FX','TRGUID')
              if fxguid ~= reaper.TrackFX_GetFXGUID(track,fxnum) then
                local trn2, trguid2, fxnum2 = FindFX(track, trguid, fxguid)
                if trn2 ~= -100 then
                  trn = trn2
                  track = GetTrack(trn)
                  trguid = trguid2
                  fxnum = fxnum2
                  reaper.SetExtState('LBX_TOUCHED_FX','TRNUM',trn,false)
                  reaper.SetExtState('LBX_TOUCHED_FX','FXNUM',fxnum,false)
                  
                  --reaper.SetExtState('LBX_TOUCHED_FX','FXGUID',fxguid,false)
                  reaper.SetExtState('LBX_TOUCHED_FX','TRGUID',trguid,false)
                else
                  ret = 0
                  reaper.SetExtState('LBX_TOUCHED_FX','TRNUM','', false)
                end
              end
              if ret ~= 0 then
                local ret, fxname = reaper.TrackFX_GetFXName(track, fxnum, '')
                local ret, fx = reaper.BR_TrackFX_GetFXModuleName(track, fxnum, '', 128)
                if lvar.pluginblacklist[(fxname or '-')] or lvar.pluginblacklist[(fx or '-')] then
                  return nil, 2
                end
              end
              --lvar.lastfocusedret = 1
              --end
            else
              ret = 0
            end
          else
            ret = 0
          end
          --[[ret, trn, fxnum = reaper.GetLastTouchedFX()
          --DBG(tostring(ret)..' '..trn..' '..fxnum)
          if ret == true then
            ret = 1
            --check against blacklist
            local track = GetTrack(trn)
            if track and fxnum then
              local ret, fxname = reaper.TrackFX_GetFXName(track, fxnum, '')
              local ret, fx = reaper.BR_TrackFX_GetFXModuleName(track, fxnum, '', 128)
              if lvar.pluginblacklist[(fxname or '-')] or lvar.pluginblacklist[(fx or '-')] then
                return nil, 2
              end
            end
          else
            ret = 0
          end]] 
        else
        
          ret, trn, itmnum, fxnum = reaper.GetFocusedFX()
          --check against blacklist
          local track = GetTrack(trn)
          if track and fxnum then
            if ret == 1 then
              local ret, fxname = reaper.TrackFX_GetFXName(track, fxnum, '')
              local ret, fx = reaper.BR_TrackFX_GetFXModuleName(track, fxnum, '', 128)
              if lvar.pluginblacklist[(fxname or '-')] or lvar.pluginblacklist[(fx or '-')] then
                return nil, 2
              end
            elseif ret == 2 then
            
            end
          end
        end
        if ret ~= 0 and trn then
          if lvar.fxsel_trn ~= trn then
            lvar.fxsel_trn = trn
            local track = GetTrack(trn)
            if track then
              lvar.fxsel_cnt = reaper.TrackFX_GetCount(track)
            end
          end
        else
          local track = reaper.GetSelectedTrack2(0, 0, true)
          if track then
            trn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
            if lvar.fxsel_trn ~= trn then
              lvar.fxsel_trn = trn
              local track = GetTrack(trn)
              if track then
                lvar.fxsel_cnt = reaper.TrackFX_GetCount(track)
              end
            end
          end
        end
      end
  
      if recmode == 0 then
        if ret == 0 and lvar.lastfocusedret ~= 0 --[[or found[trn]] then

          FFX = nil
          ofxguid = nil
          template = {dirty = {},
                      pos = {},
                      sft = {},
                      eft = {}}
          for i = 1, lvar.fcount do
            template.dirty[i] = true
          end
          
          SetCCs()
          
        elseif ret == 1 then
          --Track FX
          if not lvar.ctltracks[trn] then
            local track = GetTrack(trn)
            if track then
              local ret, fxname = reaper.TrackFX_GetFXName(track, fxnum, '')
              local fxguid = reaper.TrackFX_GetFXGUID(track, fxnum)
              if fxguid ~= ofxguid or fxnum ~= ofxnum or force == true then
  
                ofxguid = fxguid
                ofxnum = fxnum
                local ret, fx = reaper.BR_TrackFX_GetFXModuleName(track, fxnum, '', 128)
                if fx then
                  local fxnm, fxtype = string.match(fx, '(.+)%.(.*)')
                  if not fxnm then fxnm = fx end
                  fxtype = tab_fxtypeconv[fxtype] or fxtype or ''
                  fxname = TrimFXName(fxname)
                  lvar.focusedfx = fxname
                  lvar.fxsel_focusedfx = fxname
                  lvar.fxsel_focusedfx_module = fx
                  lvar.fxsel_focusedfx_guid = fxguid
                  lvar.fxsel_focusedfx_fxnum = fxnum
                  FFX = {trn = trn,
                         trguid = reaper.GetTrackGUID(track),
                         trname = reaper.GetTrackState(track),
                         fxnum = fxnum,
                         fxname = fxname,
                         fxplug = fxnm,
                         fxguid = fxguid,
                         fxtype = fxtype}
                  SetCCSend(trn)
                else
                  local trchunk = GetTrackChunk(track)
                  
                  local ffn=paths.resource_path..'chunkerror.txt'
                  
                  file=io.open(ffn,"w")
                  file:write('fxnum: '..fxnum+1 ..'\n')
                  file:write(trchunk)
                  file:close()
                  DBG('Chunk error file created at: '..ffn)
                  
                end
              else
                
              end
            end
          end      
        elseif ret == 2 then
          --Item FX
          if not lvar.ctltracks[trn] then
            local track = GetTrack(trn)
            local item = reaper.GetTrackMediaItem(track, itmnum)
            local take = reaper.GetActiveTake(item)
            if take then
            
              local ret, fxname = reaper.TakeFX_GetFXName(take, fxnum, '')
              local fxguid = reaper.TakeFX_GetFXGUID(take, fxnum)
              if fxguid ~= ofxguid or fxnum ~= ofxnum or force == true then
                ofxguid = fxguid
                ofxnum = fxnum
                local ret, fx = reaper.NF_TakeFX_GetFXModuleName(item, fxnum, '', 128)
                if fx then
                  local fxnm, fxtype = string.match(fx, '(.+)%.(.*)')
                  if not fxnm then fxnm = fx end
                  fxtype = tab_fxtypeconv[fxtype] or fxtype or ''
                  fxname = TrimFXName(fxname)
                  lvar.focusedfx = fxname
                  lvar.fxsel_focusedfx = fxname
                  lvar.fxsel_focusedfx_module = fx
                  lvar.fxsel_focusedfx_guid = fxguid
                  lvar.fxsel_focusedfx_fxnum = fxnum
  
                  FFX = {trn = trn,
                         trguid = reaper.GetTrackGUID(track),
                         trname = reaper.GetTrackState(track),
                         itemnum = itmnum,
                         itemguid = reaper.BR_GetMediaItemGUID(item),
                         take = take,
                         fxnum = fxnum,
                         fxname = fxname,
                         fxplug = fxnm,
                         fxguid = fxguid,
                         fxtype = fxtype}
                  SetCCSend(trn)
                else
                  --[[local trchunk = GetTrackChunk(track)
                  
                  local ffn=paths.resource_path..'chunkerror.txt'
                  
                  file=io.open(ffn,"w")
                  file:write('fxnum: '..fxnum+1 ..'\n')
                  file:write(trchunk)
                  file:close()
                  DBG('Chunk error file created at: '..ffn)
                  ]]
                end
              else
                
              end
            end
          end      
        end
        lvar.lastfocusedret = ret
        
      end
    else
      if recmode == 0 then
        lvar.lastfocusedret = nil
        --Track CC mode
        local track = reaper.GetSelectedTrack2(0,0,true)
        --local track = reaper.GetSelectedTrack(0,0)
        if track then
          
          trn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
          if trn and (not found[trn] or trn == -1) and recmode == 0 then
            --if trn == -1 then trn = 0 end
            local trguid = reaper.GetTrackGUID(track)
            local _, trname = reaper.GetTrackName(track)
            if trguid ~= otrguid or trname ~= otrname or trn == -1 then
            --DBG(trname..'  '..tostring(otrname))
              otrguid = trguid
              otrname = trname
              FFX = {trn = trn,
                     trguid = trguid,
                     trname = trname, --reaper.GetTrackState(track),
                     fxnum = -1,
                     fxname = '',
                     fxplug = '',
                     fxguid = '',
                     fxtype = ''}
              SetCCSend(trn)
              if lvar.trackoffsetfollowsselected then
                lvar.track_ofs = math.max(trn,0)
                if lvar.trackoffset_visibleonly > 0 then
                  lvar.tracks_vis = Internal_VisibleTracks()
                end
              end
              --reaper.SetMixerScroll(track)
              
            end
            ret = 1
          else
            ret = 0
            FFX = nil
            otrguid = nil
            otrname = nil
            ofxguid = nil
            template = {dirty = {},
                        pos = {},
                        sft = {},
                        eft = {}}
          end
        else
          ret = 0
          FFX = nil
          otrguid = nil
          otrname = nil
          ofxguid = nil
          template = {dirty = {},
                      pos = {},
                      sft = {},
                      eft = {}}
        
        end
        
      end
      
    end
    return FFX, ret
    
  end

  function FFXMenu()

    if lvar.mode ~= 3 then
      mstr = 'FX exclusion list: Add'
      local bcnt = 0
      local sorted = {}
      for a,b in pairs(lvar.pluginblacklist) do
        bcnt = bcnt + 1
        sorted[bcnt] = a
      end
      
      if bcnt > 0 then
        mstr = mstr .. '||>FX exclusion list: Remove'
        for i = 1, bcnt do
          mstr = mstr .. '|'
          if i == bcnt then
            mstr = mstr .. '<'
          end
          mstr = mstr .. sorted[i]
        end
      end
      gfx.x = mouse.mx
      gfx.y = mouse.my
      local res = gfx.showmenu(mstr)
      if res > 0 then
        if res == 1 then
          
          Blacklist_Add()
          
        elseif res <= bcnt + 1 then
        
          local idx = res-1
          local plugidx = sorted[idx]
          if plugidx then
            lvar.pluginblacklist[plugidx] = nil
          end
        end
      end
    end
  end
  
  function Blacklist_Add()
    if FFX and FFX.trn and FFX.fxnum then
      local track = GetTrack(FFX.trn)
      local ret, fxname = reaper.TrackFX_GetFXName(track, FFX.fxnum, '')
      local ret, fx = reaper.BR_TrackFX_GetFXModuleName(track, FFX.fxnum, '', 128)
      lvar.pluginblacklist[(fxname or '-')] = true
      lvar.pluginblacklist[(fx or '-')] = true
      
      Blacklist_Save()
    end
  end

  function Blacklist_Save()
    local ffn = paths.resource_path..LBX_FXEL
    file=io.open(ffn,"w")
    for a, b in pairs(lvar.pluginblacklist) do
      file:write('['..a..']\n')
    end
    file:close()
  end

  function Blacklist_Load()
    local ffn = paths.resource_path..LBX_FXEL
    if reaper.file_exists(ffn) then
    
      data = {}
      for line in io.lines(ffn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          val = string.gsub(val, '[\r]', '') --Remove \r for Mac use
          data[idx] = true
        end
      end

      for a, b in pairs(data) do
        lvar.pluginblacklist[a] = b
      end
    
    end
  end
  
  function GetSendIdxTable(trn)
    
    local track = GetTrack(trn)
    if track then
      if not tab_SendIdx then
        tab_SendIdx = {}
      end
      local guid = reaper.GetTrackGUID(track)
      tab_SendIdx[guid] = {}
      local nidx = 0

      local hicnt = reaper.GetTrackNumSends(track,1)
      tab_SendIdx[guid].hwcount = hicnt or 0
      for idx = 0, hicnt-1 do
        local ret, nm = reaper.GetTrackSendName(track,idx,'')
        if ret then
          --if not string.match(nm,'^__') then
            nm = string.gsub(nm, '(Track)', 'Tr')
            tab_SendIdx[guid][nidx] = {idx = idx, name = string.sub(nm,0,7), hw = true}
            
            nidx = nidx + 1
          --end
        end
      end
      
      local icnt = reaper.GetTrackNumSends(track,0)
      tab_SendIdx[guid].count = hicnt + icnt
      
      for idx = 0, icnt-1 do
        local ret, nm = reaper.GetTrackSendName(track,hicnt + idx,'')
        if ret then
          if not string.match(nm,'^__') then
            nm = string.gsub(nm, '(Track)', 'Tr')
            tab_SendIdx[guid][nidx] = {idx = hicnt + idx, name = string.sub(nm,0,7)}
            
            nidx = nidx + 1
          end
        end
      end
    end
    
  end

  function GetPlugNameFromChunk(fxchunk)
  
    local fxn, fxt
    local s,e = string.find(fxchunk,'.-(\n)')
    local fxc = string.sub(fxchunk,1,e)
    if string.sub(fxc,1,3) == 'VST' then
      if string.match(fxc, '.-(VST3).-\n') then
        fxt = 'VST3'
      else
        fxt = 'VST'
      end
      fxn = string.match(fxc, '.-: (.-) %(')
      if fxn == nil then
        fxn = string.match(fxc, '.-: (.-)%"')      
      end
    elseif string.sub(fxc,1,2) == 'JS' then
      fxt = 'JS'
      fxn = string.match(fxc, 'JS.*%/+(.-) \"')
      if fxn == nil then
        fxn = string.match(fxc, 'JS%s(.-)%s')  -- gets full path of effect
        fxn = string.match(fxn, '([^/]+)$') -- gets filename  
      end
      --remove final " if exists
      if string.sub(fxn,string.len(fxn)) == '"' then
        fxn = string.sub(fxn,1,string.len(fxn)-1)
      end
      
      --[[if fxn == nil then
        --JS \"AB Level Matching JSFX [2.5]/AB_LMLT_cntrl\" \"MSTR /B\"\
        fxn = string.match(fxchunk, 'JS.*%/(.-)%"%\"')
        fxn = string.sub(fxn,1,string.len(fxn)-2)
      end]]
    end
  
    return fxn, fxt
    
  end
  
  --returns success, fxchunk, start loc, end loc
  function GetFXChunkFromTrackChunk(track, fxn, trchunk)

    --local ret, trchunk = reaper.GetTrackStateChunk(track,'')
    if not trchunk then
      trchunk = GetTrackChunk(track)
    end
    if trchunk then
      local s,e, fnd = 0,0,nil
      for i = 1,fxn do
        s, e = string.find(trchunk,'(BYPASS.-WAK %d)',s)
        if s and e then
          fxchunk = string.sub(trchunk,s,e)
    
          if i == fxn then fnd = true break end
          s=e+1
        else
          fxchunk = nil
          fnd = nil
          break
        end
      end
      return fnd, fxchunk, s, e  
    end
      
  end
    
  function GetParams()

  end

  function SetParam()

  end
  
  function SetTemplateParam(temppos, paramnum, paramname) 
  
    if template.pos[temppos] then
      template.pos[temppos] = {ptype = ptype.host,
                               pnum = paramnum,
                               pname = paramname,
                               val = nil,
                               ccchan = template.pos[temppos].ccchan,
                               ccnum = template.pos[temppos].ccnum,
                               buttype = 4,
                               butstates = 2}
    else
      template.pos[temppos] = {ptype = ptype.host,
                               pnum = paramnum,
                               pname = paramname,
                               val = nil,
                               ccchan = 0,
                               ccnum = 0,
                               buttype = 4,
                               butstates = 2}    
    end  
  end
  
  function GAMenu(v)
  
    local ret
    local v1, v2 = '', ''
    if v == 1 then
      v1 = '!' 
    elseif v == 2 then
      v2 = '!'     
    end
    local mstr = v1..'Enable Global Map When Selected|'..v2..'Disable Global Map When Selected'
    gfx.x, gfx.y = mouse.mx, mouse.my
    local res = gfx.showmenu(mstr)
    return res
  
  end

  function GAMenu2(v)
  
    local ret
    local v1, v2 = '', ''
    if v == 1 then
      v1 = '!' 
    elseif v == 2 then
      v2 = '!'     
    end
    local s1, s2 = '', ''
    if lvar.fxsel_mode == 0 then
      s1 = '!'
    else
      s2 = '!'
    end
    local s3 = ''
    if lvar.fxsel_plugtype == 1 then
      s3 = '!'
    end
    local mstr = v1..'Enable Global Map When Selected|'..v2..'Disable Global Map When Selected'
                 ..'||'..s1..'Select By Focused Plugin|'..s2..'Select By Track FX Slot||'..s3..'Retain Plugin Type Selection When Changing Tracks'
    gfx.x, gfx.y = mouse.mx, mouse.my
    local res = gfx.showmenu(mstr)
    return res
  
  end
  
  function TOMenuRB()
  
    if lvar.takeover.active > -1 then
      mstr = '>Device'
      for d = 1, 4 do
        mstr = mstr .. '|'
        if d == 4 then
          mstr = mstr .. '<'
        end
        if lvar.takeover.bus == d-1 then
          mstr = mstr .. '!'
        end
        mstr = mstr .. (lvar.midimap[d] or '#No device')
      end
      mstr = mstr .. '|>Device Channel'
      for c = 1, 8 do
        mstr = mstr .. '|'
        if c == 8 then
          mstr = mstr .. '<'
        end
        if lvar.takeover.channel == c then
          mstr = mstr .. '!'
        end
        mstr = mstr .. 'Channel ' .. string.format('%i',c)      
      end
      local numtypes = #lvar.takeover_types
      mstr = mstr .. '||>Fader Assignment'
      for i = 1, numtypes do
        mstr = mstr .. '|'
        if i == 3 then
          mstr = mstr .. '|'
        end
        if i == numtypes then
          mstr = mstr .. '<'
        end
        if lvar.takeover.fader_to[lvar.takeover.active] == i then
          mstr = mstr .. '!'
        end
        mstr = mstr .. lvar.takeover_types[i].menutxt
      end
      mstr = mstr .. '|>Encoder Assignment'
      for i = 1, numtypes do
        mstr = mstr .. '|'
        if i == 3 then
          mstr = mstr .. '|'
        end
        if i == numtypes then
          mstr = mstr .. '<'
        end
        if lvar.takeover.encoder_to[lvar.takeover.active] == i then
          mstr = mstr .. '!'
        end
        mstr = mstr .. lvar.takeover_types[i].menutxt
      end
      
      
      gfx.x = mouse.mx
      gfx.y = mouse.my
      local res = gfx.showmenu(mstr)
      if res > 0 then
      
        if res <= 4 then
          local v = res
          lvar.takeover.bus = v-1
          
        elseif res <= 12 then
          local v = res-4
          lvar.takeover.channel = v
        
        elseif res <= 12+numtypes then
          local v = res-12
          local idx = lvar.takeover.active
          lvar.takeover.fader_to[idx] = v
    
        else
          local v = res-12-numtypes
          local idx = lvar.takeover.active
          lvar.takeover.encoder_to[idx] = v
    
        end
        InsertTakeoverAssignments()
        TemplateChanged() 
        lupd.update_gfx = true
      
      end
  
    end
  end
  
  function FBMenu()
    
    local fvtk = ''
    if lvar.fadervaluefb then
      fvtk = '!'
    end
    
    local sktk = ''
    if settings.liveccfb ~= true then    
      sktk = '#!'
      lvar.fbcconseek = true
    else
      if lvar.fbcconseek then
        sktk = '!'
      end
    end
    local actk = ''
    if lvar.autochase then
      actk = '!'
    end
    local tnss = ''
    if settings.includetracknameinss then
      tnss = '!'
    end
    local dotk = ''
    if lvar.display_overlay_active then
      dotk = '!'
    end
    local fitk = ''
    if lvar.display_overlay_inputonly then
      fitk = '!'
    end
    local lcc = ''
    if settings.liveccfb then
      lcc = '!'
    end
    local tcm = ''
    if not lvar.tcactive then
      tcm = '!'
    end
    local dss = ''
    if lvar.disableSSplayback then
      dss = '!'
    end
    local akm = ''
    if lvar.assignmentdisplay_active == true then
      akm = '!'
    end
    local dvf = ''
    if lvar.dv_filter_enabled then
      dvf = '!'
    end
    
    local mstr = sktk.."Feedback to faders only when transport stopped|"..fvtk.."Feedback values to scribble strip|"..dss..'Disable scribble strips on playback|'..tnss.."Include track name in scribble strip||"
                 ..dotk.."Show scribble strips in GUI|"..fitk.."Show only on controller input||"..actk.."Auto-chase events|Change max chase time  ("..lvar.maxchasetime.."ms)||"
                 ..lcc..'Live CC Feedback (recreates setup)||'..tcm..'Disable timecode messages||'..akm..'Assignments Display (XTouch)||'..dvf..'Filter Scribble Strip Values'
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then
        lvar.fbcconseek = not lvar.fbcconseek
        local v = 0
        if lvar.fbcconseek == true then
          v = 1
        end
        if LBX_CTL_TRACK then
          local tr = GetTrack(LBX_CTL_TRACK)
          if tr then
            --for i = 0, reaper.TrackFX_GetCount(tr)-2 do
              --reaper.TrackFX_SetParam(tr, i, 49, v)
              reaper.gmem_write(lvar.gm_fb.gswitch50,v)
              
            --end
          end
        end
        lupd.update_gfx = true
      elseif res == 2 then
        lvar.fadervaluefb = not lvar.fadervaluefb      
      elseif res == 3 then
        lvar.disableSSplayback = not lvar.disableSSplayback
      elseif res == 4 then
        settings.includetracknameinss = not settings.includetracknameinss
        updatetravellingtracknames(true)
      elseif res == 5 then
        lvar.display_overlay_active = not lvar.display_overlay_active
        lvar.display_overlay = {}
        lvar.display_overlay_idx = {}
      elseif res == 6 then
        lvar.display_overlay_inputonly = not lvar.display_overlay_inputonly
      elseif res == 7 then
        lvar.autochase = not lvar.autochase
      elseif res == 8 then
        local ret, v = reaper.GetUserInputs('Set max chase time',1,'Time (ms):',lvar.maxchasetime)
        if ret then
          if tonumber(v) then
            lvar.maxchasetime = tonumber(v)
          end
        end
      elseif res == 9 then --live CC FB
        settings.liveccfb = not settings.liveccfb
        if not mididevices then
          mididevices = GetMIDIDevices()
        end
        CreateSetUp()
        lvar.initstage = 1
        lupd.update_gfx = true
      elseif res == 10 then --Prev Dup CC
        lvar.tcactive = not lvar.tcactive
      
      elseif res == 11 then --Ass Display Mode
        lvar.assignmentdisplay_active = not lvar.assignmentdisplay_active
        --lvar.AKLayerMode = 1 - lvar.AKLayerMode
        
      elseif res == 12 then --Display Value Filter
        lvar.dv_filter_enabled = not lvar.dv_filter_enabled
      end
    end
  end
  
  function CCMenu(posi)
    if FFX then
      
      local tmp
      tmp = GetTemplate(posi, nil, true)
      --[[if permatemplate.pos[posi] then
        tmp = permatemplate        
      elseif globtemplate.pos[posi] and lvar.showglobalmap then
        tmp = globtemplate
      else
        tmp = template
      end]]
      local devctl = '#<unassigned>'
      if ctl_template.fader[posi] and ctl_template.fader[posi].devctl then
        devctl = '#[Device '..string.format('%i',ctl_template.fader[posi].devbus+1)..'] - '..ctl_template.fader[posi].devctl
      end
      local menustr = devctl..'||Clear|Clear All||Rename'

      gfx.x, gfx.y = mouse.mx, mouse.my
      local res = gfx.showmenu(menustr)
      if res > 0 then
        return res
      end
    end
    
  end

  function GetBtnType(v)
    for i = 1, #tab_btntype do
      if tab_btntype[i].v == v then
        return tab_btntype[i].t
      end
    end
  end
  
  function ActionMenu(posi)
    if FFX then
      local tmp
      tmp = GetTemplate(posi, nil, true)
      --[[if permatemplate.pos[posi] then
        tmp = permatemplate        
      elseif globtemplate.pos[posi] and lvar.showglobalmap then
        tmp = globtemplate
      else
        tmp = template
      end]]

      local devctl = '#<unassigned>'
      if ctl_template.fader[posi] and ctl_template.fader[posi].devctl then
        devctl = '#[Device '..string.format('%i',ctl_template.fader[posi].devbus+1)..'] - '..ctl_template.fader[posi].devctl
      end

      local menustr = devctl..'||Clear|Clear All||Rename'
      
      --local menustr = devctl..'||Clear|Clear All||Rename||Action ID|'..btntype
      gfx.x, gfx.y = mouse.mx, mouse.my
      local res = gfx.showmenu(menustr)
      if res > 0 then
        return res
      end
    end
  end
    
  function TrackMenu(posi)
    if FFX then
      local tmp
      tmp = GetTemplate(posi)
      --[[if permatemplate.pos[posi] then
        tmp = permatemplate        
      elseif globtemplate.pos[posi] and lvar.showglobalmap then
        tmp = globtemplate
      else
        tmp = template
      end]]

      local devctl = '#<unassigned>'
      if ctl_template.fader[posi] and ctl_template.fader[posi].devctl then
        devctl = '#[Device '..string.format('%i',ctl_template.fader[posi].devbus+1)..'] - '..ctl_template.fader[posi].devctl
      end
      local encres = ''
      local encres_c = 0
      if ctl_template.fader[posi] and (ctl_template.fader[posi].lmode == 3 or ctl_template.fader[posi].lmode == 2 or ctl_template.fader[posi].lmode == 6 or ctl_template.fader[posi].lmode == 7) and tmp.pos[posi] then
        encres, encres_c = encres_list(tmp.pos[posi].enc_res)
      end
      local menustr = devctl..encres..'||Clear|Clear All||Rename|'
      
      gfx.x, gfx.y = mouse.mx, mouse.my
      local res = gfx.showmenu(menustr)
      if res > 0 then
        local ret
        if res-1 <= encres_c then
          return -4, tonumber(tab_encres[res-1])-1
        else
          res = res - encres_c
          if res < 5 then
            ret = 0
          end
          return ret, res
        end
      end
    end
  end
  
  function InternalMenu(posi)

    if FFX then
      
      local tmp
      tmp = GetTemplate(posi)
      --[[if permatemplate.pos[posi] then
        tmp = permatemplate        
      elseif globtemplate.pos[posi] and lvar.showglobalmap then
        tmp = globtemplate
      else
        tmp = template
      end]]
      local devctl = '#<unassigned>'
      if ctl_template.fader[posi] and ctl_template.fader[posi].devctl then
        devctl = '#[Device '..string.format('%i',ctl_template.fader[posi].devbus+1)..'] - '..ctl_template.fader[posi].devctl
      end
        
      local menustr = devctl..'||Clear|Clear All||Rename'
      
      gfx.x, gfx.y = mouse.mx, mouse.my
      local res = gfx.showmenu(menustr)
      if res > 0 then
        return res
      end
    end  
  end
  
  function FiltMenu(shift)

    local tk = ''
    if lvar.restorelastfilter then
      tk = '!'
    end    
    
    local menustr = tk..'Restore last active filter on load|'
    for i = 1, #tab_filters do
      if menustr ~= '' then
        menustr = menustr .. '|'
      end
      --DBG(tab_filters[i])
      if tab_filters[i] then
        local tk = ''
        if i > 1 and lvar.lstfiltsel[i] == true then
          tk = '!'
        end
        menustr = menustr ..tk.. tab_filters[i]
      else
        menustr = menustr ..'#unused'
      end
    end
    gfx.x, gfx.y = mouse.mx, mouse.my
    local res = gfx.showmenu(menustr)
    if res > 0 then
      
      local skipupdate
      if res == 1 then
        lvar.restorelastfilter = not lvar.restorelastfilter
        skipupdate = true
        
      elseif res == 2 then
        if res == 2 then
          lvar.lstfiltsel = {}
          lvar.lstfilt = {}
          lvar.userfilter.select = nil
        --else
        --  lvar.lstfilt[1] = res
        --  lvar.lstfiltsel[res] = true      
        end      
      else
        res = res - 1
        lvar.userfilter.select = nil
        lvar.lstfiltsel[1] = false        
        --lvar.lstfiltsel[2] = false
        --lvar.lstfiltsel[3] = false
        lvar.lstfiltsel[res] = not (lvar.lstfiltsel[res] or false)
        if lvar.lstfiltsel[res] == true then
          lvar.lstfilt[#lvar.lstfilt+1] = res
        else
          local tmp = {}
          local cnt = 1
          for i = 1, #lvar.lstfilt do
            if lvar.lstfilt[i] ~= res then
              tmp[cnt] = lvar.lstfilt[i]
              cnt = cnt + 1
            end
          end
          lvar.lstfilt = tmp
        end
        
        --[[lvar.lstfilt = {}
        
        local cnt = 1
        for i = 2, #tab_filters do
          if lvar.lstfiltsel[i] == true then
            lvar.lstfilt[cnt] = i
            cnt = cnt + 1
          end
        end]]
      end
      if not skipupdate then
        UpdateFilter()
        control_offs = 0
        lupd.update_gfx = true
        if shift then
          FiltMenu(shift)  
        end
      end
    end
  end
  
  function UpdateFilter()

    control_offs = 0
    if not lvar.lstfilt or #lvar.lstfilt == 0 then

      lvar.filtidx = nil
      lvar.filtidx2 = nil
      lvar.fcountfilt = nil
      
      if lvar.mirrordevices then
        lvar.filtidx = {}
        lvar.filtidx2 = {}
        
        local ignorebus = {}
        if lvar.mirrordev_1to2 then
          ignorebus[1] = true
        end
        if lvar.mirrordev_3to4 then
          ignorebus[3] = true
        end
        local cnt = #lvar.filtidx+1
        for posi = 1, lvar.fcount do
          if not ignorebus[ctl_template.fader[posi].devbus] then
            lvar.filtidx[cnt] = posi
            lvar.filtidx2[posi] = cnt
            cnt = cnt + 1          
          end
        end
        
      end
    
    else
      lvar.filtidx = {}
      lvar.filtidx2 = {}

      local ignorebus = {}

      if lvar.mirrordevices then
        if lvar.mirrordev_1to2 then
          ignorebus[1] = true
        end
        if lvar.mirrordev_3to4 then
          ignorebus[3] = true
        end
      end
      
      for f = 1, #lvar.lstfilt do

        if lvar.lstfilt[f] == 2 then
          local cnt = #lvar.filtidx+1
          for posi = 1, lvar.fcount do
            local tmp
            tmp = GetTemplate(posi)
            
            if tmp and tmp.pos[posi] and not ignorebus[ctl_template.fader[posi].devbus] then
              lvar.filtidx[cnt] = posi
              lvar.filtidx2[posi] = cnt
              cnt = cnt + 1          
            end
          end
          lvar.fcountfilt = #lvar.filtidx
          
        elseif lvar.lstfilt[f] == 3 then
          local cnt = #lvar.filtidx+1
          for posi = 1, lvar.fcount do
            local tmp
            tmp = GetTemplate(posi)
            if tmp and not tmp.pos[posi] and not ignorebus[ctl_template.fader[posi].devbus] then
              lvar.filtidx[cnt] = posi
              lvar.filtidx2[posi] = cnt
              cnt = cnt + 1          
            end
          end
          lvar.fcountfilt = #lvar.filtidx
    
        elseif lvar.lstfilt[f] >= 4 and lvar.lstfilt[f] <= 8 then
          local ptype = lvar.lstfilt[f] - 3
          local cnt = #lvar.filtidx+1
          for posi = 1, lvar.fcount do
            local tmp
            tmp = GetTemplate(posi)
            if tmp and tmp.pos[posi] and tmp.pos[posi].ptype == ptype and not ignorebus[ctl_template.fader[posi].devbus] then
              lvar.filtidx[cnt] = posi
              lvar.filtidx2[posi] = cnt
              cnt = cnt + 1          
            end
          end
          lvar.fcountfilt = #lvar.filtidx

        elseif lvar.lstfilt[f] == 9 then
          local cnt = #lvar.filtidx+1
          for posi = 1, lvar.fcount do
            local tmp
            if permatemplate.pos[posi] then
              tmp = permatemplate        
            end
            if tmp and tmp.pos[posi] and not ignorebus[ctl_template.fader[posi].devbus] then
              lvar.filtidx[cnt] = posi
              lvar.filtidx2[posi] = cnt
              cnt = cnt + 1          
            end
          end
              
        elseif lvar.lstfilt[f] >= 10 and lvar.lstfilt[f] <= 13 then
          local dev = lvar.lstfilt[f] - 10
          local cnt = #lvar.filtidx+1
          for posi = 1, lvar.fcount do
            if ctl_template.fader[posi] and ctl_template.fader[posi].devbus == dev and not ignorebus[ctl_template.fader[posi].devbus] then
              lvar.filtidx[cnt] = posi
              lvar.filtidx2[posi] = cnt
              cnt = cnt + 1                  
            end
          end      
    
          lvar.fcountfilt = #lvar.filtidx   
        
        elseif lvar.lstfilt[f] > 13 then
          local sg = lvar.lstfilt[f] - 14
          local cnt = #lvar.filtidx+1
          for posi = 1, lvar.fcount do
            if ctl_template.fader[posi] and ctl_template.fader[posi].sort == sg and not ignorebus[ctl_template.fader[posi].devbus] then
              lvar.filtidx[cnt] = posi
              lvar.filtidx2[posi] = cnt
              cnt = cnt + 1                  
            end
          end      
    
          lvar.fcountfilt = #lvar.filtidx
        end
      
      
      end
    end
  end
  
  function encres_list(v)
    local str = '||>Encoder Resolution ('..string.format('%i',(v or 128))..')'
    for i = 1, #tab_encres do
      local up = ''
      if i == #tab_encres then
        up = '<'
      end
      local tk = ''
      if tab_encres[i] == v then
        tk = '!'
      end
      str = str .. '|'..up..tk..tab_encres[i]
    end
    return str, #tab_encres
  end
  
  function ParamMenu(posi)
  
    if FFX then
      local tmp
      tmp = GetTemplate(posi)
      --[[if permatemplate.pos[posi] then
        tmp = permatemplate        
      elseif globtemplate.pos[posi] and lvar.showglobalmap then
        tmp = globtemplate
      else
        tmp = template
      end]]
      
      local devctl = '#<unassigned>'
      if ctl_template.fader[posi] and ctl_template.fader[posi].devctl then
        devctl = '#[Device '..string.format('%i',ctl_template.fader[posi].devbus+1)..'] - '..ctl_template.fader[posi].devctl
      end
      local encres = ''
      local encres_c = 0
      if ctl_template.fader[posi] and (ctl_template.fader[posi].lmode == 2 or ctl_template.fader[posi].lmode == 3 or ctl_template.fader[posi].lmode == 6 or ctl_template.fader[posi].lmode == 7) and tmp.pos[posi] then
        encres, encres_c = encres_list(tmp.pos[posi].enc_res or 128)
      end
      
      --[[local btn = ''
      if ctl_template.fader[posi].lmode ~= 4 then
        btn = '#'
      end
      
      local btntype = '>'..'Button Type: '
      if tmp.pos[posi].buttype and btn == '' then
        btntype = btntype .. (GetBtnType(tmp.pos[posi].buttype) or '')
      end
      local i = 0
      for i = 1, #tab_btntype do
        btntype = btntype .. '|'
        if i == #tab_btntype then
          btntype = btntype .. '<'
        end
        if tmp.pos[posi].buttype == tab_btntype[i].v then
          btntype = btntype .. '!'
        end
        btntype = btntype .. tab_btntype[i].t
      end
      btntype = btntype .. '|Button States: '..string.format('%i',tmp.pos[posi].butstates or 2)]]
      
      local menustr = devctl..encres..'||#Clear|Clear All||Rename'
      --[[local menustr = devctl..encres..'||Clear|Clear All||Rename||'..btntype..'|'
      local pnames = {}
      local track = GetTrack(FFX.trn)
      local numparams = reaper.TrackFX_GetNumParams(track, FFX.fxnum)
      for p = 0, numparams do
        local ret, pname = reaper.TrackFX_GetParamName(track, FFX.fxnum, p, '')
        pnames[p] = pname
        menustr = menustr..'|'..pname
      end]]
      
      gfx.x, gfx.y = mouse.mx, mouse.my
      local res = gfx.showmenu(menustr)
      if res > 0 then
        if res-1 <= encres_c then
          return -4, tonumber(tab_encres[res-1])-1
        else
          res = res - encres_c
          if res-encres_c == 2 then
            return -1
          elseif res == 3 then
            return -2
          elseif res == 4 then
            return -3
          --[[elseif res < 5 + #tab_btntype then
            --but type
            return -5, res-4
          elseif res == 5 + #tab_btntype then
            return -6
          else
            local p = res -6-#tab_btntype
            return p, pnames[p]]
          end
        end
      end
    end
      
  end

  function FaderColor_Menu2(x,y,v,ext)

    local mstr = ''
    for n = 1, #tab_xtouch_color_menu do
      local tk = ''
      if n <= 8 then
        if (v or 7) == n-1 then
          tk = '!'
        end
      elseif n == 9 then
        tk = '|'
        if ext then
          tk = tk..'#'
        end
        if (v or 7)&16 == 16 then
          tk = tk..'!'
        end
      elseif n == 10 then
        if ext then
          tk = tk..'#'
        end
        if (v or 7)&32 == 32 then
          tk = '!'
        end
      end
      mstr = mstr ..'|'..tk.. tab_xtouch_color_menu[n]
    end
  
    gfx.x, gfx.y = x,y
    local res = gfx.showmenu(mstr)
    if res > 0 then
    
      return res

    end
  end
  
  function FaderColor_Menu(x,y,i)
  
    local tmp, gflag
    tmp, gflag = GetTemplate(posi)
    
    if tmp.pos[i] and ctl_template.fader[i].sscolor then
    
      local mstr = ''
      for n = 1, #tab_xtouch_color_menu do
        local tk = ''
        if n <= 8 then
          if (tmp.pos[i].sscolor or 7) == n-1 then
            tk = '!'
          end
        elseif n == 9 then
          tk = '|'
          if (tmp.pos[i].sscolor or 7)&16 == 16 then
            tk = tk..'!'
          end
        elseif n == 10 then
          if (tmp.pos[i].sscolor or 7)&32 == 32 then
            tk = '!'
          end
        end
        mstr = mstr ..'|'..tk.. tab_xtouch_color_menu[n]
      end
    
      gfx.x, gfx.y = x,y
      local res = gfx.showmenu(mstr)
      if res > 0 then
        if res <= 8 then
          local ss = tmp.pos[i].sscolor or 7
          tmp.pos[i].sscolor = (res-1) | (ss&48)
        elseif res == 9 then
          local ss = tmp.pos[i].sscolor or 7
          if ss&16 == 16 then
            tmp.pos[i].sscolor = (ss&7) + (ss&32)
          else
            tmp.pos[i].sscolor = (ss&7) + 16 + (ss&32)
          end
        elseif res == 10 then
          local ss = tmp.pos[i].sscolor or 7
          if ss&32 == 32 then
            tmp.pos[i].sscolor = (ss&31)
          else
            tmp.pos[i].sscolor = (ss&31) + 32
          end
        end
        --if gflag ~= 3 then
          if gflag == 3 then
            lvar.saveperm_highlight = true
          elseif gflag == 2 then
            lvar.saveglob_highlight = true
          else
            lvar.save_highlight = true
          end
          lupd.update_header = true
        --end
        tmp.dirty[i] = true
        lupd.update_fader = true
      end
    end
  
  end

  function GenTrackSName(i, trn, track, txt)

    local trstr      
    local tmp
    tmp = GetTemplate(i)
    --[[if permatemplate.pos[i] then
      tmp = permatemplate        
    elseif globtemplate.pos[i] and lvar.showglobalmap then
      tmp = globtemplate
    else
      tmp = template
    end]]

    if tmp and tmp.pos[i] then
      local tmppos = tmp.pos[i]
      
      local snd_type = ((tmppos.trsend-1) % 3) + 1
      local si = math.floor((tmppos.trsend-1) / 3)
      local scnt = reaper.GetTrackNumSends(track,0)
      
      local guid = reaper.GetTrackGUID(track)
      if not tab_SendIdx or not tab_SendIdx[guid] or tab_SendIdx[guid].count ~= scnt then
        GetSendIdxTable(trn)
      end
      local sndnm = ''

      if tab_SendIdx and tab_SendIdx[guid] and tab_SendIdx[guid][si] then
        sndnm = tab_SendIdx[guid][si].name
      end
      
      if snd_type == 1 then
        trstr = ' Snd Vol'
      elseif snd_type == 2 then
        trstr = ' Snd Pan'      
      elseif snd_type == 3 then
        trstr = ' Snd Mte'      
      end
      
      trstr = sndnm .. trstr
      
    end
    return trstr    
  end
    
  function GenTrackPName(i, txt)
    local tmp
    tmp = GetTemplate(i)
   
    local trstr = ' <Please select>'

    if tmp and tmp.pos[i] then
      trstr = ''
      --DBG('p'..i..tmp.pos[i].trparam)
      if tmp.pos[i].trparam == -1 then
        --DBG('s'..i..tmp.pos[i].trsend)
        if tmp.pos[i].trsend == -1 then        
        else
          if tmp.pos[i].track == -1 then
            trstr = ' SEL'
          elseif tmp.pos[i].track == -2 then
            if txt then
              trstr = ' '..txt        
            else
              trstr = ''
              --trstr = 'OFFS '..string.format('%i',tmp.pos[i].troff)..': '        
            end
          elseif tmp.pos[i].track == 0 then
            trstr = ' MASTER'
          else
            trstr = ' '..string.format('%i',tmp.pos[i].track or -1)
          end
          trstr = (tab_trparams[tmp.pos[i].trparam] or '<not set>')..trstr..' '..(tab_trsnds[tmp.pos[i].trsend] or '<not set>')
        end
      else
        if tmp.pos[i].track == -1 then
          trstr = ' SEL'
        elseif tmp.pos[i].track == -2 then
          if txt then
            trstr = ' '..txt        
          else
            trstr = ''
            --trstr = 'OFFS '..string.format('%i',tmp.pos[i].troff)..': '        
          end
        elseif tmp.pos[i].track == 0 then
          trstr = ' MASTER'
        else
          trstr = ' '..string.format('%i',tmp.pos[i].track or -1)
        end
        trstr = (tab_trparams[tmp.pos[i].trparam] or '<not set>')..trstr
      end
    end
    return trstr
  end
  
  function TrimFXName(fxname)
  
    fxname = fxname or 'unknown plugin'
    local fxn = string.match(fxname, '.-: (.+) %(')
    if fxn == nil then
      fxn = string.match(fxname, '.-: (.*)')
      if fxn == nil then
        fxn = fxname
      end
    end
    fxn = string.gsub(fxn,'/','')
    return fxn
  
  end
  
  --- Pads str to length len with char from left
  string.rpad = function(str, len, char)
      if char == nil then char = ' ' end
      str = trim2(str)
      local rp = math.floor((len - string.len(str))/2)
      --DBG(str..'  '..string.len(str)..'  '..rp)
      return string.rep(char, rp) .. str
  end
  
  function trim2(s)
     return s:match "^%s*(.-)%s*$"
  end

  function scribbleformat_singleline(str, scriblen)
    if not str then return end
    
    local tab = mysplit(str,'%s%_%,')
    local ln = 1
    local out = {}
    out[1] = ''
    for i = 1, #tab do
      out[ln] = out[ln] .. tab[i]
    end
    
    --Padding for centering
    if string.len(out[1]) < scriblen-1 then
      out[1] = string.rpad(out[1],scriblen,' ')
    end
    return out[1]
  end
  
  function scribbleformat(str, scriblen)
    local tab = mysplit(str,'%s%-%_%,')
    local ln = 1
    local out = {}
    out[1] = ''
    out[2] = ''
    for i = 1, #tab do
      if string.len(out[1]) > 2 and ln == 1 and string.len(out[1]) + string.len(tab[i]) + 1 > scriblen then
        ln = math.min(ln + 1,2)
      end
      
      if out[ln] ~= '' then
        out[ln] = out[ln]..' ' 
      end
      out[ln] = out[ln] .. tab[i]
    end
    
    --Padding for centering
    if string.len(out[1]) < scriblen-1 then
      out[1] = string.rpad(out[1],scriblen,' ')
    end
    if string.len(out[2]) < scriblen-1 then
      out[2] = string.rpad(out[2],scriblen,' ')
    end
    return out[1], out[2]
  end
  
  function mysplit(inputstr, sep)
    if sep == nil then
      sep = "%s"
    end
    local t={} ; i=1
    for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
      t[i] = str
      i = i + 1
    end
    return t
  end

  function mysplit_num(inputstr, sep, offset)
    if sep == nil then
      sep = "%s"
    end
    local t={} ; i=1
    for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
      t[i] = tonumber(str) + (offset or 0)
      i = i + 1
    end
    return t
  end
  
  function SendScribbleData()
  
    local track = GetTrack(LBX_CTL_TRACK)
    if track then
    
      if lvar.ctlgroup_select == 0 then
        for ss = 1, #lvar.ssnumidx do
          local i = lvar.ssnumidx[ss]
          local tmp
          tmp = GetTemplate(i)
          if tmp and ctl_template.fader[i] and i == ctl_template.fader[i].ssnum then
            if not SendScribbleData2(tmp, nil, i) then
              break
            end
          end
        end
      
      else
        local g = lvar.ctlgroup_select
        local gidx = lvar.groupidx[g]
        local sstab = {}
        local devbus
        if lvar.groupctlidx[gidx] then
          for a, b in pairs(lvar.groupctlidx[gidx]) do
            local i = b
            local tmp
            tmp = GetTemplate(i)
            if ctl_template.fader[i] then
              devbus = ctl_template.fader[i].devbus
            end
            if tmp and ctl_template.fader[i] and tmp.pos[i] and ctl_template.fader[i].ssnum then
              sstab[ctl_template.fader[i].ssnum] = 1
              --DBG(ctl_template.fader[i].ssnum)
              if not SendScribbleData2(tmp, nil, i) then
                break
              end
              --DBG(a..'  '..i)
            end
          end
        end
        for ss = 1, #lvar.ssnumidx do
          local i = lvar.ssnumidx[ss]
          if not sstab[i] then
            if lvar.ctlgroup_scribblemode == 0 and ctl_template.fader[i].devbus == devbus then 
              SendScribbleData2({pos={}}, nil, i)
            else
              local tmp
              tmp = GetTemplate(i)
              if tmp and ctl_template.fader[i] and i == ctl_template.fader[i].ssnum then
                if not SendScribbleData2(tmp, nil, i) then
                  break
                end
              end            
            end
          end
        end
      end
    end
  end
  
  function ConvertColorMode(m, c)
  
    if m == 2 then
      local cv = c&7
      local nc = cv
      if c&16 == 16 or c&32 == 32 then
        nc = nc | 64
      end
      --[[if c&32 == 32 then
        nc = nc + 48
      end]]
      return nc
    end
    
  end
  
  function SendScribbleData2(tmp, header, i, dispval)
    if lvar.initstage then return true end

    local dev = ctl_template.fader[i].odevbus or ctl_template.fader[i].devbus
    local scriblen = lvar.scriblen[dev] or 7
    local ssnum = ctl_template.fader[i].ssnum

    local str = ''
    local str2 = ''
    local strOV
    local str2OV
    local ss_color = 7 --default white
    local ss_color2
    local guistr = ''
    local guistrOV
    local guistr2
    local guistrB
    local scribgui
    local oi
    
    local tmppos = tmp.pos[i]
    if not tmppos then
      --force through
      tmppos = {sscolor = 0, name = '', scribov = ''}
      ss_color = 0
    --elseif lvar.remap_active and lvar.remap.ctl[i] then
      --ss_color = 0
    end
    
    if tmppos then
      if lvar.ss_alwaysshowdispval and not dispval and tmppos.dispval then
        dispval = tmppos.dispval
        if string.len(dispval) < scriblen-1 then
          dispval  = string.rpad(dispval,scriblen,' ')
        end
      end
      
      --if linkB then switch to linkA SS
      if tmppos.linkB then
        local idx = lvar.ctlmapidx[tmppos.linkB]
        if idx then
          if tmppos.linkA then
            oi = i
            i = idx
            ssnum = ctl_template.fader[i].ssnum
          end
        end
      end
      local tmppos = tmp.pos[i] or tmppos
      
      if tmppos then
      
        if tmppos.ss_override then
          local ii = lvar.ssnumidx[tmppos.ss_override]
          dev = ctl_template.fader[ii].devbus
          ssnum = ctl_template.fader[ii].ssnum
        end
        
        if lvar.ss_color_override[i] --[[and lvar.autoenv]] then
          ss_color = lvar.ss_color_override[i]
          
        elseif lvar.ss_override_sscolor[ssnum] and #lvar.ss_override_sscolor[ssnum] > 0 then
        --DBG(i..' --  '..#lvar.ss_override_sscolor[ssnum])
          local idx = #lvar.ss_override_sscolor[ssnum]
          ss_color = lvar.ss_override_sscolor[ssnum][idx].col
          local cm = ctl_template.fader[i].sscolor
          if cm and cm ~= 1 then
            ss_color = ConvertColorMode(cm, ss_color)
          end
          
          local ssc
          if ctl_template.fader[i].lmode == 4 then
            ssc = tmppos.butstates_array_sscolor[tmppos.bpos or -1]
            if ssc == -1 then ssc = nil end
          end
          ss_color2 = ssc or tmppos.sscolor or ss_color
          local cm = ctl_template.fader[i].sscolor
          if cm and cm ~= 1 then
            ss_color2 = ConvertColorMode(cm, ss_color2)
          end
          
        else
          local ssc
          if ctl_template.fader[i].lmode == 4 and tmppos.butstates_array_sscolor then
            ssc = tmppos.butstates_array_sscolor[tmppos.bpos or -1]
            if ssc == -1 then ssc = nil end
          end
          ss_color = ssc or tmppos.sscolor or ss_color
          local cm = ctl_template.fader[i].sscolor
          if cm and cm ~= 1 then
            ss_color = ConvertColorMode(cm, ss_color)
          end
        end

        if lvar.ss_override_name[ssnum] and #lvar.ss_override_name[ssnum] > 0 and dispval == nil then
          local idx = #lvar.ss_override_name[ssnum]
          local ssov = lvar.ss_override_name[ssnum][idx]
          
          if tmp.pos[ssov.tmpidx] and tmp.pos[ssov.tmpidx].ptype == ptype.cc and (ssov.col or '') == '' then
            if tmp.pos[ssov.tmpidx].ccnum == -1 then
              guistrOV = tmp.pos[ssov.tmpidx].pname
              --str, str2 = scribbleformat(tmp.pos[ssov.tmpidx].pname)
            else
              str2 = 'Chan '..string.format('%i',tmp.pos[ssov.tmpidx].ccchan+1)
              str = 'CC '..string.format('%i',tmp.pos[ssov.tmpidx].ccnum)
              guistrOV = str..' '..str2
            end
          else
            guistrOV = ssov.col
          end
          
          strOV, str2OV = scribbleformat(guistrOV, scriblen)
          guistr2 = tmppos.name or tmppos.scribov
          
          if tmp.pos[ssov.tmpidx] and tmp.pos[ssov.tmpidx].linkA then
            if tmp.pos[ssov.tmpidx].linkA_mode == 2 then
              strOV = scribbleformat(tmp.pos[ssov.tmpidx].dispval or '', scriblen) -- strB2
            end
            local tmpB = tmp.pos[lvar.ctlmapidx[tmp.pos[ssov.tmpidx].linkA]]
            if tmpB then
              
              if tmpB.ptype == ptype.cc then
                if tmp.pos[ssov.tmpidx].linkB_mode == 1 then
                  if tmpB.ccnum == -1 then
                    guistrB = tmpB.pname
                    strB, strB2 = scribbleformat(tmpB.pname, scriblen)
                  else
                    strB2 = 'Chan '..string.format('%i',tmpB.ccchan+1)
                    strB = 'CC '..string.format('%i',tmpB.ccnum)
                    guistrB = strB..' '..strB2
                  end
                  str2OV = strB
                else
                  str2OV = scribbleformat(tmpB.dispval or '', scriblen) -- strB2
                end                    
              else
                if tmp.pos[ssov.tmpidx].linkB_mode == 1 then
                  guistrB = tmpB.name or tmpB.pname or tmpB.scribov
                  local strB, strB2 = scribbleformat(guistrB, scriblen)
                  str2OV = strB
                else
                  str2OV = scribbleformat(tmpB.dispval or '', scriblen) -- strB2
                end
              end
            end
          end
          
        end
          
        if (tmppos.name or '') ~= '' or tmppos.scribov then
          guistr = tmppos.name or tmppos.scribov
          str, str2 = scribbleformat(guistr, scriblen)
          
          if tmppos.linkA then
            if tmppos.linkA_mode == 2 then
              str = scribbleformat(tmppos.dispval or '', scriblen) -- strB2
            end
            local tmpB = tmp.pos[lvar.ctlmapidx[tmppos.linkA]]
            if tmpB then
              
              if tmpB.ptype == ptype.cc then
                if tmppos.linkB_mode == 1 then
                  if tmpB.ccnum == -1 then
                    guistrB = tmpB.pname
                    strB, strB2 = scribbleformat(tmpB.pname, scriblen)
                  else
                    strB2 = 'Chan '..string.format('%i',tmpB.ccchan+1)
                    strB = 'CC '..string.format('%i',tmpB.ccnum)
                    guistrB = strB..' '..strB2
                  end
                  str2 = strB
                else
                  str2 = scribbleformat(tmpB.dispval or '', scriblen) -- strB2
                end                    
              else
                if tmppos.linkB_mode == 1 then
                  guistrB = tmpB.name or tmpB.pname or tmpB.scribov
                  local strB, strB2 = scribbleformat(guistrB, scriblen)
                  str2 = strB
                else
                  str2 = scribbleformat(tmpB.dispval or '', scriblen) -- strB2
                end
              end
            end
          end

        elseif (tmppos.name or '') == '' then

          if tmppos.ptype == ptype.cc then
            if tmppos.ccnum == -1 then
              guistr = tmppos.pname
              str, str2 = scribbleformat(tmppos.pname, scriblen)
            else
              str2 = 'Chan '..string.format('%i',tmppos.ccchan+1)
              str = 'CC '..string.format('%i',tmppos.ccnum)
              guistr = str..' '..str2
              --Padding for centering
              if string.len(str) < scriblen-1 then
                str = string.rpad(str,scriblen,' ')
              end
              if string.len(str2) < scriblen-1 then
                str2 = string.rpad(str2,scriblen,' ')
              end
            end
          else
            guistr = tmppos.host_pname or tmppos.pname
            str, str2 = scribbleformat(guistr, scriblen)
          end
          
          --DBG('B '..guistr..' '..tostring(guistrOV)..'  '..tostring(strOV))
          
          if tmppos.linkA then
            if tmppos.linkA_mode == 2 then
              str = scribbleformat(tmppos.dispval or '', scriblen) -- strB2
            end
            local tmpB = tmp.pos[lvar.ctlmapidx[tmppos.linkA]]
            if tmpB then
              
              if tmpB.ptype == ptype.cc then
                if tmppos.linkB_mode == 1 then
                  if tmpB.ccnum == -1 then
                    guistrB = tmpB.pname
                    strB, strB2 = scribbleformat(tmpB.pname, scriblen)
                  else
                    strB2 = 'Chan '..string.format('%i',tmpB.ccchan+1)
                    strB = 'CC '..string.format('%i',tmpB.ccnum)
                    guistrB = strB..' '..strB2
                  end
                  str2 = strB
                else
                  str2 = scribbleformat(tmpB.dispval or '', scriblen) -- strB2
                end                    
              else
                if tmppos.linkB_mode == 1 then
                  guistrB = tmpB.name or tmpB.pname or tmpB.scribov
                  local strB, strB2 = scribbleformat(guistrB)
                  str2 = strB
                else
                  str2 = scribbleformat(tmpB.dispval or '', scriblen) -- strB2
                end
              end
            end
          end
        
        else
          guistr = tmppos.name
          str, str2 = scribbleformat(guistr, scriblen)
        end
      end
    else
      ss_color = 0
    end
    
    if dispval == nil or not lvar.dv_filter_enabled or not lvar.dv_filter[dispval] then
      str2OV = dispval or str2OV
    end
    if dispval and lvar.display_overlay_active and (ss_color2 or ss_color) > 0 then
      local gstr = dispval or ''
      if oi then
        guistrOV = guistrB
      end
      local oi = oi or i
      local gmr = reaper.gmem_read(lvar.gm_fb.fader_input+(oi-1))
      if not lvar.display_overlay_inputonly or gmr == 1 then
        reaper.gmem_write(lvar.gm_fb.fader_input+(oi-1),0)
        if not lvar.display_overlay_idx[oi] then
          --local ssc = tmp.pos[i].butstates_array_sscolor[tmp.pos[i].bpos or -1] or tmp.pos[i].ss_color
          local n = #lvar.display_overlay+1
          lvar.display_overlay[n] = {i = oi,
                                     gmr = gmr,
                                     ontime = reaper.time_precise(),
                                     sscolor = ss_color2 or ss_color,
                                     str = guistrOV or guistr2 or guistr, --str,
                                     str2 = gstr,
                                     timeout = round(reaper.time_precise())+lvar.display_overlay_hold}
          lvar.display_overlay_idx[lvar.display_overlay[n].i] = n
        else
          --local ssc = tmp.pos[i].butstates_array_sscolor[tmp.pos[i].bpos or -1] or tmp.pos[i].ss_color
          local ontime = lvar.display_overlay[lvar.display_overlay_idx[oi]].ontime
          lvar.display_overlay[lvar.display_overlay_idx[oi]] = {i = oi,
                                                               gmr = gmr,
                                                               ontime = ontime,
                                                               sscolor = ss_color2 or ss_color,
                                                               str = guistrOV or guistr2 or guistr,
                                                               str2 = gstr,
                                                               timeout = round(reaper.time_precise())+lvar.display_overlay_hold}    
        end
        lupd.update_overlay = true
      end
    end

    --DBG((str2OV or str2)..'  '..ssnum)
    if ssnum and ctl_template.scrib[dev] then
   
      local sstab = ctl_template.scrib[dev][ssnum]
      if sstab then
        local out = {}
        --DBG((str2OV or str2)..'  '..(strOV or str)..' ','')
        for ss = 1, #sstab.ss_sysx do
          if sstab.ss_color and ss == sstab.ss_color then
            out[ss] = ss_color
          elseif sstab.ss_char[ss] then
            local n = ((sstab.ss_char[ss]-1) % scriblen) + 1
            if sstab.ss_char[ss] > scriblen then
              out[ss] = string.byte(str2OV or str2,n) or 0x20
            else
              out[ss] = string.byte(strOV or str,n) or 0x20
            end
          else
            out[ss] = sstab.ss_sysx[ss]
          end
          --DBG(out[ss])
          --[[if out[ss] >= 65 then
          DBG(string.char(out[ss]),'')
          end]]
        end
        --DBG('')
        local sxb = #lvar.sysxbuffer[dev]
        --lvar.sysxbuffer[dev][ctl_template.fader[i].ssnum] = out
        lvar.sysxbuffer[dev][ssnum] = out
      
        if lvar.virtualss_active then
          local gstr = dispval or ''
          if oi then
            guistrOV = guistrB
          end
          
          local key = '[VSS_'..ssnum
          --DBG(key)
          reaper.SetExtState('LBXVSS',key..'_DIRTY]',1,false)
          reaper.SetExtState('LBXVSS',key..'_GSTR1]',guistrOV or guistr2 or guistr,false)
          reaper.SetExtState('LBXVSS',key..'_GSTR2]',gstr,false)
          reaper.SetExtState('LBXVSS',key..'_STR1]',strOV or str,false)
          reaper.SetExtState('LBXVSS',key..'_STR2]',str2OV or str2,false)
          reaper.SetExtState('LBXVSS',key..'_COLOR]',--[[ss_color2 or ]]ss_color,false)
          if tmppos.val then
            reaper.SetExtState('LBXVSS',key..'_VAL]',tmppos.val/16383,false)
          else
            reaper.SetExtState('LBXVSS',key..'_VAL]',-1,false)
          end
        end
      end
    end
    
    return true
  end
  
  function Empty_SysXBuffer()
    for d = 0, 3 do
      if lvar.sysxbuffer[d] and not lvar.sysxinactive_dev[d] then
        local ssxb = {}
        local i = 1
        for a,b in pairs(lvar.sysxbuffer[d]) do
          ssxb[i] = b
          i=i+1
        end
        if #ssxb > 0 then
          if SendSYSX(d, ssxb) == nil then
            lvar.sysxinactive_dev[d] = true
            return 
          end

        end
        lvar.sysxbuffer[d] = {}
      
      elseif lvar.sysxbuffer[d] and lvar.sysxinactive_dev[d] then
  
        local s
        local trn = LBX_SYSX_OUT[d]
        local track = GetTrack(trn)
        if track then
          s = reaper.TrackFX_GetOffline(track,0)
          if s then
            break
          end
        else
          s = true
        end
        if not s then 
          --dev online - make active
          lvar.sysxinactive_dev[d] = nil
          lvar.msg = nil
          lupd.update_gfx = true
        end
        
      end
    end
    
    return true
  end
  
  function Scribble_FlashVal(i,dispval)

    local tmp
    tmp = GetTemplate(i)
--DBG(dispval..' '..i)
    local dev = ctl_template.fader[i].devbus
    if not permanent then
      if not lvar.flash_scribble then
        lvar.flash_scribble = {}
        lvar.flash_scribble_idx = {}
      end
      if lvar.flash_scribble_idx[i] then
      else
        lvar.flash_scribble[#lvar.flash_scribble+1] = i
        lvar.flash_scribble_idx[i] = #lvar.flash_scribble
      end

      if tmp.pos[i].valtime or ((tmp.pos[i].valtime or -1) == -1 and lvar.scribble_value_time > 0) then
        --if tmp.pos[i].ss_override_sscolor == 1 and (tmp.pos[i].butstates) == 2 then --change to tmp.pos flash time amount 
        --  lvar.flash_scribble_timer = reaper.time_precise() 
        --else
          if (tmp.pos[i].valtime or -1) >= 0 then
            lvar.flash_scribble_timer = reaper.time_precise() + tmp.pos[i].valtime
          elseif tmp.pos[i].valtime == 0 then
            lvar.flash_scribble_timer = reaper.time_precise()
          else
            lvar.flash_scribble_timer = reaper.time_precise() + lvar.scribble_value_time
          end
        --end
      else
        lvar.flash_scribble_timer = reaper.time_precise()
      end
    end
    
    local dispval2
    local scriblen = lvar.scriblen[dev] or 7
    if ctl_template.fader[i].lmode == 4 and tmp.pos[i].bpos then
      local bsarray = tmp.pos[i].butstates_array_name
      if bsarray[tmp.pos[i].bpos] then
        dispval2 = bsarray[tmp.pos[i].bpos]
        if dispval2 then
          --Padding for centering
          if string.len(dispval2) < scriblen-1 then
            dispval2  = string.rpad(dispval2,scriblen,' ')
            --DBG(dispval2..'  '..tmp.pos[i].bpos)
          end
        end
        --tmp.pos[i].dispval = dispval
      end
    end
    SendScribbleData2(tmp, nil, i, dispval2 or scribbleformat_singleline(dispval, scriblen))
        
  end
  
 --[[ function SendSYSX(bus, message)
    --local t = reaper.time_precise()
    local trn = LBX_SYSX_OUT[bus]
    if trn then
      local track = GetTrack(trn)
      local fxnum = 0
      local param = 0
    
      local lv = lvar.gm_sysx
      
      local gmem = reaper.gmem_read
      local gmem_wr = reaper.gmem_write
      if lvar.livemode == 0 then
     
        for m = 1, #message do
          
          --lvar.gm_sysx.msg_len = 1999999;
          --lvar.gm_sysx.sysx_msg = 2000000;
          --if (m == 1 and sst) or (m == 2 and ssb) then
            local t = reaper.time_precise()
            local timeout = reaper.time_precise()+2
            local ready = true
            --DBG(gmem(lv.msg_len))
            --while gmem(lv.msg_len) > 0 and t <= timeout do
            while reaper.TrackFX_GetParam(track,fxnum,param+1) == 0 and t <= timeout do
              t = reaper.time_precise()
            end
            if t > timeout then
              ready = false
            end
            
            if ready == true then
                for i = 1, #message[m] do
                  --gmem_wr(lv.sysx_msg + (i-1), message[m][i])
                  reaper.TrackFX_SetParam(track,fxnum,param,message[m][i])
                end
                --gmem_wr(lv.msg_len, #message[m])
            else
              --reaper.ShowConsoleMsg('timed out...! '..m)
              lvar.msg = 'SYSX timed out'
              return
            end
           
            reaper.TrackFX_SetParam(track, fxnum, 3, bus)
          --end
        end
      else
      
      end
      return true
    end
    --reaper.ShowConsoleMsg(reaper.time_precise()-t..'\n')
  end]]
  
  function SendSYSX(bus, message)

    local boff = bus*1000
    
    local trn = LBX_SYSX_OUT[bus]
    if trn then
      local track = GetTrack(trn)
      local fxnum = 0
      local param = 0
    
      local lv = lvar.gm_sysx
      
      local gmem = reaper.gmem_read
      local gmem_wr = reaper.gmem_write
      if lvar.livemode ~= 1 then

        local msgtot = 0
        gmem_wr(lv.msg_cnt+boff, #message) 
        --DBG(#message)
        --local dbgmsg,dmsg2, dmsg3 = '','',''
        for m = 1, #message do
          
            local timeout = reaper.time_precise() + 2
            local ready = true
            while gmem(lv.msg_ready +boff) ~= 1 --[[or t > timeout]] do
              t = reaper.time_precise()
              if not reaper.Audio_IsRunning() or t > timeout then
                ready = false
                break
              end
            end
            
            if ready == true then
                --dbgmsg = dbgmsg ..'\n'..m..'\n'
                --dmsg2, dmsg3 = '',''
                for i = 1, #message[m] do
                  --[[if message[m][i] >= 40 then
                    dmsg2 = dmsg2 ..string.char(message[m][i]) 
                    dmsg3 = dmsg3 ..message[m][i]..' ' 
                  end]]
                  gmem_wr(lv.sysx_msg +boff + msgtot, message[m][i])
                  msgtot = msgtot + 1
                  --reaper.TrackFX_SetParam(track,fxnum,param,message[m][i])
                end
                --dbgmsg = dbgmsg .. dmsg2 .. '  '..dmsg3
                --DBG('msglen:'..m-1 ..'  '..#message[m])
                gmem_wr(lv.msg_len+boff+(m-1), #message[m])
            else
              lvar.msg = 'SYSX timed out'
              return
            end
          --end
        end
        --DBG(dbgmsg)
        msgtot = msgtot - 1
        gmem_wr(lv.msg_lentot+boff, msgtot)
        --DBG('message tot:'..msgtot-1)
        --reaper.TrackFX_SetParam(track,fxnum,param,-1)
        if track then
          reaper.TrackFX_SetParam(track, fxnum, 3, bus)
          --DBG(bus..'  '..tostring(track))
        end
      else
      
      end
      return true
    end
    --reaper.ShowConsoleMsg(reaper.time_precise()-t..'\n')
  end
  
  function LoadLaneOverrideData()
  
    local tab = {}
    local ffn = paths.resource_path..LBX_LANESOV
    if reaper.file_exists(ffn) then
    
      data = {}
      for line in io.lines(ffn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          val = string.gsub(val, '[\r]', '') --Remove \r for Mac use
          data[idx] = val
        end
      end

      for a, b in pairs(data) do
        tab[a] = {all = string.gsub(b,'_','\n')}
        tab[a].ind = {}
        lane = 1
        for vel in string.gmatch(tab[a].all,'(\nVELLANE [-]?%d+ %d+ %d+)') do
          tab[a].ind[lane] = vel
          lane = lane + 1
        end
      end
    
    end
    lvar.lanes_ov_tab = tab
    
  end

  function SaveLaneOverrideData()
  
    local ffn = paths.resource_path..LBX_LANESOV
    file=io.open(ffn,"w")
    for a, b in pairs(lvar.lanes_ov_tab) do
      file:write('['..a..']'..string.gsub(b.all,'\n','_')..'\n')
    end
    file:close()
    
  end

  function LoadLanePresets()
  
    local tab = {}
    local ffn = paths.resource_path..LBX_LANESOVPRE
    if reaper.file_exists(ffn) then
    
      data = {}
      for line in io.lines(ffn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          val = string.gsub(val, '[\r]', '') --Remove \r for Mac use
          data[idx] = val
        end
      end

      for a, b in pairs(data) do
        local trnm, p = string.match(a,'(.*)_P(%d+)$')
        if trnm and p then
          p = tonumber(p)
          if p then
            if not tab[trnm] then
              tab[trnm] = {}
            end
            if b and b ~= '' then
              tab[trnm][p] = string.gsub(b,'_','\n')
            end
          end
        else
          local trnm = string.match(a,'(.*)_SELECT$')
          if trnm then
            if not tab[trnm] then
              tab[trnm] = {}
            end
            tab[trnm].select = tonumber(b)
          end
        end
      end
    
    end
    lvar.lanes_presets = tab
    
  end
  
  function SaveLanePresets()
  
    local ffn = paths.resource_path..LBX_LANESOVPRE
    file=io.open(ffn,"w")
    for a, b in pairs(lvar.lanes_presets) do
      for p = 1, 8 do
        if b[p] then
          file:write('['..a..'_P'..string.format('%i',p)..']'..string.gsub(b[p] or '','\n','_')..'\n')
        end
      end
      if b.select then
        file:write('['..a..'_SELECT]'..b.select..'\n')      
      end
    end
    file:close()
    
  end
  
  function GetLaneData()

    local hwnd = reaper.MIDIEditor_GetActive()
    if hwnd then
      local take = reaper.MIDIEditor_GetTake(hwnd)
      if take then
        local item = reaper.GetMediaItemTake_Item(take)
        local retval, chunk = reaper.GetItemStateChunk(item, '', false)
        local aa = string.match(chunk,'<.-(\nVELLANE.-)>')
        local vellane = string.match(aa,'(\nVELLANE [-]?%d+ %d+ %d+.*\nVELLANE [-]?%d+ %d+ %d+)') --WONT WORK WITH MULTIPLE TAKES
        if not vellane then
          vellane = string.match(aa,'(\nVELLANE [-]?%d+ %d+ %d+).*\n')
        end
        return vellane
      end
    end
      
  end
  
  function StoreLaneOverrideData(p)
  
    local vellane = GetLaneData()
    if vellane then
      GUI_FlashButton(obj, gui, 24, 'OVERRIDE', 0.1, '205 205 205', -4)
      if not lvar.lanes_ov_enable then
        lvar.lanes_ov_enable = true
        lupd.update_gfx = true
      end
      local track, trnm = GetCCLanesTrack()
      if track then
        if p then
          if not lvar.lanes_presets[trnm] then
            lvar.lanes_presets[trnm] = {}
          end
          lvar.lanes_presets[trnm][p] = vellane
        else
          lvar.lanes_ov_tab[trnm] = {all = vellane}
        end
      end
    end
    
  end
  
  function LoadLanesXtra()
  
    local tab = {}
    local ffn = paths.resource_path..LBX_LANESXTRA
    if reaper.file_exists(ffn) then
    
      data = {}
      for line in io.lines(ffn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          val = string.gsub(val, '[\r]', '') --Remove \r for Mac use
          data[idx] = val
        end
      end

      tab.velshow = tobool(data['velshow'])
      tab.velbottom = tobool(data['velbottom'])

      for a, b in pairs(data) do
      
        local typ = string.match(a,'.+_(.*)$')
        if typ then
          local s = string.match(a,'.*_(.*)_'..typ..'$')
          --DBG(a..'  '.. tostring(s))
          if s then
            local trnm = string.match(a,'(.*)_'..s..'_'..typ..'$')
            --DBG(trnm)
            local slot = tonumber(s)
          
            if not tab[trnm] then
              tab[trnm] = {}
            end
            if not tab[trnm][slot] then
              tab[trnm][slot] = {}
            end
            if typ == 'tabidx' then
              tab[trnm][slot].tabidx = tonumber(b)
            elseif typ == 'show' then
              tab[trnm][slot].show = tobool(b)
            elseif typ == 'bottom' then
              tab[trnm][slot].bottom = tobool(b)        
            end
          end
        end
      end

    end  
    lvar.lanes_xtra = tab
    
  end
  
  function SaveLanesXtra()
  
    local ffn = paths.resource_path..LBX_LANESXTRA
    file=io.open(ffn,"w")
    file:write('[velshow]'..tostring(lvar.lanes_xtra.velshow)..'\n')
    file:write('[velbottom]'..tostring(lvar.lanes_xtra.velbottom)..'\n')
    
    for trnm, tab in pairs(lvar.lanes_xtra) do  
      if trnm ~= 'velshow' and trnm ~= 'velbottom' then  
        for slot = 1, 4 do
          if lvar.lanes_xtra[trnm][slot] and lvar.lanes_xtra[trnm][slot].tabidx then
            file:write('['..trnm..'_'..slot..'_tabidx]'..lvar.lanes_xtra[trnm][slot].tabidx..'\n')
            file:write('['..trnm..'_'..slot..'_show]'..tostring(lvar.lanes_xtra[trnm][slot].show)..'\n')
            file:write('['..trnm..'_'..slot..'_bottom]'..tostring(lvar.lanes_xtra[trnm][slot].bottom)..'\n')
          end
        end    
      end
    end
    file:close()
  
  end
  
  
  
  function LoadAllTemplates()
  
    local templates = {}
    
    local pfn = paths.globtemplate_path..LBX_PERMATMP
    permatemplate = LoadFXParamTemplate(nil, fn, true, nil)
    
    --global
    local fol = paths.globtemplate_path
    local i = 0
    local tmpfn = reaper.EnumerateFiles(fol,i)
    while tmpfn ~= nil do
      local tmp = LoadFXParamTemplate(nil, fol..tmpfn, true, true)
      if tmp then
        templates[fol..tmpfn] = tmp
        --GUI_DrawMsg(obj, gui, {'LBX SRD TJL','','Smart Knobs 2', '', 'Loading Template', '', tmpfn,''},{14,10,18,2}, true) 
        
        --DBG('Template Loaded: '..tmpfn)
      end
      i=i+1
      tmpfn = reaper.EnumerateFiles(fol,i)
    end
    
    --track
    local fol = paths.tracktemplate_path
    local i = 0
    local tmpfn = reaper.EnumerateFiles(fol,i)
    while tmpfn ~= nil do
      local tmp = LoadFXParamTemplate(nil, fol..tmpfn, true, false)
      if tmp then
        templates[fol..tmpfn] = tmp
        --DBG('Template Loaded: '..tmpfn)
      end
      i=i+1
      tmpfn = reaper.EnumerateFiles(fol,i)
    end
    
    --plugin
    local fol = paths.template_path
    local i = 0
    local tmpfn = reaper.EnumerateFiles(fol,i)
    while tmpfn ~= nil do
      local tmp = LoadFXParamTemplate(nil, fol..tmpfn, true, false)
      if tmp then
        templates[fol..tmpfn] = tmp
        --DBG('Template Loaded: '..tmpfn)
      end
      i=i+1
      tmpfn = reaper.EnumerateFiles(fol,i)
    end
  
    lvar.templates = templates
  end
  
  function CheckTemplateExists(fn)
    if lvar.templates[fn] then
      return true
    end
  end
  
  function LoadFXParamTemplate(ffx, ffn, loadflag, globflag)
    
    DBGOut('Function Call: LoadFXParamTemplate: '..tostring(ffn)..' loadflag '..tostring(loadflag))
    
    lvar.readparams = nil
    lvar.deflayout = nil
    
    lvar.save_highlight = false
    --ResetLEDs()
    
    local tmp = {dirty = {},
                pos = {},
                sft = {},
                eft = {}}
    local loadtag
    if ffx then
    
      local CheckFN = reaper.file_exists
      if loadflag ~= true and lvar.loadalltemplates == true then
        CheckFN = CheckTemplateExists
      end
    
      if lvar.mode == 1 then
        ffn=paths.template_path..TrimFXName(ffx.fxplug)..'_'..(ffx.fxtype or '')..'.smtemp'
  
        if CheckFN(ffn) ~= true then
          ffn=paths.template_path..TrimFXName(ffx.fxplug)..'.smtemp'
          if CheckFN(ffn) ~= true then
            DBGOut('Plugin map not found!')
            return tmp
          end
        end    
        
      elseif lvar.mode == 2 then
        --Try loading instance specific template
        ffn=paths.template_path..TrimFXName(ffx.fxplug)..'_'..(ffx.fxtype or '')..'_'..ffx.fxname..'.smtemp'
        if CheckFN(ffn) ~= true then
          --Try loading plugin template
          ffn=paths.template_path..TrimFXName(ffx.fxplug)..'_'..(ffx.fxtype or '')..'.smtemp'  
          if CheckFN(ffn) ~= true then
            ffn=paths.template_path..TrimFXName(ffx.fxplug)..'.smtemp'
            if CheckFN(ffn) ~= true then
              DBGOut('Plugin instance map not found!')
              return tmp
            end
          end
        end
            
      elseif lvar.mode == 3 then
        local tag = lvar.tags.trackassoc[ffx.trname]
        --maybe change check file to checkfn at some point - when i do this remove loadtag
        if tag and lvar.tags.tags[tag.tag] and reaper.file_exists(paths.tags_path..lvar.tags.tags[tag.tag].fn) then
          ffn = paths.tags_path..lvar.tags.tags[tag.tag].fn
          loadtag = true
        else
          ffn=paths.tracktemplate_path..'TRACK_'..ffx.trname..'.smtemp'
          if CheckFN(ffn) ~= true then
            if lvar.defaulttemplate_active and lvar.defaulttemplate_type == 0 then
            
              ffn = paths.deftemplate_path..lvar.defaulttemplate_fn
              --ffn=paths.tracktemplate_path..LBX_DEFTRACKCCTMP
              if CheckFN(ffn) ~= true then
                DBGOut('Default track map not found!')
                return tmp
              else
                lvar.deflayout = true
              end
            else
              DBGOut('Track map not found!')
              return tmp
            end
          end
        end
      end
    
    end
    
    if loadflag ~= true and ffn and lvar.loadalltemplates == true and not loadtag then
      tmp = lvar.templates[ffn]
      
      if lvar.flip == 1 then
        FlipParams_Tmp(tmp)
      end
    
      updatetravellingtracknames(true)
    
    else
      if ffn and reaper.file_exists(ffn) then  
        DBGOut('Loading Map: '..ffn)
        
        local file
        data = {}
        for line in io.lines(ffn) do
          local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
          if idx then
            val = string.gsub(val, '[\r]', '') --Remove \r for Mac use
            data[idx] = val
          end
        end

        settings.floatfxgui = 0
        if data['floatgui'] then
          settings.floatfxgui = tonumber(data['floatgui'])
        end

        for i = 1, control_max do
        
          local pfx = 'ctl_'..i..'_'
  
          local loc = zn(data[pfx..'loc'])
          local ii = i
          if loc then
            --loc = string.gsub(loc, "\r", "")
            if lvar.ctlmapidx and lvar.ctlmapidx[loc] then
              ii = lvar.ctlmapidx[loc]
            else
              ii = -1
            end        
          end
          if ii ~= -1 then
  
            local cc = tobool(zn(data[pfx..'cc'],false))
            local pt = tonumber(zn(data[pfx..'ptype'],-1))
            
            if pt ~= -1 then
  --[[if loc == '0|For' then
    DBG(loc..'  '..ii..'  '..lvar.ctlmapidx[loc]..'   '..zn(data[pfx..'pname'],'')..'  '..ffn)
  end]]
  
              tmp.pos[ii] = {ptype = pt,
                             cc = cc,
                             cc14bit = tonumber(zn(data[pfx..'cc14bit'],false)),
                             ccchan = tonumber(zn(data[pfx..'ccchan'],-1)),
                             ccnum = tonumber(zn(data[pfx..'ccnum'],-1)),                            
                             pnum = zn(data[pfx..'pnum'],-1),

                             ptrack = tonumber(zn(data[pfx..'ptrack'],-99)),
                             ptrguid = zn(data[pfx..'ptrguid'],''),
                             pfxnum = tonumber(zn(data[pfx..'pfxnum'],-1)),
                             pfxguid = zn(data[pfx..'pfxguid'],''),
                             pfxmodule = zn(data[pfx..'pfxmodule']),
                             globalhost = tonumber(zn(data[pfx..'globalhost'],0)),

                             pname = zn(data[pfx..'pname'],''),
                             name = zn(data[pfx..'name']),
                             track = tonumber(zn(data[pfx..'track'],-1)),
                             trguid = zn(data[pfx..'trguid'],''),
                             troff = tonumber(zn(data[pfx..'troff'],-1)),
                             trparam = tonumber(zn(data[pfx..'trparam'],-1)),
                             trsend = tonumber(zn(data[pfx..'trsend'],-1)),
                             actionmon = tonumber(zn(data[pfx..'actionmon'],0)),
                             actionid = zn(data[pfx..'actionid'],-1),
                             code = tonumber(zn(data[pfx..'code'],-1)),
                             codeval = tonumber(zn(data[pfx..'codeval'],0)),
                             buttype = tonumber(zn(data[pfx..'buttype'],4)),
                             butstates = tonumber(zn(data[pfx..'butstates'],2)),
                             defcc_val = tonumber(zn(data[pfx..'defcc_val'])),
                             printval = tonumber(zn(data[pfx..'printval'])),
                             printvaldv = (zn(data[pfx..'printvaldv'])),
                             sscolor = tonumber(zn(data[pfx..'sscolor'])),
                             ledon = tonumber(zn(data[pfx..'ledon'])),
                             but_onval_override = tonumber(zn(data[pfx..'but_onval_override'],-1)),
                             exauto = tonumber(zn(data[pfx..'exauto'],0)),
                             polarity = tonumber(zn(data[pfx..'polarity'],0)),
                             valtime = tonumber(zn(data[pfx..'valtime'])),
                             min = tonumber(zn(data[pfx..'min'])),
                             max = tonumber(zn(data[pfx..'max'])),
                             linkA = (zn(data[pfx..'linkA'])),
                             linkA_linkonly = (zn(data[pfx..'linkA_linkonly'])),
                             linkB = (zn(data[pfx..'linkB'])),
                             linkA_mode = tonumber(zn(data[pfx..'linkA_mode'])),
                             linkB_mode = tonumber(zn(data[pfx..'linkB_mode'])),
                             ss_override = tonumber(zn(data[pfx..'ss_override'])),
                             ss_override_sscolor = tonumber(zn(data[pfx..'ss_override_sscolor'],0)),
                             ss_override_name = tonumber(zn(data[pfx..'ss_override_name'],0)),
                             butstates_array = {},
                             butstates_array_ext = {},
                             butstates_array_sscolor = {},
                             butstates_array_name = {},
                             lmode_ov = tonumber(zn(data[pfx..'lmode_ov']))}

              --DBGOut('F'..string.format('%i',i)..' ii '..ii..' '..tostring(tmp.pos[ii].pname)..'  '..tostring(tmp.pos[ii].name))
              
              if cc then
                tmp.pos[ii].enc_res = tonumber(zn(data[pfx..'enc_res'],128))
              else
                tmp.pos[ii].enc_res = tonumber(zn(data[pfx..'enc_res'],512))
              end
              
              if ctl_template.fader[ii].lmode == 4 then
                if tmp.pos[ii].buttype ~= 4 and tmp.pos[ii].buttype ~= 6 then
                  tmp.pos[ii].butstates = 1
                end
                
                local bsarray, bsarrayext = CalcButtStates(tmp.pos[ii].ptype, tmp.pos[ii].buttype, tmp.pos[ii].butstates)
                local gmem = reaper.gmem_write
                tmp.pos[ii].butstates_arrayidx = {}
                
                for b = 1, tmp.pos[ii].butstates do
                  local key = pfx..'bs'..b
                  local key2 = pfx..'bsext'..b
                  local key3 = pfx..'bssscol'..b
                  local key4 = pfx..'bsvname'..b
                  if data[key] then
                    tmp.pos[ii].butstates_array[b] = tonumber(data[key])
                    tmp.pos[ii].butstates_array_ext[b] = tonumber(data[key2])
                    tmp.pos[ii].butstates_array_sscolor[b] = tonumber(data[key3])
                    local v = data[key4]
                    if (v or '') ~= '' then
                      tmp.pos[ii].butstates_array_name[b] = v
                    end
                    if tmp.pos[ii].ptype == ptype.host then
                      tmp.pos[ii].butstates_arrayidx[math.ceil(tonumber(data[key]*100000))/100000] = b
                    else
                      tmp.pos[ii].butstates_arrayidx[tmp.pos[ii].butstates_array[b]] = b
                    end
                  else
                    tmp.pos[ii].butstates_array[b] = bsarray[b] or 0
                    tmp.pos[ii].butstates_array_ext[b] = bsarrayext[b] or 0
                    --if tmp.pos[ii].ptype == ptype.host then
                      tmp.pos[ii].butstates_arrayidx[bsarray[b] or 0] = b
                    --end
                  end
                end
              end
  
              if ctl_template.fader[ii].dtype == 999 then
                if tmp.pos[ii].lmode_ov then
                  ctl_template.fader[ii].lmode = tmp.pos[ii].lmode_ov
                end
              end
              
              --[[if tmp.pos[ii].buttype == 5 then
                tmp.pos[ii].buttype = 4
              end ]]
            else
              if cc == true then
                tmp.pos[ii] = {ptype = ptype.cc, 
                               cc = true,
                               cc14bit = 0,
                               ccchan =  tonumber(zn(data[pfx..'ccchan'],-1)),
                               ccnum = tonumber(zn(data[pfx..'ccnum'],-1)),                            
                               pnum = -1,
                               ptrack = -99,
                               pfxnum = -1,
                               globalhost = 0,
                               pname = zn(data[pfx..'pname'],''),
                               name = zn(data[pfx..'name']),
                               track = tonumber(zn(data[pfx..'track'],-1)),
                               trguid = zn(data[pfx..'trguid'],''),
                               troff = -1,
                               trparam = tonumber(zn(data[pfx..'trparam'],-1)),
                               trsend = tonumber(zn(data[pfx..'trsend'],-1)),                               
                               actionmon = 0,
                               actionid = -1,
                               buttype = 4,
                               enc_res = 128,
                               exauto = 0,
                               polarity = 0,
                               but_onval_override = -1,
                               butstates_array = {},
                               butstates_array_ext = {},
                               butstates_array_sscolor = {},
                               butstates_array_name = {}}
              elseif cc == false then
                local pnum = zn(data[pfx..'pnum'])
                if pnum then   
                  tmp.pos[ii] = {ptype = ptype.host,
                                 cc = false,
                                 cc14bit = 0,
                                 ccchan = -1,
                                 ccnum = -1,
                                 pnum = pnum,
                                 ptrack = -99,
                                 pfxnum = -1,
                                 globalhost = 0,
                                 pname = zn(data[pfx..'pname'],''),
                                 name = zn(data[pfx..'name']),
                                 track = tonumber(zn(data[pfx..'track'],-1)),
                                 trguid = zn(data[pfx..'trguid'],''),
                                 troff = -1,
                                 trparam = tonumber(zn(data[pfx..'trparam'],-1)),
                                 trsend = tonumber(zn(data[pfx..'trsend'],-1)),                               
                                 actionmon = 0,
                                 actionid = -1,
                                 buttype = 4,
                                 enc_res = 512,
                                 exauto = 0,
                                 polarity = 0,
                                 but_onval_override = -1,
                                 butstates_array = {},
                                 butstates_array_ext = {},
                                 butstates_array_sscolor = {},
                                 butstates_array_name = {}}
                end
              end
            end
            
          end
        end      
      
        if not globflag then
          
          --load overlay templates
          local ovtmp = {}

          for oi = 1, lvar.overtmp_cnt do
          
            if data['LAYER '..string.format('%i',oi)] then
          
              ovtmp[oi] = {dirty = {},
                           pos = {},
                           sft = {},
                           eft = {}}

              local pfx = 'L'..string.format('%i',oi)..'_'
              local lname = data[pfx..'NAME']
              if lname then
                ovtmp[oi].name = lname
              end          
    
              for i = 1, control_max do
                      
                local pfx = 'L'..string.format('%i',oi)..'_'..i..'_'
        
                local loc = zn(data[pfx..'loc'])
                local ii = i
                if loc then
                  --loc = string.gsub(loc, "\r", "")
                  if lvar.ctlmapidx and lvar.ctlmapidx[loc] then
                    ii = lvar.ctlmapidx[loc]
                  else
                    ii = -1
                  end        
                end
      
                if ii ~= -1 then
        
                  local cc = tobool(zn(data[pfx..'cc'],false))
                  local pt = tonumber(zn(data[pfx..'ptype'],-1))
                  if pt ~= -1 then
        
                    ovtmp[oi].pos[ii] = {ptype = pt,
                                   cc = cc,
                                   cc14bit = tonumber(zn(data[pfx..'cc14bit'],false)),
                                   ccchan = tonumber(zn(data[pfx..'ccchan'],-1)),
                                   ccnum = tonumber(zn(data[pfx..'ccnum'],-1)),                            
                                   pnum = zn(data[pfx..'pnum'],-1),
                                   --ptrack = -99,
                                   --pfxnum = -1,
                                   --globalhost = 0,
                                   ptrack = tonumber(zn(data[pfx..'ptrack'],-99)),
                                   ptrguid = zn(data[pfx..'ptrguid'],''),
                                   pfxnum = tonumber(zn(data[pfx..'pfxnum'],-1)),
                                   pfxguid = zn(data[pfx..'pfxguid'],''),
                                   pfxmodule = zn(data[pfx..'pfxmodule']),
                                   globalhost = tonumber(zn(data[pfx..'globalhost'],0)),

                                   pname = zn(data[pfx..'pname'],''),
                                   name = zn(data[pfx..'name']),
                                   track = tonumber(zn(data[pfx..'track'],-1)),
                                   trguid = zn(data[pfx..'trguid'],''),
                                   troff = tonumber(zn(data[pfx..'troff'],-1)),
                                   trparam = tonumber(zn(data[pfx..'trparam'],-1)),
                                   trsend = tonumber(zn(data[pfx..'trsend'],-1)),
                                   actionmon = tonumber(zn(data[pfx..'actionmon'],0)),
                                   actionid = zn(data[pfx..'actionid'],-1),
                                   code = tonumber(zn(data[pfx..'code'],-1)),
                                   codeval = tonumber(zn(data[pfx..'codeval'],0)),
                                   buttype = tonumber(zn(data[pfx..'buttype'],4)),
                                   butstates = tonumber(zn(data[pfx..'butstates'],2)),
                                   defcc_val = tonumber(zn(data[pfx..'defcc_val'])),
                                   printval = tonumber(zn(data[pfx..'printval'])),
                                   printvaldv = (zn(data[pfx..'printvaldv'])),
                                   sscolor = tonumber(zn(data[pfx..'sscolor'])),
                                   ledon = tonumber(zn(data[pfx..'ledon'])),
                                   but_onval_override = tonumber(zn(data[pfx..'but_onval_override'],-1)),
                                   exauto = tonumber(zn(data[pfx..'exauto'],0)),
                                   polarity = tonumber(zn(data[pfx..'polarity'],0)),
                                   valtime = tonumber(zn(data[pfx..'valtime'])),
                                   min = tonumber(zn(data[pfx..'min'])),
                                   max = tonumber(zn(data[pfx..'max'])),
                                   linkA = (zn(data[pfx..'linkA'])),
                                   linkA_linkonly = (zn(data[pfx..'linkA_linkonly'])),
                                   linkB = (zn(data[pfx..'linkB'])),
                                   linkA_mode = tonumber(zn(data[pfx..'linkA_mode'])),
                                   linkB_mode = tonumber(zn(data[pfx..'linkB_mode'])),
                                   ss_override = tonumber(zn(data[pfx..'ss_override'])),
                                   ss_override_sscolor = tonumber(zn(data[pfx..'ss_override_sscolor'],0)),
                                   ss_override_name = tonumber(zn(data[pfx..'ss_override_name'],0)),
                                   butstates_array = {},
                                   butstates_array_ext = {},
                                   butstates_array_sscolor = {},
                                   butstates_array_name = {},
                                   lmode_ov = tonumber(zn(data[pfx..'lmode_ov']))}
      
                    if cc then
                      ovtmp[oi].pos[ii].enc_res = tonumber(zn(data[pfx..'enc_res'],128))
                    else
                      ovtmp[oi].pos[ii].enc_res = tonumber(zn(data[pfx..'enc_res'],512))
                    end
                    
                    if ctl_template.fader[ii].lmode == 4 then
                      if ovtmp[oi].pos[ii].buttype ~= 4 and ovtmp[oi].pos[ii].buttype ~= 6 then
                        ovtmp[oi].pos[ii].butstates = 1
                      end
                      
                      local bsarray, bsarrayext = CalcButtStates(ovtmp[oi].pos[ii].ptype, ovtmp[oi].pos[ii].buttype, ovtmp[oi].pos[ii].butstates)
                      local gmem = reaper.gmem_write
                      ovtmp[oi].pos[ii].butstates_arrayidx = {}
                      
                      for b = 1, ovtmp[oi].pos[ii].butstates do
                        local key = pfx..'bs'..b
                        local key2 = pfx..'bsext'..b
                        local key3 = pfx..'bssscol'..b
                        local key4 = pfx..'bsvname'..b
                        if data[key] then
                          ovtmp[oi].pos[ii].butstates_array[b] = tonumber(data[key])
                          ovtmp[oi].pos[ii].butstates_array_ext[b] = tonumber(data[key2])
                          ovtmp[oi].pos[ii].butstates_array_sscolor[b] = tonumber(data[key3])
                          local v = data[key4]
                          if (v or '') ~= '' then
                            ovtmp[oi].pos[ii].butstates_array_name[b] = v
                          end
                          if ovtmp[oi].pos[ii].ptype == ptype.host then
                            ovtmp[oi].pos[ii].butstates_arrayidx[math.ceil(tonumber(data[key]*100000))/100000] = b
                          else
                            ovtmp[oi].pos[ii].butstates_arrayidx[ovtmp[oi].pos[ii].butstates_array[b]] = b
                          end
                        else
                          ovtmp[oi].pos[ii].butstates_array[b] = bsarray[b] or 0
                          ovtmp[oi].pos[ii].butstates_array_ext[b] = bsarrayext[b] or 0
                          --if ovtmp[oi].pos[ii].ptype == ptype.host then
                            ovtmp[oi].pos[ii].butstates_arrayidx[bsarray[b] or 0] = b
                          --end
                        end
                      end
                    end
        
                    if ctl_template.fader[ii].dtype == 999 then
                      if ovtmp[oi].pos[ii].lmode_ov then
                        ctl_template.fader[ii].lmode = ovtmp[oi].pos[ii].lmode_ov
                      end
                    end
                    
                    --[[if tmp.pos[ii].buttype == 5 then
                      tmp.pos[ii].buttype = 4
                    end ]]
                  else
                    if cc == true then
                      ovtmp[oi].pos[ii] = {ptype = ptype.cc, 
                                     cc = true,
                                     cc14bit = 0,
                                     ccchan =  tonumber(zn(data[pfx..'ccchan'],-1)),
                                     ccnum = tonumber(zn(data[pfx..'ccnum'],-1)),                            
                                     pnum = -1,
                                     ptrack = -99,
                                     pfxnum = -1,
                                     globalhost = 0,
                                     pname = zn(data[pfx..'pname'],''),
                                     name = zn(data[pfx..'name']),
                                     track = tonumber(zn(data[pfx..'track'],-1)),
                                     trguid = zn(data[pfx..'trguid'],''),
                                     troff = -1,
                                     trparam = tonumber(zn(data[pfx..'trparam'],-1)),
                                     trsend = tonumber(zn(data[pfx..'trsend'],-1)),                               
                                     actionmon = 0,
                                     actionid = -1,
                                     buttype = 4,
                                     enc_res = 128,
                                     exauto = 0,
                                     polarity = 0,
                                     but_onval_override = -1,
                                     butstates_array = {},
                                     butstates_array_ext = {},
                                     butstates_array_sscolor = {},
                                     butstates_array_name = {}}
                    elseif cc == false then
                      local pnum = zn(data[pfx..'pnum'])
                      if pnum then   
                        ovtmp[oi].pos[ii] = {ptype = ptype.host,
                                       cc = false,
                                       cc14bit = 0,
                                       ccchan = -1,
                                       ccnum = -1,
                                       pnum = pnum,
                                       ptrack = -99,
                                       pfxnum = -1,
                                       globalhost = 0,
                                       pname = zn(data[pfx..'pname'],''),
                                       name = zn(data[pfx..'name']),
                                       track = tonumber(zn(data[pfx..'track'],-1)),
                                       trguid = zn(data[pfx..'trguid'],''),
                                       troff = -1,
                                       trparam = tonumber(zn(data[pfx..'trparam'],-1)),
                                       trsend = tonumber(zn(data[pfx..'trsend'],-1)),                               
                                       actionmon = 0,
                                       actionid = -1,
                                       buttype = 4,
                                       enc_res = 512,
                                       exauto = 0,
                                       polarity = 0,
                                       but_onval_override = -1,
                                       butstates_array = {},
                                       butstates_array_ext = {},
                                       butstates_array_sscolor = {},
                                       butstates_array_name = {}}
                      end
                    end
                  end
                  
                end
              end
              
          
          
            end
          
          end
          
          --overtemplates = ovtmp
          tmp.layer = ovtmp
          
        end
      
        if lvar.flip == 1 then
          FlipParams_Tmp(tmp)
        end
      
        updatetravellingtracknames(true)
      else
        DBGOut('Map not found!')
      end
    end    
    
    return tmp
  end
  
  function InsertTakeoverAssignments()

    totemplate = {dirty = {},
                  pos = {},
                  sft = {},
                  eft = {}}
    local tmp = totemplate
    --if lvar.takeover.active == -1 then return tmp end
    
    if lvar.takeover.active ~= -1 then 
      local fad = lvar.takeover.fader_to[lvar.takeover.active]
      if fad then
        local idx = string.format('%i',lvar.takeover.bus)..'|Fader '..string.format('%i',lvar.takeover.channel)   
        local i = lvar.ctlmapidx[idx]
        if i then
          tmp.pos[i] = table.copy(lvar.takeover_types[fad])
        end
      end
  
      local enc = lvar.takeover.encoder_to[lvar.takeover.active]
      if enc then
        local idx = string.format('%i',lvar.takeover.bus)..'|Encoder '..string.format('%i',lvar.takeover.channel)   
        local i = lvar.ctlmapidx[idx]
        if i then
          tmp.pos[i] = table.copy(lvar.takeover_types[enc])
        end
      end
    end
    
    lvar.readparams = nil
    updatetravellingtracknames(true)
    --TemplateChanged()    

  end
  
  function SaveFXParamTemplate(ffx, template, ffn, donotflip, globflag)
    if ffx or ffn then
    
      --if not glob then
        if not ffn then
          
          if lvar.mode == 1 then
            ffn=paths.template_path..TrimFXName(ffx.fxplug)..'_'..ffx.fxtype..'.smtemp'
          elseif lvar.mode == 2 then
            ffn=paths.template_path..TrimFXName(ffx.fxplug)..'_'..ffx.fxtype..'_'..ffx.fxname..'.smtemp'
          elseif lvar.mode == 3 then
            ffn=paths.tracktemplate_path..'TRACK_'..ffx.trname..'.smtemp'
          end
        
        --else
          --ffn=paths.tracktemplate_path..ffn..'.smtemp'
        end
      --else
      --  ffn=paths.globtemplate_path..ffn..'smtemp'
      --end

      file=io.open(ffn,"w")
      if not file then
        --likely invalid filename
        reaper.MB('Could not create template file.  The likely cause is the track name, or plugin instance name, '
                  ..'contains characters which are not valid in a filename.  Please rename the track or plugin instance and try again.\n\n'
                  ..'Invalid characters are: \\ / : * ? " < > |',
                  'Template save error', 0)
        return
      end
      
      if not donotflip and lvar.flip == 1 then
        FlipParams_Tmp(template)
      end
      
      file:write('[floatgui]'..(settings.floatfxgui or 0)..'\n')
      
      local assignedcnt = 0
      
      --local gmem = reaper.gmem_read
      for i = 1, control_max do
      
        if template.pos[i] and template.pos[i].ptype then
          assignedcnt = assignedcnt + 1
          local pfx = 'ctl_'..i..'_'
          
          local loc = (ctl_template.fader[i].odevbus or ctl_template.fader[i].devbus)..'|'..(ctl_template.fader[i].devctl or '<PORT MISSING>')
          
          file:write('[' .. pfx ..'ptype]'..template.pos[i].ptype..'\n')
          file:write('[' .. pfx ..'cc]'..tostring(template.pos[i].cc)..'\n')
          file:write('[' .. pfx ..'cc14bit]'..tostring(template.pos[i].cc14bit)..'\n')
          file:write('[' .. pfx ..'ccchan]'..tostring(template.pos[i].ccchan)..'\n')
          file:write('[' .. pfx ..'ccnum]'..tostring(template.pos[i].ccnum)..'\n')
          file:write('[' .. pfx ..'pnum]'..template.pos[i].pnum..'\n')
          
          file:write('[' .. pfx ..'ptrack]'..(template.pos[i].ptrack or -99)..'\n')
          file:write('[' .. pfx ..'ptrguid]'..(template.pos[i].ptrguid or '')..'\n')
          file:write('[' .. pfx ..'pfxnum]'..(template.pos[i].pfxnum or -1)..'\n')
          file:write('[' .. pfx ..'pfxguid]'..(template.pos[i].pfxguid or '')..'\n')
          file:write('[' .. pfx ..'pfxmodule]'..(template.pos[i].pfxmodule or '')..'\n')
          file:write('[' .. pfx ..'globalhost]'..(template.pos[i].globalhost or 0)..'\n')
          
          file:write('[' .. pfx ..'pname]'..template.pos[i].pname..'\n')
          file:write('[' .. pfx ..'name]'..(template.pos[i].tmpname or template.pos[i].name or '')..'\n')
          file:write('[' .. pfx ..'track]'..(template.pos[i].track or -2)..'\n')
          file:write('[' .. pfx ..'trguid]'..(template.pos[i].trguid or '')..'\n')
          file:write('[' .. pfx ..'trparam]'..(template.pos[i].trparam or -1)..'\n')
          file:write('[' .. pfx ..'trsend]'..(template.pos[i].trsend or -1)..'\n')
          file:write('[' .. pfx ..'troff]'..(template.pos[i].troff or -1)..'\n')
          file:write('[' .. pfx ..'actionid]'..(template.pos[i].actionid or -1)..'\n')
          file:write('[' .. pfx ..'actionmon]'..(template.pos[i].actionmon or 0)..'\n')
          file:write('[' .. pfx ..'ledon]'..(template.pos[i].ledon or '')..'\n')
          file:write('[' .. pfx ..'but_onval_override]'..(template.pos[i].but_onval_override or -1)..'\n')
          file:write('[' .. pfx ..'exauto]'..(template.pos[i].exauto or 0)..'\n')
          file:write('[' .. pfx ..'polarity]'..(template.pos[i].polarity or 0)..'\n')
          file:write('[' .. pfx ..'valtime]'..(template.pos[i].valtime or '')..'\n')

          if template.pos[i].min and template.pos[i].min > 0 then
            file:write('[' .. pfx ..'min]'..template.pos[i].min..'\n')
          end
          if template.pos[i].max and template.pos[i].max < 1 then
            file:write('[' .. pfx ..'max]'..template.pos[i].max..'\n')
          end
          
          file:write('[' .. pfx ..'linkA]'..(template.pos[i].linkA or '')..'\n')
          file:write('[' .. pfx ..'linkA_linkonly]'..(template.pos[i].linkA_linkonly or '')..'\n')
          file:write('[' .. pfx ..'linkB]'..(template.pos[i].linkB or '')..'\n')
          file:write('[' .. pfx ..'linkA_mode]'..(template.pos[i].linkA_mode or 1)..'\n')
          file:write('[' .. pfx ..'linkB_mode]'..(template.pos[i].linkB_mode or 1)..'\n')

          file:write('[' .. pfx ..'ss_override]'..(template.pos[i].ss_override or '')..'\n')
          file:write('[' .. pfx ..'ss_override_sscolor]'..(template.pos[i].ss_override_sscolor or 0)..'\n')
          file:write('[' .. pfx ..'ss_override_name]'..(template.pos[i].ss_override_name or 0)..'\n')
          file:write('[' .. pfx ..'buttype]'..(template.pos[i].buttype or 4)..'\n')
          if ctl_template.fader[i].lmode == 4 then
            if template.pos[i].buttype ~= 4 and template.pos[i].buttype ~= 6 then
              template.pos[i].butstates = 1
            end
          end
                    
          file:write('[' .. pfx ..'butstates]'..(template.pos[i].butstates or 2)..'\n')
          file:write('[' .. pfx ..'code]'..(template.pos[i].code or -1)..'\n')
          file:write('[' .. pfx ..'codeval]'..(template.pos[i].codeval or 0)..'\n')
          file:write('[' .. pfx ..'enc_res]'..(template.pos[i].enc_res or 128)..'\n')
          file:write('[' .. pfx ..'defcc_val]'..(template.pos[i].defcc_val or '')..'\n')
          file:write('[' .. pfx ..'printval]'..(template.pos[i].printval or '')..'\n')
          file:write('[' .. pfx ..'printvaldv]'..(template.pos[i].printvaldv or '')..'\n')
          file:write('[' .. pfx ..'loc]'..loc..'\n')
  
          file:write('[' .. pfx ..'sscolor]'..(template.pos[i].sscolor or '')..'\n')
      
          if ctl_template.fader[i].lmode == 4 then
            local bsarray, bsarrayext = CalcButtStates(template.pos[i].ptype, template.pos[i].buttype, template.pos[i].butstates)
            --DBG('save '..i..'  '..template.pos[i].butstates)
            for b = 1, template.pos[i].butstates do
              local key = pfx..'bs'..b
              local key2 = pfx..'bsext'..b
              local key3 = pfx..'bssscol'..b
              local key4 = pfx..'bsvname'..b
              local v = template.pos[i].butstates_array[b] or -1
              local v2 = template.pos[i].butstates_array_ext[b] or -99
              local v3 = template.pos[i].butstates_array_sscolor[b] or ''
              local v4 = template.pos[i].butstates_array_name[b] or ''
              if v == -1 then
                v = bsarray[b] or 0
              end
              if v2 == -99 then
                v2 = bsarrayext[b] or 0
              end
              file:write('[' .. key ..']'..v..'\n')          
              file:write('[' .. key2 ..']'..v2..'\n')          
              file:write('[' .. key3 ..']'..v3..'\n')
              file:write('[' .. key4 ..']'..v4..'\n')
            end
          end
          if template.pos[i].lmode_ov then
            file:write('[' .. pfx ..'lmode_ov]'..template.pos[i].lmode_ov..'\n')
          end
  
        end
      
      end
      
      if not globflag then

        local layers = template.layer
        if layers then
          for a, b in pairs(layers) do
        
            file:write('[LAYER ' .. string.format('%i',a) ..']\n')
            if b.name then
              local pfx = 'L'..string.format('%i',a)..'_'
              file:write('[' .. pfx ..'NAME]'..b.name..'\n')
            end
            
            for i = 1, control_max do
                  
              if b.pos[i] and b.pos[i].ptype then
                assignedcnt = assignedcnt + 1
                
                local pfx = 'L'..string.format('%i',a)..'_'..i..'_'
                
                local loc = ctl_template.fader[i].devbus..'|'..(ctl_template.fader[i].devctl or '<PORT MISSING>')
                
                file:write('[' .. pfx ..'ptype]'..b.pos[i].ptype..'\n')
                file:write('[' .. pfx ..'cc]'..tostring(b.pos[i].cc)..'\n')
                file:write('[' .. pfx ..'cc14bit]'..tostring(b.pos[i].cc14bit)..'\n')
                file:write('[' .. pfx ..'ccchan]'..tostring(b.pos[i].ccchan)..'\n')
                file:write('[' .. pfx ..'ccnum]'..tostring(b.pos[i].ccnum)..'\n')
                file:write('[' .. pfx ..'pnum]'..b.pos[i].pnum..'\n')

                file:write('[' .. pfx ..'ptrack]'..(b.pos[i].ptrack or -99)..'\n')
                file:write('[' .. pfx ..'ptrguid]'..(b.pos[i].ptrguid or '')..'\n')
                file:write('[' .. pfx ..'pfxnum]'..(b.pos[i].pfxnum or -1)..'\n')
                file:write('[' .. pfx ..'pfxguid]'..(b.pos[i].pfxguid or '')..'\n')
                file:write('[' .. pfx ..'pfxmodule]'..(b.pos[i].pfxmodule or '')..'\n')
                file:write('[' .. pfx ..'globalhost]'..(b.pos[i].globalhost or 0)..'\n')
                
                file:write('[' .. pfx ..'pname]'..b.pos[i].pname..'\n')
                file:write('[' .. pfx ..'name]'..(b.pos[i].tmpname or b.pos[i].name or '')..'\n')
                file:write('[' .. pfx ..'track]'..(b.pos[i].track or -2)..'\n')
                file:write('[' .. pfx ..'trguid]'..(b.pos[i].trguid or '')..'\n')
                file:write('[' .. pfx ..'trparam]'..(b.pos[i].trparam or -1)..'\n')
                file:write('[' .. pfx ..'trsend]'..(b.pos[i].trsend or -1)..'\n')
                file:write('[' .. pfx ..'troff]'..(b.pos[i].troff or -1)..'\n')
                file:write('[' .. pfx ..'actionid]'..(b.pos[i].actionid or -1)..'\n')
                file:write('[' .. pfx ..'actionmon]'..(b.pos[i].actionmon or 0)..'\n')
                file:write('[' .. pfx ..'ledon]'..(b.pos[i].ledon or '')..'\n')
                file:write('[' .. pfx ..'but_onval_override]'..(b.pos[i].but_onval_override or -1)..'\n')
                file:write('[' .. pfx ..'exauto]'..(b.pos[i].exauto or 0)..'\n')
                file:write('[' .. pfx ..'polarity]'..(b.pos[i].polarity or 0)..'\n')
                file:write('[' .. pfx ..'valtime]'..(b.pos[i].valtime or '')..'\n')

                if b.pos[i].min and b.pos[i].min > 0 then
                  file:write('[' .. pfx ..'min]'..b.pos[i].min..'\n')
                end
                if b.pos[i].max and b.pos[i].max < 1 then
                  file:write('[' .. pfx ..'max]'..b.pos[i].max..'\n')
                end

                file:write('[' .. pfx ..'linkA]'..(b.pos[i].linkA or '')..'\n')
                file:write('[' .. pfx ..'linkA_linkonly]'..(b.pos[i].linkA_linkonly or '')..'\n')
                file:write('[' .. pfx ..'linkB]'..(b.pos[i].linkB or '')..'\n')
                file:write('[' .. pfx ..'linkA_mode]'..(b.pos[i].linkA_mode or 1)..'\n')
                file:write('[' .. pfx ..'linkB_mode]'..(b.pos[i].linkB_mode or 1)..'\n')
                
                file:write('[' .. pfx ..'ss_override]'..(b.pos[i].ss_override or '')..'\n')
                file:write('[' .. pfx ..'ss_override_sscolor]'..(b.pos[i].ss_override_sscolor or 0)..'\n')
                file:write('[' .. pfx ..'ss_override_name]'..(b.pos[i].ss_override_name or 0)..'\n')
                file:write('[' .. pfx ..'buttype]'..(b.pos[i].buttype or 4)..'\n')
                if ctl_template.fader[i].lmode == 4 then
                  if b.pos[i].buttype ~= 4 and b.pos[i].buttype ~= 6 then
                    b.pos[i].butstates = 1
                  end
                end
                          
                file:write('[' .. pfx ..'butstates]'..(b.pos[i].butstates or 2)..'\n')
                file:write('[' .. pfx ..'code]'..(b.pos[i].code or -1)..'\n')
                file:write('[' .. pfx ..'codeval]'..(b.pos[i].codeval or 0)..'\n')
                file:write('[' .. pfx ..'enc_res]'..(b.pos[i].enc_res or 128)..'\n')
                file:write('[' .. pfx ..'defcc_val]'..(b.pos[i].defcc_val or '')..'\n')
                file:write('[' .. pfx ..'printval]'..(b.pos[i].printval or '')..'\n')
                file:write('[' .. pfx ..'printvaldv]'..(b.pos[i].printvaldv or '')..'\n')
                file:write('[' .. pfx ..'loc]'..loc..'\n')
        
                file:write('[' .. pfx ..'sscolor]'..(b.pos[i].sscolor or '')..'\n')
            
                if ctl_template.fader[i].lmode == 4 then
                  local bsarray, bsarrayext = CalcButtStates(b.pos[i].ptype, b.pos[i].buttype, b.pos[i].butstates)
                  for bb = 1, b.pos[i].butstates do
                    local key = pfx..'bs'..bb
                    local key2 = pfx..'bsext'..bb
                    local key3 = pfx..'bssscol'..bb
                    local key4 = pfx..'bsvname'..bb
                    local v = b.pos[i].butstates_array[bb] or -1
                    local v2 = b.pos[i].butstates_array_ext[bb] or -99
                    local v3 = b.pos[i].butstates_array_sscolor[bb] or ''
                    local v4 = b.pos[i].butstates_array_name[bb] or ''
                    if v == -1 then
                      v = bsarray[bb] or 0
                    end
                    if v2 == -99 then
                      v2 = bsarrayext[bb] or 0
                    end
                    file:write('[' .. key ..']'..v..'\n')          
                    file:write('[' .. key2 ..']'..v2..'\n')          
                    file:write('[' .. key3 ..']'..v3..'\n')          
                    file:write('[' .. key4 ..']'..v4..'\n')          
                  end
                end
                if b.pos[i].lmode_ov then
                  file:write('[' .. pfx ..'lmode_ov]'..b.pos[i].lmode_ov..'\n')
                end
              
              end
            end
        
          end
        end
      end
      
      file:close()      
      
      if assignedcnt == 0 then
        --empty template - delete
        os.remove(ffn)
      end
      
      if lvar.loadalltemplates then
        local tmp = LoadFXParamTemplate(nil, ffn, true)
        if tmp then
          lvar.templates[ffn] = tmp
        end
      end
      
      if not donotflip and lvar.flip == 1 then
        FlipParams_Tmp(template)
      end
          
    end
  end
  
  function ResetCtlMap()
    ctl_template = {fader = {}, fb = {}, flip = {}, devsysx = {}, scrib = {}, notesthru = {}, but_onval = {}, maxgrp = 0, maxsort = 0}
    lvar.tc_display = {}
    lvar.ass_display = {}
    lvar.hardout = {}
    lvar.sysxbuffer = {}
    lvar.group = {}
    lvar.groupidx = {}
    lvar.groupctlidx = {}
    lvar.groupctlidx2 = {}
    lvar.ssnumidx = {}
    lvar.groupcnt = 0
    lvar.sortgrps = {}
    lvar.chanstrips = {idx = {}, idx2 = {}, count = 0} --idx2 = faders only
    
    --lvar.ssa = {}
  end
  
  function SYSX_StrToTable(sysxstr)
  
    local t = {}
    local str = ''
    sysxstr = sysxstr..' '
    for i in sysxstr:gmatch("(.-)%s+") do 
      t[#t+1] = tonumber(i) or i
      str = str..' '..t[#t]
    end
    return t
  
  end
  
  function RemapMenu(slot,x,y)
  
    if lvar.remap.ctl[slot] or lvar.remap.ctl2[slot] then
      local mstr = '#Remap Control||Clear Remapped Control||Clear All Remapped Controls'
      gfx.x = x
      gfx.y = y
      local res = gfx.showmenu(mstr)
      if res > 1 then
        if res == 2 then
          if lvar.remap.ctl[slot] then
            lvar.remap.ctl2[lvar.remap.ctl[slot]] = nil
            lvar.remap.ctl[slot] = nil
          else
            lvar.remap.ctl[lvar.remap.ctl2[slot]] = nil
            lvar.remap.ctl2[slot] = nil
          end
          RemapChange()
        elseif res == 3 then
          lvar.remap.ctl = {}
          lvar.remap.ctl2 = {}
          RemapChange()
        end
      end
    else
      local lmode = ctl_template.fader[slot].lmode
      local tab = {}
      local allowed = {[0] = true, [1] = true, [2] = true}
      for f = 1, lvar.fcount do
        if f ~= slot and ctl_template.fader[f].lmode == lmode and allowed[ctl_template.fader[f].dtype] then
          local dev = ctl_template.fader[f].devbus
          local available = true
          if lvar.remap.ctl[f] or lvar.remap.ctl2[f] then
            available = false
          end
          tab[#tab+1] = {slot = f, available = available, name = lvar.midimap[dev+1]..' '..ctl_template.fader[f].devctl}
        end
      end
      local mstr = '#Remap Control|'
      for i = 1, #tab do
        local avail = ''
        if not tab[i].available then
          avail = '#'
        end
        mstr = mstr .. '|' .. avail .. tab[i].slot .. ' / '.. tab[i].name
      end
      gfx.x = x
      gfx.y = y
      local res = gfx.showmenu(mstr)
      if res > 1 then
        res = res - 1
        local tslot = tab[res].slot
        lvar.remap.ctl[slot] = tslot
        lvar.remap.ctl2[tslot] = slot
        RemapChange()
      end
    end
    
  end
  
  function ResetDevices()
    
    reaper.Audio_Quit()
    reaper.Audio_Init()
    reaper.Main_OnCommand(41175, 0) --reset midi devices
    
    lvar.sysxinactive_dev = {}
    lvar.sysxinactive = nil
    
    lvar.remap_active = false
    lvar.remap.data = nil    
    RemapCtls(false)
    
    ResetCtlMap()
    for i = 1, 4 do
      if lvar.midimap[i] then
        local fn = paths.ctemplate_path..lvar.midimap[i]..'.skctlmap'
        LoadCtlMap(fn,i)
      end
    end
    SortCtlMap()
    SetCtlMap()
    
    TemplateChanged()
  
    --SaveRemap()
    
    lupd.update_gfx = true
  end
  
  function RemapChange()
    
    lvar.sysxinactive_dev = {}
    lvar.sysxinactive = nil
    
    lvar.remap_active = false
    lvar.remap.data = nil    
    RemapCtls(false)
    
    ResetCtlMap()
    for i = 1, 4 do
      if lvar.midimap[i] then
        local fn = paths.ctemplate_path..lvar.midimap[i]..'.skctlmap'
        LoadCtlMap(fn,i)
      end
    end
    SortCtlMap()
    SetCtlMap()
    
    TemplateChanged()

    SaveRemap()
    
    lupd.update_gfx = true
  end
  
  function SaveRemap()
  
    local fn = paths.resource_path..'remapped_controls.sk2remap'
    file=io.open(fn,"w")
    if file then
      for a, b in pairs(lvar.remap.ctl) do
        file:write('['..string.format('%i',a)..']'..string.format('%i',b)..'\n')
      end
      file:close()
    end
    
  end

  function LoadRemap()
  
    local fn = paths.resource_path..'remapped_controls.sk2remap'
    if reaper.file_exists(fn) then
            
      local data = {}
      for line in io.lines(fn) do
        local idx, val = string.match(line,'^%[(.-)%](.*)') --decipher(line)
        if idx then
          lvar.remap.ctl[tonumber(idx)] = tonumber(val)
          lvar.remap.ctl2[tonumber(val)] = tonumber(idx)
        end
      end
    end
    
  end
  
  function RemapCtls(enable)
    if not lvar.remap.data then return end
    
    for src, dst in pairs(lvar.remap.ctl) do
      local data = lvar.remap.data[src]
      if enable then
        
        ctl_template.fader[src].devbus = data.dsttab.devbus
        ctl_template.fader[src].dtype = data.dsttab.dtype
        ctl_template.fader[src].dcode = data.dsttab.dcode
        ctl_template.fader[src].dchan = data.dsttab.dchan
        ctl_template.fader[src].ttype = data.dsttab.ttype
        ctl_template.fader[src].tcode = data.dsttab.tcode
        ctl_template.fader[src].tchan = data.dsttab.tchan
        ctl_template.fader[src].ton = data.dsttab.ton
        ctl_template.fader[src].toff = data.dsttab.toff
        ctl_template.fb[src] = data.dstfb
        ctl_template.fader[src].remapped = 2
        
        ctl_template.fader[dst].odevbus = data.dsttab.devbus
        ctl_template.fader[dst].devbus = -1
        ctl_template.fader[dst].dtype = tab_dtype['DUMMY']
        ctl_template.fader[dst].dcode = 0
        ctl_template.fader[dst].dchan = 0
        ctl_template.fader[dst].ttype = nil
        ctl_template.fb[dst] = nil
        ctl_template.fader[dst].remapped = 1
        
      else

        ctl_template.fader[dst].odevbus = nil 
        ctl_template.fader[dst].devbus = data.dsttab.devbus
        ctl_template.fader[dst].dtype = data.dsttab.dtype
        ctl_template.fader[dst].dcode = data.dsttab.dcode
        ctl_template.fader[dst].dchan = data.dsttab.dchan
        ctl_template.fader[dst].ttype = data.dsttab.ttype
        ctl_template.fader[dst].tcode = data.dsttab.tcode
        ctl_template.fader[dst].tchan = data.dsttab.tchan
        ctl_template.fader[dst].ton = data.dsttab.ton
        ctl_template.fader[dst].toff = data.dsttab.toff
        ctl_template.fb[dst] = data.dstfb
        ctl_template.fader[dst].remapped = 2
        
        ctl_template.fader[src].odevbus = data.srctab.devbus
        ctl_template.fader[src].devbus = -1
        ctl_template.fader[src].dtype = tab_dtype['DUMMY']
        ctl_template.fader[src].dcode = 0
        ctl_template.fader[src].dchan = 0
        ctl_template.fader[src].ttype = nil
        ctl_template.fb[src] = nil
        ctl_template.fader[src].remapped = 1
        
      end
      
    end

    SetCtlMap(true)
    TemplateChanged()
    
    lupd.update_gfx = true

  end
  
  function RemapFader(src, dst)
    if lvar.remap.data == nil then
      lvar.remap.data = {}
    end
    lvar.remap.data[src] = {dst = dst, dsttab = table.copy(ctl_template.fader[dst]), srctab = table.copy(ctl_template.fader[src]),
                            dstfb = table.copy(ctl_template.fb[dst]), srcfb = table.copy(ctl_template.fb[src])}
    --Indexes should still work ok - as ctlmapidx defined before remapping
    
    local devbus = ctl_template.fader[src].devbus
    local fb = ctl_template.fb[src] or ctl_template.fader[src]
    
    SendMIDIFB_Reset(devbus,fb.dtype,fb.dchan,fb.dcode,fb.dA,fb.dB)
    
    ctl_template.fader[src].odevbus = ctl_template.fader[src].devbus
    ctl_template.fader[src].devbus = -1
    ctl_template.fader[src].dtype = tab_dtype['DUMMY']
    ctl_template.fader[src].dcode = 0
    ctl_template.fader[src].dchan = 0
    ctl_template.fader[src].ttype = nil
    ctl_template.fader[src].remapped = 1
  end

  function RemapFaders()
    for src, dst in pairs(lvar.remap.ctl) do
      RemapFader(src, dst)
    end
  end
  
  function AddDummyFader(n, sort, group)
    local tmp = {}
    tmp.sort = tonumber(sort)
    tmp.group = tonumber(group)
    tmp.devbus = -1
    tmp.devctl = 'DUMMY '..string.format('%i',n)
    tmp.dtype = tab_dtype['DUMMY']
    tmp.dcode = 0
    tmp.dchan = 0
    tmp.lmode = 0
    
    return tmp
  end
  
  function AddDummyFaders(n)
    
    local tmp = ctl_template.fader
    local maxsort = ctl_template.maxsort+1
    local maxgrp = ctl_template.maxgrp+1
    local cnt = #tmp
    for i = 1, n do
      tmp[cnt+i] = AddDummyFader(i, maxsort, maxgrp)
    end
    ctl_template.maxgrp = maxgrp
    ctl_template.maxsort = maxsort
    
    --LoadDummyData() --fcount unavailable here
    
  end
  
  function LoadCtlMap(fn, d)
    DBGOut('Function call: LoadCtlMap: '..fn..' Device '..d)
    local incheck, outcheck
    for a, b in pairs(lvar.midiinput_ctl) do
      if tonumber(b.bus) == tonumber(d-1) then
        incheck = true
        break
      end
    end
    for a, b in pairs(lvar.midioutput_ctl) do
      if tonumber(b.bus) == tonumber(d-1) then
        outcheck = true
        break
      end
    end

    if reaper.file_exists(fn) and ((incheck and outcheck) or not lvar.checkmidiports) then
      
      local file
      
      local data = {}
      for line in io.lines(fn) do
        local idx, val = string.match(line,'^%[(.-)%](.*)') --decipher(line)
        if idx then
          data[idx] = val
        end
      end
    
      --local tmp = {fader = {}, fb = {}, flip = {}}
      local tmp = ctl_template
      local fader_offs = #ctl_template.fader
      local group_offs = #lvar.groupidx
      local fb_offs = #ctl_template.fb
      
      for a, b in pairs(lvar.midioutput_ctl) do
        local bus = b.bus
        if tonumber(bus) == d-1 then
          lvar.hardout[d-1] = b.dev
          break
        end
      end
      
      lvar.sysxbuffer[d-1] = {}
      
      local errormap
      
      local key = 'NOTESTHRU'
      if data[key] then
        tmp.notesthru[d-1] = tonumber(data[key]) or 0
      else
        tmp.notesthru[d-1] = 0
      end

      local key = 'BUTTON_ON_VAL'
      if data[key] then
        tmp.but_onval[d-1] = tonumber(data[key]) or 127
      else
        tmp.but_onval[d-1] = 127
      end

      local key = 'FADER_RESET_SYSX'
      tmp.devsysx[d-1] = {}
      
      if data[key] then
        tmp.devsysx[d-1].fader_reset_sysx = SYSX_StrToTable(data[key])
      end

      local key = 'LED_RESET_SYSX'
      if data[key] then
        tmp.devsysx[d-1].led_reset_sysx = SYSX_StrToTable(data[key])      
      end
      
      tmp.scrib[d-1] = {}
      local sscolor = tonumber(data['SSCOLORMODE'])
      
      local hs = data['HANDSHAKE']
      if hs then
        tmp.devsysx[d-1].handshake = SYSX_StrToTable(hs)
        if tmp.devsysx[d-1].handshake then
          SetUpHandshake(d-1, tmp.devsysx[d-1].handshake)
        end
      end

      tmp.devsysx[d-1].setupsysx = {}
      for i = 1, 32 do
        local hs = data['SETUP_SYSX_'..string.format('%i',i)]
        if hs then
          tmp.devsysx[d-1].setupsysx[i] = SYSX_StrToTable(hs)

        else 
          break
        end
      end
      
      local assd = data['ASSIGNMENTDISPLAY']
      if assd then
        lvar.assignmentdisplay = true
        lvar.ass_display[d-1] = {}
        lvar.ass_display[d-1].chars = {}
        local cc = {}
        local ccdp = {}
        cc[1], ccdp[1], cc[2], ccdp[2] = string.match(assd, '(%d*)%s*(%d*)%s*(%d*)%s*(%d*)')
        lvar.ass_display[d-1].cc = cc
        lvar.ass_display[d-1].ccdp = ccdp
        for chars = 0, 20 do
          local key = 'DISPLAYCHAR'..string.format('%i',chars)
          if data[key] then
            local ch, cv = string.match(data[key],'(%-*%d*%a*)%s*(%d+)')
            if ch == 'X' then ch = ' ' end
            lvar.ass_display[d-1].chars[ch] = cv
          end
        end
      end
      
      
      local tcd = data['TIMECODEDISPLAY']
      if tcd then
        lvar.timecodedisplay = true
        lvar.tc_display[d-1] = {}
        local cc = {}
        local tf, bf, cnt
        tf, bf, cnt, cc[1], cc[2], cc[3], cc[4], cc[5], cc[6], cc[7], cc[8], cc[9], cc[10] = 
              string.match(tcd,'%<(.-)%>%s*%<(.-)%>%s*(%d*)%s*(%d*)%s*(%d*)%s*(%d*)%s*(%d*)%s*(%d*)%s*(%d*)%s*(%d*)%s*(%d*)%s*(%d*)%s*(%d*)')

        lvar.tc_display[d-1].timeformat = tf
        lvar.tc_display[d-1].beatformat = bf
        lvar.tc_display[d-1].cc = cc
        lvar.tc_display[d-1].chars = {}
        lvar.tc_display[d-1].led = {}
        
        local gmem = reaper.gmem_write        
        gmem(lvar.gm_fb.pos_active+(d-1),cnt)
        for i = 1, 10 do
          gmem(lvar.gm_fb.pos_ccs+((d-1)*16)+(i-1),cc[i])
        end
        
        for chars = 0, 20 do
          local key = 'DISPLAYCHAR'..string.format('%i',chars)
          if data[key] then
            local ch, cv = string.match(data[key],'(%-*%d*%a*)%s*(%d+)')
            if ch == 'X' then ch = ' ' end
            lvar.tc_display[d-1].chars[ch] = cv
          end
        end
        
        local key = 'TIMECODE_SMPTE_LED'
        if data[key] then
          local note, on, off = string.match(data[key],'(%d+)%s*(%d+)%s*(%d+)')
          if note then
            lvar.tc_display[d-1].led[0] = {note = note, on = on, off = off}
          end
        end
        local key = 'TIMECODE_BEATS_LED'
        if data[key] then
          local note, on, off = string.match(data[key],'(%d+)%s*(%d+)%s*(%d+)')
          if note then
            lvar.tc_display[d-1].led[1] = {note = note, on = on, off = off}
          end
        end        
      else
        local gmem = reaper.gmem_write        
        gmem(lvar.gm_fb.pos_active+(d-1),0)      
      end
      
      local ssa = {}
      local sscnt = 0
      for xx = 0, 31 do
        local id = string.char(65+xx)
        local key = 'SS'..id
        if data[key] then
          --DBG(key..'  '..tostring(data[key]))
          sscnt = xx
          ssa[id] = tonumber(data[key])
          lvar.sscount = (lvar.sscount or 0)+1
        end
      end
      --DBG(d-1 ..'  '..sscnt)
      
      for gg = 1, 16 do
        local key = 'GRPSEL'..gg
        if data[key] then
          local v = tonumber(data[key])*4 + (d-1)
          --DBG('g '..v)
          --lvar.groupidx[group_offs+gg] = tonumber(data[key])
          lvar.groupidx[#lvar.groupidx+1] = v
          
          lvar.group[v] = 0
          lvar.groupctlidx[v] = {}
          lvar.groupctlidx2[v] = {}
          lvar.groupcnt = math.max(#lvar.groupidx,lvar.groupcnt or 0)
        end
      end

      for sg = 0, 15 do
        local key = 'SORTGRP'..sg
        if data[key] then
          lvar.sortgrps[sg] = data[key]
        end      
      end

      for cs = 1, 8 do
        local key = 'CHANSTRIP'..cs
        if data[key] then
          lvar.chanstrips.count = lvar.chanstrips.count + 1
          local tab = mysplit_num(data[key],' ',fader_offs)
          local idx = lvar.chanstrips.count
          lvar.chanstrips[idx] = tab
          for t = 1, #tab do
            if tab[t] then
              if t == 1 then
                lvar.chanstrips.idx2[tab[t]] = idx
              end
              lvar.chanstrips.idx[tab[t]] = {cs = idx, cidx = t}
            end
          end
        end      
      end
      
      local fc = 0
      for i = 1, 256 do
      
        local key = 'F'..string.format('%i',i)
        if data[key] then
          local sort, group, devctl, dtype, dcode, dchan, lmode, ssnum, ttype, tcode, tchan, ton, toff 
          sort, group, devctl, dtype, dcode, dchan, lmode, ssnum = string.match(data[key]..' ','(%d+)%s*(%d+)%s*%<(.-)%>%s*(%a+)%s*(%d+)%s*(%d+)%s*(%d+)%s*(%d*%-*[A-H]*)%s*')
          if sort == nil then
            sort, group, devctl, dtype, dcode, dchan, lmode, ssnum = string.match(data[key]..' ','(%d+)%s*(-)%s*%<(.-)%>%s*(%a+)%s*(%d+)%s*(%d+)%s*(%d+)%s*(%d*%-*[A-H]*)%s*')
          end
          ttype, tcode, tchan, ton, toff = string.match(data[key]..' ','%d+%s*%d+%s*%<.-%>%s*%a+%s*%d+%s*%d+%s*%d+%s*%d*%-*[A-H]*%s*(%a+)%s*(%d+)%s*(%d+)%s*(%d+)%s*(%d+)')
          if ttype == nil then
            ttype, tcode, tchan, ton, toff = string.match(data[key]..' ','%d+%s*-%s*%<.-%>%s*%a+%s*%d+%s*%d+%s*%d+%s*%d*%-*[A-H]*%s*(%a+)%s*(%d+)%s*(%d+)%s*(%d+)%s*(%d+)')
          end
          --local ttype, tcode, tchan, ton, toff = string.match(data[key]..' ','%d+%s*%d+%s*%<.-%>%s*%a+%s*%d+%s*%d+%s*%d+%s*%d*%-*[A-H]*%s*(%a+)%s*(%d+)%s*(%d+)%s*(%d+)%s*(%d+)')
          --DBG(i..'  '..tostring(group)..'  '.. tostring(dtype)..'  '..tostring(dcode)..'  '..tostring(dchan))
          --DBG(i..'  '..tostring(ttype)..'  '..tostring(tcode)..'  '..tostring(tchan)..'  '..tostring(ton)..'  '..tostring(toff))
          if not sort then
            errormap = i
            break
          end
          fc = fc + 1
          
          group = tonumber(group)
          if group then
            group = group*4 + (d-1)
          end
          sort = tonumber(sort)
          tmp.maxgrp = math.max(tmp.maxgrp or 0, group or -1)
          tmp.maxsort = math.max(tmp.maxsort or 0, sort)
--DBG(--[[data[key]..'  '..]]'UU '..fader_offs+i..'  '..ssnum..'  '..tostring(ssa[ssnum])..'    '..group..'  '..tostring(lvar.group[group]))
          if group and lvar.group[group] and ssa[ssnum] then
            --DBG(d-1 ..'  '..i..'  '..ssnum)
            lvar.groupctlidx[group][ssa[ssnum]] = fader_offs+i
            lvar.groupctlidx2[group][fader_offs+i] = tonumber(ssa[ssnum])
            
            lvar.group[group] = lvar.group[group]+1
          end
          
          tmp.fader[fader_offs+i] = {}
          tmp.fader[fader_offs+i].sort = tonumber(sort)
          tmp.fader[fader_offs+i].group = tonumber(group) or -1
          tmp.fader[fader_offs+i].devbus = d-1
          tmp.fader[fader_offs+i].devctl = devctl
          tmp.fader[fader_offs+i].dtype = tab_dtype[dtype]
          tmp.fader[fader_offs+i].dcode = tonumber(dcode)
          tmp.fader[fader_offs+i].dchan = tonumber(dchan)
          tmp.fader[fader_offs+i].lmode = tonumber(lmode)
          --DBG(i..'  '..d-1 ..'  '..ssnum)
          if tonumber(ssnum) then
            if i == tonumber(ssnum) then
              lvar.ssnumidx[#lvar.ssnumidx+1] = fader_offs+tonumber(ssnum)
            end
            tmp.fader[fader_offs+i].ssnum_abs = tonumber(ssnum)
            tmp.fader[fader_offs+i].ssnum = fader_offs+tonumber(ssnum)
            tmp.fader[fader_offs+i].sscolor = sscolor
          elseif ssnum ~= '' and ssa[ssnum] then
            --DBG(ssnum..'  '..ssa[ssnum])
            tmp.fader[fader_offs+i].ssnum_a = ssnum
            tmp.fader[fader_offs+i].ssnum_abs = tonumber(ssa[ssnum])
            tmp.fader[fader_offs+i].ssnum = fader_offs+tonumber(ssa[ssnum])
            tmp.fader[fader_offs+i].sscolor = sscolor
          end
          
          if ttype then
            tmp.fader[fader_offs+i].ttype = tab_dtype[ttype]
            tmp.fader[fader_offs+i].tcode = tonumber(tcode)
            tmp.fader[fader_offs+i].tchan = tonumber(tchan)
            tmp.fader[fader_offs+i].ton = tonumber(ton)
            tmp.fader[fader_offs+i].toff = tonumber(toff)
          end
          
          local skey = 'SS'..string.format('%i',i)
          if data[skey] then
            local sstab = SYSX_StrToTable(data[skey])
            local color
            local char = {}
            for ss = 1, #sstab do
              local cnum = tonumber(string.match(sstab[ss],'%<C(%d+)%>'))
              if sstab[ss] == '<COLOR>' then
                color = ss
              elseif cnum then
                char[ss] = tonumber(cnum)
              end
            end
            tmp.scrib[d-1][fader_offs+i] = {}
            tmp.scrib[d-1][fader_offs+i].ss_sysx = sstab
            tmp.scrib[d-1][fader_offs+i].ss_color = color
            tmp.scrib[d-1][fader_offs+i].ss_char = char
          
          --[[elseif tonumber(ssnum) then
            local skey = 'SS'..string.format('%i',tonumber(ssnum))
            if data[skey] then
              local sst, ssb = string.match(data[skey],'(%d+)%s*(%d+)')
              tmp.fader[fader_offs+i].fsstop = tonumber(sst)
              tmp.fader[fader_offs+i].fssbottom = tonumber(ssb)
            end]]
          end
        end

        local key = 'FB'..string.format('%i',i)
        if data[key] then
        
          local dtype, dcode, dchan, dA, dB = string.match(data[key],'(%a+%d*)%s-(%d+)%s*(%d+)%s*(%d*)%s*(%d*)')
          --DBG(i..' / '..tostring(dtype)..' / '..dcode..' / '..dchan..' / '..tostring(dA)..' / '..tostring(dB))
          tmp.fb[fader_offs+i] = {}
          tmp.fb[fader_offs+i].dtype = tab_dtype[dtype]
          tmp.fb[fader_offs+i].dcode = tonumber(dcode)
          tmp.fb[fader_offs+i].dchan = tonumber(dchan)
          tmp.fb[fader_offs+i].dA = tonumber(dA)
          tmp.fb[fader_offs+i].dB = tonumber(dB)          
        end

        local key = 'FLIP'..string.format('%i',i)
        if data[key] then
        
          local f1, f2 = string.match(data[key],'(%d+)%s*(%d+)')
        
          tmp.flip[#tmp.flip+1] = {f1 = tonumber(fader_offs+f1), f2 = tonumber(fader_offs+f2)}
        end
        
      end
      if not errormap then
        DBGOut('Control map fader slots loaded: '..fc)
        ctl_template = tmp
      else
        DBG('Error in skctlmap file: F'..string.format('%i',errormap))
        ctl_template = {fader = {}, fb = {}, flip = {}, devsysx = {}, scrib = {}, notesthru = {}, but_onval = {}, maxgrp = 0, maxsort = 0}
      end
    end
    --SetCtlMap(d)
    
  end
  
  function SortCtlMap()
 
    AddDummyFaders(lvar.dummyfaders)
    
    local src = ctl_template
    local tmp = {fader = {}, fb = {}, flip = {}, scrib = {}, notesthru = src.notesthru, but_onval = src.but_onval}
    local moved = {}
    local moved2 = {}
    local ctlmapidx = {}
    local ctlmapidx2 = {}
    --local faders = lvar.faders
    
    --[[local ssa = lvar.ssa
    for i = 1, 1024 do
      if src.fader[i] then
        local group = src.fader[i].group
        local ssnum = src.fader[i].ssnum_a
        if group and ssnum then
          if lvar.group[group] then
            lvar.groupctlidx[group][ssa[ssnum] ] = i
            lvar.groupctlidx2[group][i] = src.fader[i].ssnum_a
            
            lvar.group[group] = lvar.group[group]+1
          end
        end
      end
    end]]
     
    if settings.sort then
      for g = 0, src.maxsort do
        for i = 1, 1024 do
          if src.fader[i] and src.fader[i].sort == g then
            local ii = #tmp.fader + 1
            tmp.fader[ii] = src.fader[i]
            tmp.fb[ii] = src.fb[i]
            moved[i] = ii
            moved2[ii] = i
            
            local idx = src.fader[i].devbus ..'|'..src.fader[i].devctl
            ctlmapidx[idx] = ii
            local idx = (lvar.midimap[src.fader[i].devbus+1] or '-1') ..'|'..src.fader[i].devctl
            ctlmapidx2[idx] = ii
          end
        end
      end      
      for i = 1, 1024 do
        if tmp.fader[i] and tmp.fader[i].ssnum then
          --DBG('moving '..i..'  '..tmp.fader[i].ssnum..'   '..moved[tmp.fader[i].ssnum])
          tmp.fader[i].ssnum = moved[tmp.fader[i].ssnum]
        end
      end
      for d = 0, 3 do
        if src.scrib[d] then
          if not tmp.scrib[d] then
            tmp.scrib[d] = {}
          end
          for i = 1, 1024 do
            if src.scrib[d][i] then
              local idx = moved[i]
              tmp.scrib[d][idx] = src.scrib[d][i]
            end
          end
        end
      end
      for i = 1, #src.flip do
        if src.flip[i] then
          tmp.flip[i] = {}
          --DBG(i..'    '..src.flip[i].f1..' '..src.flip[i].f2..' >>> '..moved[src.flip[i].f1]..' '..moved[src.flip[i].f2])
          tmp.flip[i].f1 = moved[src.flip[i].f1]
          tmp.flip[i].f2 = moved[src.flip[i].f2]
        end
      end

      for i = 1, lvar.groupcnt do
        local grp = lvar.groupidx[i]
        local gi2 = {}
        lvar.groupctlidx2[grp] = {}
        for j = 1, 8 do
          if lvar.groupctlidx[grp] and lvar.groupctlidx[grp][j] then
            lvar.groupctlidx[grp][j] = moved[lvar.groupctlidx[grp][j]]
            lvar.groupctlidx2[grp][lvar.groupctlidx[grp][j]] = j
            --DBG(grp..'  '..moved[lvar.groupctlidx[grp][j]])
          end
        end
      end
      for i = 1, #lvar.ssnumidx do
        lvar.ssnumidx[i] = moved[lvar.ssnumidx[i]]
      end
      
      for i = 1, lvar.chanstrips.count do        
        local idx = i
        if lvar.chanstrips[idx] then          
          for j = 1, #lvar.chanstrips[idx] do          
            lvar.chanstrips[idx][j] = moved[lvar.chanstrips[idx][j]] or -1
            --DBG('cs '..i..' j '..j..'  '..moved[lvar.chanstrips[idx][j]])
          end          
        end        
      end
      local nidx = {}
      for a,b in pairs(lvar.chanstrips.idx) do      
        if moved[a] then
          nidx[moved[a]] = b
          --DBG(moved[a]..'  '..b)
        end        
      end
      lvar.chanstrips.idx = nidx
      local nidx = {}
      for a,b in pairs(lvar.chanstrips.idx2) do      
        if moved[a] then
          nidx[moved[a]] = b
        end        
      end
      lvar.chanstrips.idx2 = nidx
      
      tmp.devsysx = ctl_template.devsysx
      --tmp.scrib = ctl_template.scrib
      ctl_template = tmp
    else
      for i = 1, 1024 do
        if src.fader[i] then
          local idx = src.fader[i].devbus ..'|'..src.fader[i].devctl
          ctlmapidx[idx] = i
          local idx = (lvar.midimap[src.fader[i].devbus+1] or '-1') ..'|'..src.fader[i].devctl
          ctlmapidx2[idx] = i
        end
      end    
    end
    lvar.ctlmapidx = ctlmapidx
    lvar.ctlmapidx2 = ctlmapidx2
  
  end
  
  function SetCtlMap(donotremap)

    lvar.mirroridxs = {}
    lvar.faders = {}
    lvar.fadersidx = {}
    lvar.encoders = {}
    lvar.encodersidx = {}
    
    lvar.fcount = MIDIMap_CountFaders()
    LoadDummyData()
    if not donotremap then
      RemapFaders()
    end
    
    if LBX_CC_TRACK and ctl_template then
          
      local track = GetTrack(LBX_CC_TRACK)      
      local fxnum = 0 --math.floor((i-1)/32)
      local dataoff = 36
      local gmem = reaper.gmem_write
      
      GMCC_memset_37() --reset
      
      --reaper.TrackFX_SetParam(track,fxnum,36,1) --reset
      for i = 1, lvar.fcount do -- LIMIT TO 32 TOTAL FOR NOW --control_max do
        if ctl_template.fader[i] then
          local code
          local dtype = ctl_template.fader[i].dtype
          if dtype == 1 then
            --PITCH
            code = ctl_template.fader[i].dchan + (ctl_template.fader[i].devbus << 4)
            gmem(lvar.gm_cc.fdata_in_pitch + code, i-1)
          else
            --CC or NOTE
            code = (ctl_template.fader[i].dchan << 7) + ctl_template.fader[i].dcode + (ctl_template.fader[i].devbus << 11)
            if dtype == 0 then
              gmem(lvar.gm_cc.fdata_in_cc + code, i-1)
            elseif dtype == 2 then
              gmem(lvar.gm_cc.fdata_in_note + code, i-1)            
            end
          end
          gmem(lvar.gm_cc.fdata_fadermode + (i-1), ctl_template.fader[i].lmode)
          
          --DBG('SKCC '..i..'  '..ctl_template.fader[i].devctl..' bus '..ctl_template.fader[i].devbus..' dtype: '..dtype..' code: '..code..' lmode '..ctl_template.fader[i].lmode)
          
          --reaper.TrackFX_SetParam(track,fxnum,41,dtype)
          --reaper.TrackFX_SetParam(track,fxnum,40,code)
          --reaper.TrackFX_SetParam(track,fxnum,35,ctl_template.fader[i].lmode)  
          --reaper.TrackFX_SetParam(track,fxnum,37,i) --set fader to save
        end
      end
      
      --notes thru
      for i = 0, 3 do
        local v = ctl_template.notesthru[i] or 0
        gmem(lvar.gm_cc.fdata_notesthru+i, v)
      end
      gmem(lvar.gm_cc.fdata_sendcconrel, lvar.fdata_sendcconrel)
      
      reaper.TrackFX_SetParam(track,fxnum,2,0)
      reaper.TrackFX_SetParam(track,fxnum,3,0)
      reaper.TrackFX_SetParam(track,fxnum,4,0)
      reaper.TrackFX_SetParam(track,fxnum,5,0)
      if lvar.midimap[1] then
        for n = 1, string.len(lvar.midimap[1]) do
          reaper.TrackFX_SetParam(track,fxnum,2,string.byte(string.sub(lvar.midimap[1],n,n)))
        end
      end
      if lvar.midimap[2] then
        for n = 1, string.len(lvar.midimap[2]) do
          reaper.TrackFX_SetParam(track,fxnum,3,string.byte(string.sub(lvar.midimap[2],n,n)))
        end
      end
      if lvar.midimap[3] then
        for n = 1, string.len(lvar.midimap[3]) do
          reaper.TrackFX_SetParam(track,fxnum,4,string.byte(string.sub(lvar.midimap[3],n,n)))
        end
      end
      if lvar.midimap[4] then
        for n = 1, string.len(lvar.midimap[4]) do
          reaper.TrackFX_SetParam(track,fxnum,5,string.byte(string.sub(lvar.midimap[4],n,n)))
        end
      end
    end
    
    if LBX_CTL_TRACK and ctl_template then
    
      local track = GetTrack(LBX_CTL_TRACK)
      local dataoff = 36
      local fxnum = 0
      local gmem = reaper.gmem_write
      
      reaper.TrackFX_SetParam(track,0,0,lvar.fcount)
      
      GMFB_memset_37() --reset
      
      --reaper.SetExtState('SK2DATA_SLOTS', '')
      
      --for f = 0, reaper.TrackFX_GetCount(track) do
      --  reaper.TrackFX_SetParam(track,f,36,1) --reset
      --end
      if lvar.stripperlink then
        reaper.SetExtState('SK2DATA_SLOTS', 'COUNT', lvar.fcount, false)
      end
      
      for i = 0, 3 do
        local v = ctl_template.but_onval[i] or 127
        gmem(lvar.gm_fb.but_onval+i, v)
      end
      
      for i = 1, lvar.fcount do 

        --local save = false
        --local fxnum = math.floor((i-1)/32)
        if lvar.stripperlink then
          reaper.DeleteExtState('SK2DATA_SLOTS', string.format('%i',i-1)..'_NAME', true)
          reaper.DeleteExtState('SK2DATA_SLOTS', string.format('%i',i-1)..'_LMODE', true)
          reaper.DeleteExtState('SK2DATA_SLOTS', string.format('%i',i-1)..'_MAPTYPE', true)
        end
        
        if ctl_template.fader[i] or ctl_template.fb[i] then  
          
          local fb
          if ctl_template.fb[i] then
            fb = ctl_template.fb[i]
          else
            fb = ctl_template.fader[i]
          end
          
          local code, code2
          local dtype = fb.dtype
          --DBG(i..'  '..dtype)
          if dtype then
            if dtype == 1 then
              --PITCH
              code = fb.dchan + (ctl_template.fader[i].devbus << 4)
            elseif dtype == 0 or dtype == 2 then
              --CC or NOTE
              code = (fb.dchan << 7) + fb.dcode + (ctl_template.fader[i].devbus << 11)
            elseif dtype == 100 then
              --SPEC1 dA == CC_A dB == CC_B
              code = (fb.dchan << 14) + (fb.dA << 7) + fb.dB
            elseif dtype == 102 then
              --SPEC2
              code = (fb.dchan << 7) + fb.dcode

            elseif dtype == 101 then
              --XCTLLED dA == VAL OFFS dB == RANGE
              code = (fb.dchan << 14) + (fb.dA << 7) + fb.dB
            end
            if code then
              
              gmem(lvar.gm_fb.fdata + (i-1), code)
              gmem(lvar.gm_fb.fdata_type + (i-1), dtype)
              gmem(lvar.gm_fb.fbuttype2 + (i-1), ctl_template.fader[i].lmode)
              gmem(lvar.gm_fb.fdata_bus + (i-1), ctl_template.fader[i].devbus)
           
              if dtype == 0 then --cc
                --DBG('cc'..i..'  '..tostring(code)..'  '..tostring(code2))
                code2 = code | (ctl_template.fader[i].devbus << 11)
                gmem(lvar.gm_fb.directin_cc + code2, i-1)
              elseif dtype == 1 then --pitch
                code2 = code | (ctl_template.fader[i].devbus << 4)
                gmem(lvar.gm_fb.directin_pitch + code2, i-1)
              elseif dtype == 2 then --note
                code2 = code | (ctl_template.fader[i].devbus << 11)
                gmem(lvar.gm_fb.directin_note + code2, i-1)
              end  
            else
              gmem(lvar.gm_fb.fdata_type + (i-1), -1)
            end
            
            --DBG('SKCTL '..i..'  '..ctl_template.fader[i].devctl..' bus '..ctl_template.fader[i].devbus..' dtype: '..dtype..' code: '..code..' code2: '..code2..' lmode '..ctl_template.fader[i].lmode)
            
            --reaper.TrackFX_SetParam(track,fxnum,42,code)
            --reaper.TrackFX_SetParam(track,fxnum,41,dtype)
            --reaper.TrackFX_SetParam(track,fxnum,53,ctl_template.fader[i].lmode)  
            --reaper.TrackFX_SetParam(track,fxnum,52,ctl_template.fader[i].devbus)  
            --DBG(dtype..'  '..code)
            --save = true
          end
        end
        
        if ctl_template.fader[i] then  
          local ttype = ctl_template.fader[i].ttype
          if ttype then
            if ttype == 0 then
              --CC
              code = (ctl_template.fader[i].tchan << 7) + ctl_template.fader[i].tcode + (ctl_template.fader[i].devbus << 11)
              gmem(lvar.gm_fb.ftouch_in_cc + code, i-1)
              
              --reaper.TrackFX_SetParam(track,fxnum,44,code)            
            elseif ttype == 2 then
              --NOTE
              code = (ctl_template.fader[i].tchan << 7) + ctl_template.fader[i].tcode + (ctl_template.fader[i].devbus << 11)
              gmem(lvar.gm_fb.ftouch_in_note + code, i-1)
              --DBG(i-1 ..'  '..code..'  '..ctl_template.fader[i].ton..'  '..ctl_template.fader[i].toff)
              --reaper.TrackFX_SetParam(track,fxnum,43,code)
            end
            
            gmem(lvar.gm_fb.ftouch_on + (i-1), ctl_template.fader[i].ton)
            gmem(lvar.gm_fb.ftouch_off + (i-1), ctl_template.fader[i].toff)

            --reaper.TrackFX_SetParam(track,fxnum,45,ctl_template.fader[i].ton)            
            --reaper.TrackFX_SetParam(track,fxnum,46,ctl_template.fader[i].toff)            
            --save = true
          else
          
            --reaper.TrackFX_SetParam(track,fxnum,43,-1)            
            --reaper.TrackFX_SetParam(track,fxnum,44,-1)            
            --reaper.TrackFX_SetParam(track,fxnum,45,-1)            
            --reaper.TrackFX_SetParam(track,fxnum,46,-1)                      
          end 
          
          --SET UP EXT DATA
          if lvar.stripperlink then
            --DBG('SK2 '..string.format('i',i)..'_LMODE'..'  '..ctl_template.fader[i].lmode)
            reaper.SetExtState('SK2DATA_SLOTS', string.format('%i',i-1)..'_LMODE', ctl_template.fader[i].lmode, false)
            --DBG('GET '..reaper.GetExtState('SK2DATA_SLOTS', string.format('i',i)..'_LMODE'))
            reaper.SetExtState('SK2DATA_SLOTS', string.format('%i',i-1)..'_NAME', ctl_template.fader[i].devctl, false)
            --map type
            local devbus = ctl_template.fader[i].devbus+1
            if devbus and lvar.midimap[devbus] then
              local map = lvar.midimap[devbus]
              reaper.SetExtState('SK2DATA_SLOTS', string.format('%i',i-1)..'_MAPTYPE', map, false)
            end
          end
          
          if ctl_template.fader[i].lmode == 0 then
            if string.match(ctl_template.fader[i].devctl, 'Fader ') then
              if string.match(ctl_template.fader[i].devctl, 'Fader %d+') then
                lvar.faders[#lvar.faders+1] = i
                lvar.fadersidx[i] = i
              end
              --Set up faders for CTL jsfx
              gmem(lvar.gm_fb.isfader + (i-1), 1)
              
            elseif string.match(ctl_template.fader[i].devctl, 'Encoder ') then
              if string.match(ctl_template.fader[i].devctl, 'Encoder %d+') then
                lvar.encoders[#lvar.encoders+1] = i
                lvar.encodersidx[i] = i
              end
            end
          elseif ctl_template.fader[i].lmode == 2 or ctl_template.fader[i].lmode == 3 or ctl_template.fader[i].lmode == 6 or ctl_template.fader[i].lmode == 7 then
            if string.match(ctl_template.fader[i].devctl, 'Encoder ') then
              if string.match(ctl_template.fader[i].devctl, 'Encoder %d+') then
                lvar.encoders[#lvar.encoders+1] = i
                lvar.encodersidx[i] = i
              end
            end
          end
        end
        
        --if save == true then
        --  reaper.TrackFX_SetParam(track,fxnum,37,((i-1)%32)+1) --set fader to save          
        --end
        
      end
      
      if lvar.stripperlink then
        reaper.SetExtState('SK2DATA_SLOTS', 'DIRTY', 1, false)
      end
      
      reaper.TrackFX_SetParam(track,fxnum,2,0)
      reaper.TrackFX_SetParam(track,fxnum,3,0)
      reaper.TrackFX_SetParam(track,fxnum,4,0)
      reaper.TrackFX_SetParam(track,fxnum,5,0)
      if lvar.midimap[1] then
        tab_filters[10] = lvar.midimap[1]
        for n = 1, string.len(lvar.midimap[1]) do
          reaper.TrackFX_SetParam(track,fxnum,2,string.byte(string.sub(lvar.midimap[1],n,n)))
        end
      end
      if lvar.midimap[2] then
        tab_filters[11] = lvar.midimap[2]
        for n = 1, string.len(lvar.midimap[2]) do
          reaper.TrackFX_SetParam(track,fxnum,3,string.byte(string.sub(lvar.midimap[2],n,n)))
        end
      end
      if lvar.midimap[3] then
        tab_filters[12] = lvar.midimap[3]
        for n = 1, string.len(lvar.midimap[3]) do
          reaper.TrackFX_SetParam(track,fxnum,4,string.byte(string.sub(lvar.midimap[3],n,n)))
        end
      end
      if lvar.midimap[4] then
        tab_filters[13] = lvar.midimap[4]
        for n = 1, string.len(lvar.midimap[4]) do
          reaper.TrackFX_SetParam(track,fxnum,5,string.byte(string.sub(lvar.midimap[4],n,n)))
        end
      end
      
    end
    
    --Set gswitches 
    if lvar.fbcconseek == true then
      reaper.gmem_write(lvar.gm_fb.gswitch50,1)
    else
      reaper.gmem_write(lvar.gm_fb.gswitch50,0)
    end
    reaper.gmem_write(lvar.gm_fb.gswitch47,1)
    
    if lvar.sortgrps then
      for i = 0, #lvar.sortgrps do
        --if i == 0 then
        --  tab_filters[13+i] = '|'..lvar.sortgrps[i]          
        --else
          tab_filters[14+i] = lvar.sortgrps[i]
        --end
      end
    end
    
    if lvar.virtualss_active then
      reaper.SetExtState('LBXVSS','[SSCNT]',#lvar.ssnumidx,false)
      for i = 1, #lvar.ssnumidx do
        reaper.SetExtState('LBXVSS','[SS_' .. i .. ']',lvar.ssnumidx[i],false)
      end
    end
    --SendSetUpSYSX()
    
  end

  function SendSetUpSYSX()
    local tmp = ctl_template
    for d =  1, 4 do
      if tmp.devsysx[d-1] then
        if tmp.devsysx[d-1].setupsysx and #tmp.devsysx[d-1].setupsysx > 0 then
          SendSYSX(d-1, tmp.devsysx[d-1].setupsysx)
        end
      end
    end
  end
  
  function SetFineTune()
  
    lvar.finetune_fader = {}
    for i = 1, lvar.fcount do
      if string.match(ctl_template.fader[i].devctl,'.*Fader.*') then
        if lvar.finetune_active then
          lvar.finetune_fader[i] = 1
        else
          lvar.finetune_fader[i] = 0
        end
      end
    end    
  
  end
  
  function SetCCs()

    --lvar.sk2data_setdata = math.huge

    if LBX_CC_TRACK then
      local track = GetTrack(LBX_CC_TRACK)      
      local fxnum = 0 --math.floor((i-1)/32)
      local dataoff = 38
      local gmem = reaper.gmem_write
      
      GMCC_memset_39() --reset
      
      GMCC_ButState_Reset() --hmmm reset button states

      --reaper.TrackFX_SetParam(track,fxnum,38,1) --reset
      for i = 1, lvar.fcount do
        local tmp
        tmp = GetTemplate(i)
        local tmppos = tmp.pos[i]
        
        if tmppos and tmppos.cc == true then
          --set CC
          local cccode = (tmppos.ccchan << 7) + tmppos.ccnum
          gmem(lvar.gm_cc.fdata_fader + (i-1), cccode)
          
          if tmppos.cc14bit == 1 then
            gmem(lvar.gm_cc.fdata_14bit + (i-1), 1)        
          end
          if tmppos.polarity == 1 then
            gmem(lvar.gm_cc.fdata_polarity + (i-1), 1)        
          end
          if tmppos.buttype == 6 then
            gmem(lvar.gm_cc.fdata_bmode + (i-1), 1)        
          end
          if lvar.finetune_fader[i] == 1 then
            gmem(lvar.gm_cc.fdata_fine + (i-1), 1)
          end

          --reaper.TrackFX_SetParam(track,fxnum,42,cccode)
          --reaper.TrackFX_SetParam(track,fxnum,39,i) --set fader to save
        end
      end
      
      
    end

    lvar.idx_cc = {}
    
    --reaper.SetExtState('SK2DATA_ASSIGN', nil)
    
    if LBX_CTL_TRACK then
    
      local track = GetTrack(LBX_CTL_TRACK)
      local dataoff = 38
      
      local gmem = reaper.gmem_write
            
      GMFB_memset_39() --reset 
      GMFB_LEDOn_Reset()
      
      --for f = 0, reaper.TrackFX_GetCount(track) do
      --  reaper.TrackFX_SetParam(track,f,38,1) --reset
      --end
      
      local cc_cnt = 1
      --[[if lvar.stripperlink then
        reaper.SetExtState('SK2DATA_ASSIGN', 'DIRTY', 1, true)
      end]]
      
      for i = 1, lvar.fcount do -- LIMIT TO 32 TOTAL FOR NOW --control_max do
        
        --[[if lvar.stripperlink then
          reaper.DeleteExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_ACTIVE', true)
          reaper.DeleteExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_SSCOLOR', true)
          reaper.DeleteExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_NAME', true)
          reaper.DeleteExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_DVAL', true)
          reaper.DeleteExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_BTYPE', true)
          reaper.DeleteExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', true)
        end]]
        
        local tmp
        tmp, gflag = GetTemplate(i)
        local tmppos = tmp.pos[i]
        local faderpos = ctl_template.fader[i]
        
        if tmppos then
          if faderpos.lmode == 4 then
            if tmppos.ledon then
              gmem(lvar.gm_fb.faderled_on + (i-1), 1)
            end
            if tmppos.buttype == 6 then
              gmem(lvar.gm_cc.fdata_bmode + (i-1), 1)        
            end
            
            local dev = ctl_template.fader[i].devbus
            gmem(lvar.gm_fb.but_onval_override + (i-1), tmppos.but_onval_override or ctl_template.but_onval[dev] or 127)
            --DBG(i..'  '..(tmppos.but_onval_override or ctl_template.but_onval[dev] or 127))
          end
          
          if faderpos.lmode == 0 and lvar.finetune_fader[i] == 1 then
            if tmppos.ptype == ptype.host or tmppos.ptype == ptype.track then
              gmem(lvar.gm_cc.fdata_fine + (i-1), 1)
            end
          end
          
          local fxnum = math.floor((i-1)/32)
          if faderpos and 
                (faderpos.lmode == 3 or faderpos.lmode == 2 or faderpos.lmode == 6 or faderpos.lmode == 7) then
            gmem(lvar.gm_fb.fencoderres + (i-1), (tmppos.enc_res or 128))
            
            --reaper.TrackFX_SetParam(track,fxnum,59,tmppos.enc_res or 127)
            --reaper.TrackFX_SetParam(track,fxnum,60,((i-1)%32)+1) --set fader to save          
          end
          if (tmppos.ptype == ptype.cc or tmppos.cc == true) and tmppos.ccnum ~= -1 then
            if tmppos.exauto ~= 1 then
              lvar.idx_cc[cc_cnt] = i
              cc_cnt = cc_cnt + 1
            end
            
            --set CC
            --local fxnum = math.floor((i-1)/32)
            local cccode = (tmppos.ccchan << 7) + tmppos.ccnum
            if faderpos.lmode ~= 4 then --do not feedback to buttons
              gmem(lvar.gm_fb.fdata_in + cccode, (i-1))
            end
            gmem(lvar.gm_fb.fdata2 + (i-1), cccode)
  
            if tmppos.cc14bit == 1 then
              local cccode = (tmppos.ccchan << 7) + tmppos.ccnum+32
              if faderpos.lmode ~= 4 then --do not feedback to buttons
                gmem(lvar.gm_fb.fdata_in + cccode, (i-1))
              end
              --gmem(lvar.gm_fb.fdata2 + (i-1), cccode)          
            end
  
            local bi = tmppos.buttype
            local bs = tmppos.butstates or 1
            if not bi then
              bi = 0
            end
            if bi then
              gmem(lvar.gm_fb.fbuttype + (i-1), bi)
              gmem(lvar.gm_fb.fbutstates + (i-1), bs)
  
              if faderpos.lmode == 4 then
                for b = 1, (tmppos.butstates or 0) do
                  --DBG(i..'  '..tmppos.butstates_array[b])
                  gmem(lvar.gm_fb.fbutstates_array + i*32 + (b-1), tmppos.butstates_array[b] or -1)
                end
              end
              
            end
                      
            --reaper.TrackFX_SetParam(track,fxnum,40,cccode) --set code
            --reaper.TrackFX_SetParam(track,fxnum,39,((i-1)%32)+1) --set fader to save
          
          elseif tmppos.ptype == ptype.track then
            --set button info
            --local fxnum = math.floor((i-1)/32)
            local bi = track_info[tab_trparams_code[tmppos.trparam]]
            if bi then
  
              gmem(lvar.gm_fb.fbuttype + (i-1), bi.btype)
              gmem(lvar.gm_fb.fbutstates + (i-1), bi.states)
  
              --reaper.TrackFX_SetParam(track,fxnum,53,bi.btype) --set type
              --reaper.TrackFX_SetParam(track,fxnum,54,bi.states) --set states
              --reaper.TrackFX_SetParam(track,fxnum,55,((i-1)%32)+1) --set fader to save
            end
  
          elseif tmppos.ptype == ptype.action then
            --set button info
            --local fxnum = math.floor((i-1)/32)
            local bi = tmppos.buttype
            if not bi then
              bi = 0
            end
            if bi then
              gmem(lvar.gm_fb.fbuttype + (i-1), bi)
  
              --reaper.TrackFX_SetParam(track,fxnum,53,bi) --set type
              --reaper.TrackFX_SetParam(track,fxnum,54,bi.states) --set states
              --reaper.TrackFX_SetParam(track,fxnum,55,((i-1)%32)+1) --set fader to save
            end
          end
        end
        
        --SET UP EXT DATA
        --[[if lvar.stripperlink then
          
          if tmppos then
          
            --DBG(tmppos.name or tmppos.scribov or tmppos.pname or 'blank')
            reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_SSCOLOR', tmppos.sscolor or '', false)
            
            local pname
            if tmppos.ptype == ptype.cc and tmppos.ccnum ~= -1 then
              str2 = 'Chan '..string.format('%i',tmppos.ccchan+1)
              str = 'CC '..string.format('%i',tmppos.ccnum)
              pname = str..' '..str2
            end
            
            reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_NAME', tmppos.name or pname or tmppos.scribov or tmppos.pname or '', false)
            reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_BTYPE', tmppos.buttype or 4, false)
            reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_ACTIVE', 1, false)
            --DBG(tmppos.name or tmppos.pname or tmppos.scribov or '')
          
          end
        end]]
        
      end
      
      if lvar.midieditor_cclanes == true then
        local track, trnm = GetCCLanesTrack()
        if trnm and lvar.lanes_ov_tab[trnm] and lvar.lanes_ov_enable and trnm ~= lvar.otrnm then
          lvar.midieditor_cclanes_offset = -1
        end
        lvar.otrnm = trnm
        lvar.update_midieditor_cclanes = true
      end
      
    end
    
    --if lvar.mode ~= 3 or reaper.time_precise() > (lvar.sk2data_setdata_delay or 0) then
    
    if lvar.stripperlink then
      lvar.sk2setdata_spos = 1
      SK2Data_SetData(1)
    end
    
    --[[else
      lvar.sk2data_setdata = reaper.time_precise() + lvar.sk2data_setdata_delaytime
      lvar.sk2data_setdata_delay = lvar.sk2data_setdata
    end]]
  end
  
  function SK2Data_SetData(spos)
  
    --Deal with case where tracks are rapidly scrolled through
    if lvar.mode == 3 and reaper.time_precise() < (lvar.sk2data_setdata_delay or 0) then
      lvar.sk2data_setdata = reaper.time_precise() + lvar.sk2data_setdata_delaytime
      lvar.sk2data_setdata_delay = lvar.sk2data_setdata
      return
    end

    if spos == 1 then
      reaper.SetExtState('SK2DATA_ASSIGN', 'UPDATING', 1, true)
    end
    
    for i = spos, math.min(spos+lvar.sk2setdata_num, lvar.fcount) do -- LIMIT TO 32 TOTAL FOR NOW --control_max do
      
      --if lvar.stripperlink then
        --[[reaper.DeleteExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_ACTIVE', true)
        reaper.DeleteExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_SSCOLOR', true)
        reaper.DeleteExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_NAME', true)
        reaper.DeleteExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_DVAL', true)
        reaper.DeleteExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_BTYPE', true)
        reaper.DeleteExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', true)]]
        
        reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_ACTIVE', '', false)
        reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_SSCOLOR', '', false)
        reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_NAME', '', false)
        reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_DVAL', '', false)
        reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_BTYPE', '', false)
        reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', '', false)
        
      --end
      
      local tmp
      tmp, gflag = GetTemplate(i)
      local tmppos = tmp.pos[i]
      local faderpos = ctl_template.fader[i]
      
      if tmppos then

        --SET UP EXT DATA
        --if lvar.stripperlink then
          
          if tmppos then
          
            --DBG(tmppos.name or tmppos.scribov or tmppos.pname or 'blank')
            reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_SSCOLOR', tmppos.sscolor or '', false)
            
            local pname
            if tmppos.ptype == ptype.cc and tmppos.ccnum ~= -1 then
              str2 = 'Chan '..string.format('%i',tmppos.ccchan+1)
              str = 'CC '..string.format('%i',tmppos.ccnum)
              pname = str..' '..str2
            end
            
            reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_NAME', tmppos.name or pname or tmppos.scribov or tmppos.pname or '', false)
            reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_BTYPE', tmppos.buttype or 4, false)
            reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_ACTIVE', 1, false)
            --DBG(tmppos.name or tmppos.pname or tmppos.scribov or '')
          
          end
        --end
        
      end
    end
    --DBG(spos)
    lvar.sk2setdata_spos = spos+lvar.sk2setdata_num + 1
    if lvar.sk2setdata_spos >= lvar.fcount then
      --DBG('T')
      lvar.sk2setdata_spos = nil
      reaper.SetExtState('SK2DATA_ASSIGN', 'UPDATING', 0, true)
      reaper.SetExtState('SK2DATA_ASSIGN', 'DIRTY', 1, true)
      lvar.sk2data_setdata_delay = reaper.time_precise() + lvar.sk2data_setdata_delaytime
      lvar.sk2data_setdata = nil
      
      updatetravellingtracknames()
    end
    
    --DBG('TTTTTTTTTTTTT')
    
  end
  
  function tobool(b)
  
    local ret = false
    if tostring(b) == 'true' then
      ret = true
    end
    return ret
    
  end
  
  function nz(val, d)
    if val == nil then return d else return val end
  end
  function zn(val, d)
    if val == '' or val == nil then return d else return val end
  end

  function SaveUserFilters()
    local ffn = paths.resource_path..'userfilters.txt'
    file=io.open(ffn,"w")
    for i = 1, 8 do
      if lvar.userfilter[i] then
        file:write('[USER'..string.format('%i',i)..']'..lvar.userfilter[i].name..'\n')
        local kk = '[USER'..string.format('%i',i)..'_'
        for a = 1, #lvar.userfilter[i].filter do
          file:write(kk..string.format('%i',a)..']'..lvar.userfilter[i].filter[a]..'\n')
        end
      end    
    end
    file:close()  
  end

  function LoadUserFilters()

    local ffn = paths.resource_path..'userfilters.txt'
    if reaper.file_exists(ffn) then  
      local file
      
      data = {}
      for line in io.lines(ffn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          val = string.gsub(val, '[\r]', '') --Remove \r for Mac use
          data[idx] = val
        end
      end
      
      for i = 1, 8 do
        local key = 'USER'..string.format('%i',i)
        if data[key] then
          lvar.userfilter[i] = {}
          lvar.userfilter[i].name = data[key]
          lvar.userfilter[i].filter = {}
          
          local a = 1
          local key2 = key..'_'..string.format('%i',a)
          while data[key2] do
            lvar.userfilter[i].filter[a] = tonumber(data[key2])
            a = a+1
            key2 = key..'_'..string.format('%i',a)
          end
        end
      end
    end

  end
      
  function SaveDefCCs()
    local gmem = reaper.gmem_read
    local ffn = paths.resource_path..'defcc.txt'
    file=io.open(ffn,"w")
    for i = 0, 127 do
      file:write('[CC'..string.format('%i',i)..']'..gmem(lvar.gm_ccstamp.defcc_val+i)..'\n')    
    end  
    for i = 0, 127 do
      file:write('[CC_ENABLED'..string.format('%i',i)..']'..gmem(lvar.gm_ccstamp.cc_enabled+i)..'\n')    
    end  
    file:close()
  end

  function LoadDefCCs()

    GMCCSTAMP_ResetEnabled()

    local gmem = reaper.gmem_write
    local ffn = paths.resource_path..'defcc.txt'
  
    if ffn and reaper.file_exists(ffn) then  
      local file
      
      data = {}
      for line in io.lines(ffn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          val = string.gsub(val, '[\r]', '') --Remove \r for Mac use
          data[idx] = val
        end
      end
      
      for i = 0, 127 do
        local key = 'CC'..string.format('%i',i)
        if tonumber(data[key]) then
          gmem(lvar.gm_ccstamp.defcc_val+i,tonumber(data[key]))
        end
        local key = 'CC_ENABLED'..string.format('%i',i)
        if tonumber(data[key]) then
          gmem(lvar.gm_ccstamp.cc_enabled+i,tonumber(data[key]))
        end
      end
    end
    
    --Load disabled CC's
  
  end
  
  function SaveCCMapAsDef()
    if FFX then
      local fn = paths.tracktemplate_path..LBX_DEFTRACKCCTMP
      SaveFXParamTemplate(FFX, template, fn, nil, false)
    end
  end
  
  
  function ctlScale(m, v)
  
    local mm = lvar.scalemode_table[m]
    return v^mm
  
  end
  
  function ctlScaleInv(m, v)
  
    local mm = 1/lvar.scalemode_table[m]
    return (v or 0)^mm
  
  end
  
  function normalizetrackparam(v, code)
    local min, max, scale = track_info[code].min, track_info[code].max, track_info[code].scaling
    if min and max then
      if scale then
        return ctlScaleInv(scale, (v - min)/(max - min)), v
      else
        return (v - min)/(max - min), v
      end
    else
      return v, v
    end
  end

  function denormalizetrackparam(v, code)
    local min, max, scale = track_info[code].min, track_info[code].max, track_info[code].scaling
    if min and max then
      if scale then
        return ctlScale(scale, v) * (max-min) + min
      else
        return v * (max-min) + min
      end
    else
      return v
    end
  end

  function normalizetracksend(v, code)
    local min, max, scale = tracksend_info[code].min, tracksend_info[code].max, tracksend_info[code].scaling
    if min and max then
      if scale then
        return ctlScaleInv(scale, (v - min)/(max - min))
      else
        return (v - min)/(max - min)
      end
    else
      return v
    end
  end

  function denormalizetracksend(v, code)
    local min, max, scale = tracksend_info[code].min, tracksend_info[code].max, tracksend_info[code].scaling
    if min and max then
      if scale then
        return ctlScale(scale, v) * (max-min) + min
      else
        return v * (max-min) + min
      end
    else
      return v
    end
  end
  
  function ResetFaderBox()
  
    local manual_dev = {}
    local man
    for i = 0, 3 do
      if ctl_template.devsysx and ctl_template.devsysx[i] and ctl_template.devsysx[i].fader_reset_sysx then
        SendSYSX(i, {ctl_template.devsysx[i].fader_reset_sysx})
      elseif lvar.midimap[i+1] then
        manual_dev[i] = true
        man = true
      end
    end
  
    if man then
      local ctltrack = GetTrack(LBX_CTL_TRACK)
    if ctltrack then          
      local blast
      local gmem = reaper.gmem_write
      for i = 1, lvar.fcount do
      if ctl_template.fader[i] and manual_dev[ctl_template.fader[i].devbus] then
        gmem(lvar.gm_fb.fader_val+(i-1), 0)
        gmem(lvar.gm_fb.fader_val2+(i-1), 0)
      
        gmem(lvar.gm_fb.fset+(i-1),0)  
        --Trigger send
        blast = true          
      end
    end           
        if blast == true then
          --local fbfxn = math.floor((i-1)/32)
          --reaper.TrackFX_SetParam(ctltrack, 0, 58, 1)
          local gmem = reaper.gmem_write
          gmem(lvar.gm_fb.gswitch59,1)
          blast = nil
        end
      end    
    end
    
  end
  
  function ResetLEDs()

    local manual_dev = {}
    local man
    for i = 0, 3 do
      if ctl_template.devsysx and ctl_template.devsysx[i] and ctl_template.devsysx[i].led_reset_sysx then
        SendSYSX(i, {ctl_template.devsysx[i].led_reset_sysx})
      elseif lvar.midimap[i+1] then
        manual_dev[i] = true
        man = true
      end
    end
    
    if man == true then
      local ctltrack = GetTrack(LBX_CTL_TRACK)
      if ctltrack then
        reaper.TrackFX_SetParam(ctltrack, 0, 62, 1) --trigger reset of stored tc digits
        
        local blast
        local gmem = reaper.gmem_write
        for i = 1, lvar.fcount do
          --local fbfxn = math.floor((i-1)/32)
          --local ii = ((i-1) % 32)+1
          local tmp
          tmp, gflag = GetTemplate(i)
          --[[if permatemplate.pos[i] then
            tmp = permatemplate        
          elseif globtemplate.pos[i] and lvar.showglobalmap then
            tmp = globtemplate
          else
            tmp = template
          end]]
          
          if ctl_template.fader[i] and manual_dev[ctl_template.fader[i].devbus] then
            if ctl_template.fader[i].lmode == 4 and not permatemplate.pos[i] and not tmp.pos[i] then
              gmem(lvar.gm_fb.fset+(i-1),0)          
              --Trigger send
              blast = true          
            elseif ctl_template.fader[i].lmode == 4 and not permatemplate.pos[i] and tmp.pos[i] then
              if tmp.pos[i].ledon == 1 then
                SendMIDIFB(i, 127)
              end
              --gmem(lvar.gm_fb.fset+(i-1),(tmp.pos[i].ledon or 0)*127)          
              --Trigger send
              blast = true        
            end
          end
        end
        if blast == true then
          --local fbfxn = 0
          --reaper.TrackFX_SetParam(ctltrack, 0, 58, 1)
          gmem(lvar.gm_fb.gswitch59,1)
          blast = nil
        end 
        
      end
    end
  end

  function SPEC1_CC_A_Conv(v) 
    local res
    v = math.floor(v)
    if v == 7 then
      res = 64
    elseif v < 7 then
      res = 2^math.floor(v)
    else
      res = 0
    end
    return res;  
  end
  
  function SPEC1_CC_B_Conv(v) 
  local res
    v = math.floor(v)
    if v < 8 then
      res = 0
    else
      res = 2^math.floor(v-8)
    end
    return res
  end

  function SendMIDIFB_Reset(devbus, dtype, dchan, dcode, dA, dB)
    local msg1, msg2
    if dtype == 100 then
      msg1 = 176 + dchan
      local vA = 0
      local vB = 0
      local dev = lvar.hardout[devbus]
      if dev and msg1 then
        reaper.StuffMIDIMessage(16+dev, msg1, dA, vA)
        reaper.StuffMIDIMessage(16+dev, msg1, dB, vB)
      end
    else
      if dtype == 0 then
        msg1 = 176 + dchan
        msg2 = dcode
      elseif dtype == 1 then
        msg1 = 224 + dchan
        msg2 = msg2 or 0
      elseif dtype == 2 then
        msg1 = 144 + dchan
        msg2 = dcode
      end
      local dev = lvar.hardout[devbus]
      if dev and msg1 then
        reaper.StuffMIDIMessage(16+dev, msg1, msg2, 0)
      end
    end
  end
  
  function SendMIDIFB(i, msg3, msg2)

    local devbus = devbus or ctl_template.fader[i].devbus
    local dtype, dchan, dcode, dA, dB
    if ctl_template.fb[i] then
      dtype = ctl_template.fb[i].dtype 
      dchan = ctl_template.fb[i].dchan 
      dcode = ctl_template.fb[i].dcode 
      dA = ctl_template.fb[i].dA
      dB = ctl_template.fb[i].dB
    else
      dtype = ctl_template.fader[i].dtype
      dchan = ctl_template.fader[i].dchan
      dcode = ctl_template.fader[i].dcode
    end
    local msg1
    if dtype == 100 then
      msg1 = 176 + dchan
      local vA = SPEC1_CC_A_Conv(((msg3/127)*13)+0.5)
      local vB = SPEC1_CC_B_Conv(((msg3/127)*13)+0.5)
      local dev = lvar.hardout[devbus]
      if dev and msg1 then
        reaper.StuffMIDIMessage(16+dev, msg1, dA, vA)
        reaper.StuffMIDIMessage(16+dev, msg1, dB, vB)
      end
    elseif dtype == 102 then
      msg1 = 176 + dchan
      local vA = math.floor(((msg3/127)*12)+1)
      local dev = lvar.hardout[devbus]
      if dev and msg1 then
        reaper.StuffMIDIMessage(16+dev, msg1, dcode, vA)
      end
    else
      if dtype == 0 then
        msg1 = 176 + dchan
        msg2 = dcode
      elseif dtype == 1 then
        msg1 = 224 + dchan
        msg2 = msg2 or 0
      elseif dtype == 2 then
        msg1 = 144 + dchan
        msg2 = dcode
      end
      local dev = lvar.hardout[devbus]
      if dev and msg1 then
        reaper.StuffMIDIMessage(16+dev, msg1, msg2, math.min(tonumber(msg3),127))
      end
    end
    
  end

  function SendMIDIMsg_ToTrack(msg1, msg2, msg3)

    tr = GetTrack(LBX_CC_TRACK)
    if tr then
      local gmem = reaper.gmem_write
      --scope LBX_SK2_SharedMem
      --local mansend_msg1 = 1999100
      --local mansend_msg2 = 1999101
      --local mansend_msg3 = 1999102
      --gmem(mansend_msg1, msg1)
      --gmem(mansend_msg2, msg2)
      --gmem(mansend_msg3, msg3)
      reaper.TrackFX_SetParam(tr,0,19,msg1)
      reaper.TrackFX_SetParam(tr,0,20,msg2)
      reaper.TrackFX_SetParam(tr,0,21,msg3)
      
      reaper.TrackFX_SetParam(tr,0,18,1)
    end
    
  end
    
  function SendMIDIDirect(i, chan, msg2, msg3)
    local gmem = reaper.gmem_read
    local ftype = gmem(lvar.gm_fb.fdata_type + (i-1))
    if ftype == 0 then
      --cc
      local devbus = ctl_template.fader[i].devbus
      SendCCDirect(devbus, chan, msg2, msg3)      
    elseif ftype == 2 then
      --note
      local devbus = ctl_template.fader[i].devbus
      SendNoteDirect(devbus, chan, msg2, msg3)
    end
  end
  
  function SendCCDirect(devbus, chan, ccnum, val)
    local dev = lvar.hardout[devbus]
    if dev then
      reaper.StuffMIDIMessage(16+dev, 176+chan, ccnum, math.min(tonumber(val),127))
    end
  end

  function SendNoteDirect(devbus, chan, note, val)
    local dev = lvar.hardout[devbus]
    if dev then
      reaper.StuffMIDIMessage(16+dev, 144+chan, note, math.min(tonumber(val),127))
    end
  end
  
  local function CF_Flip()
    if lvar.flip > 0 then
      return 1, 127
    else
      return 0, 0
    end
  end

  local function CF_Timecode()
    return lvar.timecodedisplayformat
  end

  local function CF_RemapControls()
    if lvar.remap_active then
      return 1, 127
    else
      return 0, 0    
    end
  end

  local function CF_PlayOnTouchCC()
    if lvar.cc_starttransportonfadertouch == true then
      return 1, 127
    else
      return 0, 0
    end
  end

  local function CF_StampCC()
    return 0, 0
  end

  local function CF_GrpOnOff()
    if lvar.ctlgroup_select > 0 then
      return 1, 1
    else
      return 0, 0
    end
  end

  local function CF_Off()
    return 0, 0
  end

  local function CF_Automap()
    if lvar.rec_mapactiveenvstofaders2 == true then
      return 1, 127
    else
      return 0, 0
    end
  end
  
  local function CF_LearnFX()
    if lrnmode == true then
      return 1, 127
    else
      return 0, 0
    end
  end

  local function CF_REC()
    if recmode == 1 then
      return 1, 127
    else
      return 0, 0
    end
  end

  local function CF_AssDispMode()
    return 0, 0
  end

  local function CF_TrackSelectMode()
    if lvar.trackselectmode then
      return 1, 127
    else
      return 0, 0
    end
  end

  local function CF_FB()
    if not lvar.fbcconseek then
      return 1, 127
    else
      return 0, 0
    end
  end

  local function CF_SSVals()
    if lvar.ss_alwaysshowdispval then
      return 1, 127
    else
      return 0, 0
    end
  end

  local function CF_Automap_Flip()
    if lvar.rec_automap_flip == true then
      return 1, 127
    else
      return 0, 0
    end
  end
  
  local function CF_Mode(tmp, i)  
    if tmp.pos[i].codeval == 2 then
      if lvar.mode == 3 then
        return 1, 127
      end
    elseif tmp.pos[i].codeval == 3 then
      if lvar.mode == 2 then
        return 1, 127
      end
    elseif tmp.pos[i].codeval == 4 then
      if lvar.mode == 1 then
        return 1, 127
      end
    end
    return 0, 0
  end
  
  
  function OpenFXGUI(track,fxnum)
  
    local fxopentimerset = false
    if reaper.TrackFX_GetOpen(track, fxnum) ~= true then
      reaper.TrackFX_Show(track,fxnum,3)
      fxopentimerset = true
    end
    if lvar.fxopentimer or fxopentimerset == true then
      lvar.fxopentimer = reaper.time_precise() + settings.floatfxgui
      lvar.fxopeninfo = {track = track,
                         fxnum = fxnum}
    end
    
  end
  function CloseFXGUI(track,fxnum)
    reaper.TrackFX_Show(track,fxnum,2)
  end
  
  function GetFaderEnvelope(f, recallseltrack)
    
    local env
    local tmp = GetTemplatePos(f, true)
    if tmp then
      if tmp.ptype == ptype.host then
      
        if not FFX.take or tmp.globalhost == 1 then
          local tgttrack 
          if tmp.globalhost == 0 then
            tgttrack = GetTrack(FFX.trn)
            if tgttrack then
              env = reaper.GetFXEnvelope(tgttrack, FFX.fxnum, tmp.pnum, true)
            end
          elseif tmp.globalhost == 1 then
            tgttrack = GetTrack(tmp.ptrack)
            if tgttrack then
              env = reaper.GetFXEnvelope(tgttrack, tmp.pfxnum, tmp.pnum, true)
            end
          elseif tmp.globalhost == 2 then
            --check
            tgttrack = reaper.GetSelectedTrack2(0, 0, true)
            local fxnum
            if reaper.TrackFX_GetFXGUID(tgttrack, tmp.pfxnum) == tmp.pfxguid then
              fxnum = tmp.pfxnum
            else
              ok = false
              --find FX
              local trn, trguid, fxnum_, fxguid_ = FindFX2(tgttrack, tmp.pfxmodule, tmp.pfxguid)
              if trguid then
                tmp.ptrack = trn
                tmp.ptrguid = trguid
                tmp.pfxnum = fxnum_
                tmp.pfxguid = fxguid_
                tgttrack = GetTrack(trn)
                fxnum = fxnum_
                ok = true
              else
                tmp.ptrack = trn -- -100
                tmp.pfxnum = fxnum_ -- -1
              end
            end
            
            if tgttrack and fxnum then
              env = reaper.GetFXEnvelope(tgttrack, fxnum, tmp.pnum, true)
            end
          end
        else
          --ignore for now
          --env = reaper.TakeFX_GetEnvelope(FFX.take, FFX.fxnum, tmp.pnum, true)
        end
        
      elseif tmp.ptype == ptype.track then
        
        local trn = tmp.track
        local ttrn, trackD = Internal_GetTrack(trn, tmp)
    
        if trackD then
          if tmp.trparam > 0 then
            local tgttrack = trackD
            local param = tab_trparams_envnames[tmp.trparam]
            if param then
              env = reaper.GetTrackEnvelopeByName(tgttrack, param)
              if not env then
                --create
                local selectedtracks
                if recallseltrack and not selectedtracks then
                  selectedtracks = StoreSelectedTracks()
                end                      
                reaper.SetOnlyTrackSelected(tgttrack)
                local actionid = tab_trparams_envcreate[tmp.trparam]
                if actionid then
                  reaper.Main_OnCommand(actionid, 0)
                end
                env = reaper.GetTrackEnvelopeByName(tgttrack, param)
                --hide
                --VisEnv(env, true)
                
                if recallseltrack and selectedtracks then
                  RestoreSelectedTracks(selectedtracks)                  
                end                
              end    
              --VisEnv(env, true)
            end
            
          elseif tmp.trsend > 0 then
            local tgttrack = trackD
            local snd_type = ((tmp.trsend-1) % 3)
            local si = math.floor((tmp.trsend-1) / 3)
            local skip = 0
            
            local guid = reaper.GetTrackGUID(trackD)
            local scnt = reaper.GetTrackNumSends(trackD,0) + reaper.GetTrackNumSends(trackD,1)
            
            if not tab_SendIdx or not tab_SendIdx[guid] or tab_SendIdx[guid].count ~= scnt then
              GetSendIdxTable(ttrn)
            end
            local snd_idx 
            if tab_SendIdx and tab_SendIdx[guid] and tab_SendIdx[guid][si] then
              snd_idx = tab_SendIdx[guid][si].idx
            end

            if snd_idx and snd_idx <= scnt-1 then
              env = reaper.GetTrackSendInfo_Value(tgttrack, 0, snd_idx, 'P_ENV:'..lvar.sndinfo[snd_type])
              
              if env then
                local val = reaper.GetTrackSendInfo_Value(tgttrack, 0, snd_idx, lvar.sndinfo[snd_type+3])
                VisEnv2(env, true, true, val, snd_type)
              end
            
            end
            
            --check send is not to skctl track
            --[[local sendtgttr --= reaper.BR_GetMediaTrackSendInfo_Track(tgttrack, 0, si, 1) -- get target track
            local ctltrack = GetTrack(LBX_CTL_TRACK)
            for i = 0, si do
              sendtgttr = reaper.BR_GetMediaTrackSendInfo_Track(tgttrack, 0, i, 1) -- get target track
              if sendtgttr == ctltrack then
                skip = skip + 1
              end
            end
            if sendtgttr then
              --DBG(skip..'  '..si..'  '..si + skip)
              env = reaper.BR_GetMediaTrackSendInfo_Envelope(tgttrack, 0, si + skip, snd_type)
              if env then
                --check target track is not SKCTL
                VisEnv(env, false, true)
              end
            end]]
          end
        end            
      
      elseif tmp.ptype == ptype.internal then
        if tmp.code == 18 and tmp.codeval <= lvar.qfx_faders then
          local idx = tmp.codeval
          local qfx = lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx]
          if qfx then
            local track, trnum, fxnum = QFX_FindFX(qfx)
            if track and qfx.enabled == 1 then
              env = reaper.GetFXEnvelope(track, fxnum, qfx.pnum, true)
            end
          end
        end
      end
    end
    
    return env
    
  end

  function GetTrackEnvelope(track, trparam, trsend, recallseltrack)
    
    local env
    if track then
      local ttrn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
      if trparam > 0 then
        local tgttrack = track
        local param = tab_trparams_envnames[trparam]
        if param then
          env = reaper.GetTrackEnvelopeByName(tgttrack, param)
          if not env then
            --create
            local selectedtracks
            if recallseltrack and not selectedtracks then
              selectedtracks = StoreSelectedTracks()
            end                      
            reaper.SetOnlyTrackSelected(tgttrack)
            local actionid = tab_trparams_envcreate[trparam]
            if actionid then
              reaper.Main_OnCommand(actionid, 0)
            end
            env = reaper.GetTrackEnvelopeByName(tgttrack, param)
            if recallseltrack and selectedtracks then
              RestoreSelectedTracks(selectedtracks)                  
            end                
          end    
        end
        
      elseif trsend > 0 then
        local tgttrack = track
        local snd_type = ((trsend-1) % 3)
        local si = math.floor((trsend-1) / 3)
        local skip = 0
        
        local guid = reaper.GetTrackGUID(track)
        local scnt = reaper.GetTrackNumSends(track,0) + reaper.GetTrackNumSends(track,1)
        
        if not tab_SendIdx or not tab_SendIdx[guid] or tab_SendIdx[guid].count ~= scnt then
          GetSendIdxTable(ttrn)
        end
        local snd_idx 
        if tab_SendIdx and tab_SendIdx[guid] and tab_SendIdx[guid][si] then
          snd_idx = tab_SendIdx[guid][si].idx
        end

        if snd_idx and snd_idx <= scnt-1 then
          env = reaper.GetTrackSendInfo_Value(tgttrack, 0, snd_idx, 'P_ENV:'..lvar.sndinfo[snd_type])
          
          if env then
            local val = reaper.GetTrackSendInfo_Value(tgttrack, 0, snd_idx, lvar.sndinfo[snd_type+3])
            VisEnv2(env, true, true, val, snd_type)
          end
        
        end
      end
    end            
    
    return env
    
  end
  
  function StoreSelectedTracks()
    local tbl = {}
    for t = 0, reaper.CountSelectedTracks2(0, true)-1 do
      local tr = reaper.GetSelectedTrack2(0, t, true)
      if tr then
        tbl[#tbl+1] = tr
      end
    end
    return tbl
  end

  function RestoreSelectedTracks(tracktbl)

    for t = 1, #tracktbl do
      if t == 1 then
        reaper.SetOnlyTrackSelected(tracktbl[t])
      else
        reaper.SetTrackSelected(tracktbl[t], true)      
      end
    end
    tracktbl = nil
    
  end
    
  function MonitorTouch(fader, env)

    local i = fader
    --if lvar.touchrec_data[i].ptype == ptype.host then
  
      local gmem = reaper.gmem_read
      
      local tgttrack = lvar.touchrec_data[i].track --GetTrack(FFX.trn)
      if tgttrack then
        local armed = fader_touch2[i] or lvar.tobool[gmem(lvar.gm_fb.fadertouch + i-1)]
        
        if armed ~= lvar.touchrec_data[i].armed then
        
          local osc, tn, bk
          if lvar.touchrec_data[i].ptype == ptype.track then
            if lvar.touchrec_data[i].trparam > 0 then
              if lvar.touchrec_data[i].trparam == 1 then
                --DBG(lvar.touchrec_data[i].trn)
                bk = math.floor((lvar.touchrec_data[i].trn-1) / lvar.osc_banksize)+1
                tn = ((lvar.touchrec_data[i].trn-1) % lvar.osc_banksize) + 1 
                osc = '/track/'..string.format('%i',tn) ..'/volume/touch'
              elseif lvar.touchrec_data[i].trparam == 2 then
                bk = math.floor(lvar.touchrec_data[i].trn / lvar.osc_banksize)+1
                tn = ((lvar.touchrec_data[i].trn-1) % lvar.osc_banksize) + 1 
                osc = '/track/'..string.format('%i',tn) ..'/pan/touch'            
              end
            end
          end
        
          local env = lvar.touchrec_data[i].env --reaper.GetFXEnvelope(tgttrack, lvar.touchrec_data[i].fxnum, lvar.touchrec_data[i].pnum, true)
          if lvar.touchrec_data[i].ptype == ptype.track then
            --VisEnv(env, armed)
          else
            --local _, en = reaper.GetEnvelopeName(env)
            ArmEnv(env, armed)
          end
          if osc then
            local val
            if armed then
              val = 1
            else
              val = 0
            end
            --DBG(osc..'  '..val..'  '..bk)
            reaper.OscLocalMessageToHost('/device/track/bank/select/'..string.format('%i',bk))
            reaper.OscLocalMessageToHost(osc,val)
            --DBG('/device/track/bank/select/'..string.format('%i',bk))
            --DBG(osc..'  '..tostring(val))
          end
          
          if armed == false and lvar.touchrec_data[i].ptype == ptype.track and osc then
            --VisEnv(env, true)          
            reaper.OscLocalMessageToHost(osc,val)
            --DBG(osc..'  '..tostring(val))
          end
          lvar.touchrec_data[i].armed = armed
          --[[if armed == false then
            DBG('Untouch '..i)
          else
            DBG('Touch '..i)
          end]]
        end      
      end  
    --end
 
  end
  
  function SetRecTouchMode(activate)
  
    --reset envelopes
    if lvar.touchrec_active and lvar.touchrec_data then

      for i, b in pairs(lvar.touchrec_data) do
      
        local tgttrack = lvar.touchrec_data[i].track --GetTrack(FFX.trn)
        if tgttrack then
          local env = lvar.touchrec_data[i].env --reaper.GetFXEnvelope(tgttrack, lvar.touchrec_data[i].fxnum, lvar.touchrec_data[i].pnum, true)
          ----ArmEnv(env, lvar.touchrec_data[i].defarmed)
          
          VisEnv(env, true) --lvar.touchrec_data[i].defarmed)
          ArmEnv(env, true)
          
          --untouch all track vol/pan envelopes
          if lvar.touchrec_data[i].ptype == ptype.track then
            if lvar.touchrec_data[i].trparam > 0 then
              local osc
              local bk = math.floor(lvar.touchrec_data[i].trn / 8)+1
              local tn = ((lvar.touchrec_data[i].trn-1) % 8) + 1              
              if lvar.touchrec_data[i].trparam == 1 then
                osc = '/track/'..string.format('%i',tn) ..'/volume/touch'
              elseif lvar.touchrec_data[i].trparam == 2 then
                osc = '/track/'..string.format('%i',tn) ..'/pan/touch'           
              end
              if osc then
                reaper.OscLocalMessageToHost('/device/track/bank/select/'..string.format('%i',bk))
                reaper.OscLocalMessageToHost(osc,0)
              end
            end
          end
        end            
    
      end
      lvar.touchrec_active = false
      lvar.touchrec_data = nil    
    end
    
    if activate then
    
      lvar.touchrec_active = true
      lvar.touchrec_data = {}
      local gmem = reaper.gmem_read
      
      local selectedtracks
      reaper.PreventUIRefresh(1)
      
      reaper.OscLocalMessageToHost('/device/track/count/'..string.format('%i',lvar.osc_banksize))
          
      for i = 1, lvar.fcount do
      
        if ctl_template.fader[i].ttype then        
          
          local tmp = GetTemplatePos(i, true)
          if tmp then
            if tmp.ptype == ptype.host then
            
              local ttrn = FFX.trn
              local fxnum = FFX.fxnum
              if tmp.globalhost >= 1 then
                ttrn = tmp.ptrack
                fxnum = tmp.pfxnum
              end
              local tgttrack = GetTrack(ttrn)
              if tgttrack then
                local env = reaper.GetFXEnvelope(tgttrack, fxnum, tmp.pnum, true)
    
                local armed = lvar.tobool[gmem(lvar.gm_fb.fadertouch + i-1)]
                local defarmed = VisEnv(env, true)
                ArmEnv(env, true)
                --DBG(tostring(armed)..'  '..tostring(defarmed))
  
                lvar.touchrec_data[i] = {env = env, armed = armed, defarmed = defarmed, 
                                         track = tgttrack, fxnum = fxnum, pnum = tmp.pnum, ptype = tmp.ptype}
              end
            elseif tmp.ptype == ptype.track then
              
              local trn = tmp.track
              local ttrn, trackD = Internal_GetTrack(trn, tmp)
              --[[if trn then
                if trn <= -1 then
                  if trn == -1 then
                    trackD = reaper.GetSelectedTrack2(0, 0, true)
                    if trackD then
                      ttrn = reaper.GetMediaTrackInfo_Value(trackD, 'IP_TRACKNUMBER')
                    end
                  elseif trn == -2 then
                    ttrn = lvar.track_internal + tmp.troff 
                    if lvar.ctltracks[ttrn] then
                      ttrn = ttrn + lvar.ctltracks.count
                    end 
                    trackD = GetTrack(ttrn)
                  end
                else
                  trackD = GetTrack(trn)
                  ttrn = trn
                end
              end]]
          
              if trackD then
                if tmp.trparam > 0 then
                
                  local tgttrack = trackD
                  local param = tab_trparams_envnames[tmp.trparam]
                  if param then
                    local env = reaper.GetTrackEnvelopeByName(tgttrack, param)
                    if not env then
                      --create
                      if not selectedtracks then
                        selectedtracks = StoreSelectedTracks()
                      end                      
                      reaper.SetOnlyTrackSelected(tgttrack)
                      local actionid = tab_trparams_envcreate[tmp.trparam]
                      if actionid then
                        reaper.Main_OnCommand(actionid, 0)
                      end
                      env = reaper.GetTrackEnvelopeByName(tgttrack, param)
                    end    
                    if env then
                      local armed = lvar.tobool[gmem(lvar.gm_fb.fadertouch + i-1)]
                      --local defarmed = ArmEnv(env, armed)
                      local defarmed = VisEnv(env, true)
                      lvar.touchrec_data[i] = {env = env, armed = armed, defarmed = defarmed, 
                                               track = tgttrack, trn = ttrn, trparam = tmp.trparam, trsend = tmp.trsend, ptype = tmp.ptype}                    
                    end
                  end
                  
                elseif tmp.trsend > 0 then
                  local tgttrack = trackD
                  local snd_type = ((tmp.trsend-1) % 3)
                  local si = math.floor((tmp.trsend-1) / 3)
                  
                  local guid = reaper.GetTrackGUID(trackD)
                  local scnt = reaper.GetTrackNumSends(trackD,0) + reaper.GetTrackNumSends(trackD,1)
                  
                  if not tab_SendIdx or not tab_SendIdx[guid] or tab_SendIdx[guid].count ~= scnt then
                    GetSendIdxTable(ttrn)
                  end
                  local snd_idx 
                  if tab_SendIdx and tab_SendIdx[guid] and tab_SendIdx[guid][si] then
                    snd_idx = tab_SendIdx[guid][si].idx
                  end
                  
                  if snd_idx and snd_idx <= scnt-1 then
                  
                    local env = reaper.BR_GetMediaTrackSendInfo_Envelope(tgttrack, 0, snd_idx, snd_type)
                    if env then
                      local armed = lvar.tobool[gmem(lvar.gm_fb.fadertouch + i-1)]
                      --local defarmed = ArmEnv(env, armed)
                      local defarmed = VisEnv(env, true)
                      lvar.touchrec_data[i] = {env = env, armed = armed, defarmed = defarmed, 
                                               track = tgttrack, trn = ttrn, trparam = tmp.trparam, trsend = tmp.trsend, ptype = tmp.ptype}                    
                    end

                  end                  
                  
                  --[[check send is not to skctl track                  
                  local sendtgttr --= reaper.BR_GetMediaTrackSendInfo_Track(tgttrack, 0, si, 1) -- get target track
                  local ctltrack = GetTrack(LBX_CTL_TRACK)
                  local skip = 0
                  for i = 0, si do
                    sendtgttr = reaper.BR_GetMediaTrackSendInfo_Track(tgttrack, 0, i, 1) -- get target track
                    if sendtgttr == ctltrack then
                      skip = skip + 1
                    end
                  end
                  if sendtgttr then
                    local env = reaper.BR_GetMediaTrackSendInfo_Envelope(tgttrack, 0, si + skip, snd_type)
                    if env then
                      local armed = lvar.tobool[gmem(lvar.gm_fb.fadertouch + i-1)]
                      --local defarmed = ArmEnv(env, armed)
                      local defarmed = VisEnv(env, true)
                      lvar.touchrec_data[i] = {env = env, armed = armed, defarmed = defarmed, 
                                               track = tgttrack, trn = ttrn, trparam = tmp.trparam, trsend = tmp.trsend, ptype = tmp.ptype}                    
                    end
                  end]]
                end
              end            
            end
          end
        end
      
      end
      
      if selectedtracks then
        RestoreSelectedTracks(selectedtracks)
      end
      
      reaper.PreventUIRefresh(-1)
    end
  
  end
  
  function REC_SetSSOverrideColor(v)
  
    if v and (lvar.ss_color_override_enabled or lvar.ss_color_override_nonautomatable) then
      
      lvar.ss_color_override = {}
      if lvar.autoenv then    
      
        for i = 1, lvar.fcount do
     
          --if ctl_template.fader[i].ttype then
          if lvar.chanstrips.idx[i] then
           
            local tmp = GetTemplate(i)
            local tmppos = tmp.pos[i]
            if tmppos then 
              if lvar.ss_color_override_enabled and (tmppos.ptype == ptype.host or tmppos.ptype == ptype.track) and tmppos.exauto ~= 1 then
                lvar.ss_color_override[i] = lvar.ss_color_override_color
              elseif lvar.ss_color_override_nonautomatable and ((tmppos.ptype ~= ptype.host and tmppos.ptype ~= ptype.track) or tmppos.exauto == 1) then
                lvar.ss_color_override[i] = lvar.ss_color_override_nonautomatable_color
              end 
            end
          end
        end
      end
      
    else
      lvar.ss_color_override = {}
    end
    SendScribbleData()
    
  end
  
  function SetRecMode(m)
  --DBGOut('SetRecMode')
  
    lvar.env_indzoomh = {}
    
    if LBX_CTL_TRACK and FFX then
      if m == 0 then
        --Set CTL TRACK to read/trim
        --Copy Envelope range to target param envelope
        REC_SetSSOverrideColor(false)
        
        --local ctltrack = GetTrack(LBX_CTL_TRACK)
        local tgttrack = GetTrack(FFX.trn)
        
        --local start_time, end_time = reaper.GetSet_LoopTimeRange2(0, false, false, 0, 0, false)

        --if start_time ~= end_time then
        for i = 1, lvar.fcount do
          --if fader_touch[i] == true then

            --local srcenv = reaper.GetFXEnvelope(ctltrack, math.floor((i-1)/32), (i-1) % 32, false)
          if template.pos[i] and template.pos[i].ptype == ptype.host then
            local srcenv = reaper.GetFXEnvelope(tgttrack, FFX.fxnum, template.pos[i].pnum, true)
            --if srcenv and dstenv then
            --  CopyEnv(srcenv, dstenv, start_time, end_time, true)
            --end
            --disarm 

            if srcenv then
              
              local br_env = reaper.BR_EnvAlloc(srcenv, false)              
              local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling = 
                                                            reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
              reaper.BR_EnvSetProperties(br_env, active, false, true, inLane, laneHeight, defaultShape, faderScaling)              
              reaper.BR_EnvFree(br_env, false)
            end
          end
        end
        --end
              
        --Remove envelopes
        --[[for i = 0, control_cnt-1 do
          ClearEnvelope(LBX_CTL_TRACK, i)
        end
        SetAutoMode(LBX_CTL_TRACK, 0)]]
        if lvar.tcpsp then
          SetTCPScrollPos(lvar.tcpsp)
        end
        reaper.UpdateArrange()
        SetAutoMode(FFX.trn, LBX_FX_TRACK_AM)
        
        reaper.Undo_EndBlock("LBX Record Automation", 0) -- End of the undo block. Leave it at the bottom of your main function.
        
      elseif m == 1 then
      
        reaper.Undo_BeginBlock()
      
        lvar.tcpsp = GetTCPScrollPos()
        --touch mode?
        if lvar.rec_mapactiveenvstofaders2 or mouse.ctrl then
          lvar.rec_mapactiveenvstofaders = true
        else
          lvar.rec_mapactiveenvstofaders = false
        end
        
        if lvar.rec_mapactiveenvstofaders then
          lvar.rec_automap_bankoffset = 0
          REC_MapEnvsToFaders()
        end

        REC_EnvelopeData_SlipAssignments(true)
        REC_EnvelopeData_Gather()

        REC_SetSSOverrideColor(true)
        
        if lvar.autoenv then
          --Env_AutoShow()
        end
        
        if LBX_CTL_TRACK_AM == 2 then
          SetAutoMode(FFX.trn, lvar.touchmode)
          SetRecTouchMode(true)
        else
          SetAutoMode(FFX.trn, LBX_CTL_TRACK_AM)
        end
        
        lvar.readparams = nil --required to prevent host params resetting
        
        reaper.Undo_EndBlock("LBX REC mode enabled", 0)
        
        --fader_touch = {}
      
      elseif m == -1 then
        --CLEAR REC MODE
        recmode = 0
        if lvar.rec_mapactiveenvstofaders then
          if lvar.rec_automap_selectedtracks and #lvar.rec_automap_selectedtracks > 0 then
            for t = 1, #lvar.rec_automap_selectedtracks do
              if reaper.ValidatePtr(lvar.rec_automap_selectedtracks[t].track, 'MediaTrack*') then
                reaper.SetTrackSelected(lvar.rec_automap_selectedtracks[t].track,true)
              end
            end
          end
          lvar.rec_automap_selectedtracks = nil
        end
        --Remove envelopes
        --[[for i = 0, control_cnt-1 do
          ClearEnvelope(LBX_CTL_TRACK, i)
          
        end
        reaper.UpdateArrange()]]
        --SetAutoMode(LBX_CTL_TRACK, 0)
        reaper.Undo_BeginBlock()
        
        SetAutoMode(FFX.trn, LBX_FX_TRACK_AM)
        SetRecTouchMode()

        --if lvar.autoenv then
        if lvar.autoenv_mode == 3 then
          REC_ReturnEnvelopesToStoredState(nil, true, true)
        else
          REC_ReturnEnvelopesToStoredState()
        end
        REC_EnvelopeData_SlipAssignments()
        --end

        if lvar.autoenv_mode == 1 then
          REC_AutoTracks_Restore()
        elseif lvar.autoenv_mode == 2 then
          REC_AutoTracks_Restore()
        end
        
        --must be done after restore
        if lvar.rec_mapactiveenvstofaders then
          lvar.readparams = nil
          rectemplate = {dirty = {},
                         pos = {},
                         sft = {},
                         eft = {}}
          TemplateChanged()
        end
        
        REC_SetSSOverrideColor(false)
        fader_touch = {}

        if lvar.tcpsp then
          SetTCPScrollPos(lvar.tcpsp)
        end
        
        reaper.Undo_EndBlock("LBX REC mode disabled", 0)

      elseif m == -2 then
        --CLEAR REC MODE
        recmode = 0
        if lvar.rec_mapactiveenvstofaders then
          if lvar.rec_automap_selectedtracks and #lvar.rec_automap_selectedtracks > 0 then
            for t = 1, #lvar.rec_automap_selectedtracks do
              if reaper.ValidatePtr(lvar.rec_automap_selectedtracks[t].track, 'MediaTrack*') then
                reaper.SetTrackSelected(lvar.rec_automap_selectedtracks[t].track,true)
              end
            end
          end
          lvar.rec_automap_selectedtracks = nil
        end
        
        reaper.Undo_BeginBlock()
        
        SetAutoMode(FFX.trn, LBX_CTL_TRACK_AM)
        SetRecTouchMode()
        
        --if lvar.autoenv then
        if lvar.autoenv_mode == 3 then
          REC_ReturnEnvelopesToStoredState(nil, true, true)
        else
          REC_ReturnEnvelopesToStoredState()
        end
        REC_EnvelopeData_SlipAssignments()
        --end

        if lvar.autoenv_mode == 1 then
          REC_AutoTracks_Restore()
        elseif lvar.autoenv_mode == 2 then
          REC_AutoTracks_Restore()
        end
        
        --must be done after restore
        if lvar.rec_mapactiveenvstofaders then
          lvar.readparams = nil
          rectemplate = {dirty = {},
                         pos = {},
                         sft = {},
                         eft = {}}
          TemplateChanged()
        end

        REC_SetSSOverrideColor(false)
        fader_touch = {}

        if lvar.tcpsp then
          SetTCPScrollPos(lvar.tcpsp)
        end
        
        reaper.Undo_EndBlock("LBX Clear REC mode", 0)

      end
    end

    --DBGOut('exit func: SetRecMode')
  end

  function BR_EnvAlloc(env)
    return reaper.BR_EnvAlloc(env, false)
  end

  function SetEnvLaneHeight(env, h)

    if env and reaper.ValidatePtr2(0, env, "TrackEnvelope*") then

      local br_env = reaper.BR_EnvAlloc(env, false)              
      --local status, retval = pcall(BR_EnvAlloc, env)
      --if status then
      --  local br_env = retval
        local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling = reaper.BR_EnvGetProperties(br_env)
        reaper.BR_EnvSetProperties(br_env, active, visible, armed, inLane, h, defaultShape, faderScaling)              
        reaper.BR_EnvFree(br_env, true)
        return laneHeight
      --end
    end
  
  end
    
  function ArmEnv(env, arm)

    if env and reaper.ValidatePtr2(0, env, "TrackEnvelope*") then

      local br_env = reaper.BR_EnvAlloc(env, false)              
      --local status, retval = pcall(BR_EnvAlloc, env)
      --if status then
        --local br_env = retval
        local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling = reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
        reaper.BR_EnvSetProperties(br_env, active, visible, arm, inLane, laneHeight, defaultShape, faderScaling)              
        reaper.BR_EnvFree(br_env, true)
        return armed
      --end
    end
  
  end

  function GetEnvProps(env)

    if env and reaper.ValidatePtr2(0, env, "TrackEnvelope*") then
      local br_env = reaper.BR_EnvAlloc(env, false)
      local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling 
            = reaper.BR_EnvGetProperties(br_env) --, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
      --DBG(tostring(visible)..'  '..tostring(env))
      reaper.BR_EnvFree(br_env, true)
      return active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling
    end
    
  end

  function VisEnv2(env, vis, act, val, type)
    
    if env and reaper.ValidatePtr2(0, env, "TrackEnvelope*") then
      if val then
        local ret, time, value = reaper.GetEnvelopePoint(env, 0)
        if ret == false then
          --insert point
          if type == 0 then
            local v2 = 20*math.log(val, 10)
            val = reaper.DB2SLIDER(v2)
          end
          reaper.InsertEnvelopePoint(env, 0, val, 0, 0, false, false)
        end
      end
      local br_env = reaper.BR_EnvAlloc(env, false)
      local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling = reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
      if act then active = act end
      reaper.BR_EnvSetProperties(br_env, active, vis, true, true, laneHeight, defaultShape, faderScaling)              
      reaper.BR_EnvFree(br_env, true)
            
      return visible
    end
  end
  
  function VisEnv(env, vis, act)
    if env and reaper.ValidatePtr2(0, env, "TrackEnvelope*") then
      --local br_env = reaper.BR_EnvAlloc(env, false)
      local status, retval = pcall(BR_EnvAlloc, env)
      if status then
        local br_env = retval
        local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling = reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
        if act then active = act end
        reaper.BR_EnvSetProperties(br_env, active, vis, armed, inLane, laneHeight, defaultShape, faderScaling)              
        reaper.BR_EnvFree(br_env, true)
        return visible
      end
    end
  end

  function IsEnvVisible(env)
    if env and reaper.ValidatePtr2(0, env, "TrackEnvelope*") then
      local _, chunk = reaper.GetEnvelopeStateChunk(env, '', false)
      --DBG(chunk)
      --chunk seems to be quicker and less cpu intensive - use this for now
      local visible = false
      local v = string.match(chunk, '.*VIS (%d).*')
      if tonumber(v) == 1 then
        visible = true
      end
      --DBG(visible)
      --local status, retval = pcall(BR_EnvAlloc, env)
      --if status then
        --local br_env = retval
        --quicker but problematic as height not 0 if visible flag unset (but envelope exists)
        --[[local eh = reaper.GetEnvelopeInfo_Value(env, 'I_TCPH')
        local visible = false
        if eh > 0 then
          visible = true
        end]]
        
        --CPU intensive - but no other decent way to get flag (maybe chunk?)!
        --local br_env = reaper.BR_EnvAlloc(env, true)
        --local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling = reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
        return visible
      --end
    end
  end
  
  function CopyEnv(srcenv, dstenv, start_time, end_time, preserve_edges)
  
    env_points_count = reaper.CountEnvelopePoints(srcenv)
    if env_points_count > 0 then
    
      retval3, valueOut3, dVdSOutOptional3, ddVdSOutOptional3, dddVdSOutOptional3 = reaper.Envelope_Evaluate(srcenv, start_time, 0, 0)
      retval4, valueOut4, dVdSOutOptional4, ddVdSOutOptional4, dddVdSOutOptional4 = reaper.Envelope_Evaluate(srcenv, end_time, 0, 0)
      
      if preserve_edges == true then
        retval6, valueOut6, dVdSOutOptional6, ddVdSOutOptional6, dddVdSOutOptional6 = reaper.Envelope_Evaluate(dstenv, end_time, 0, 0)
        retval5, valueOut5, dVdSOutOptional5, ddVdSOutOptional5, dddVdSOutOptional5 = reaper.Envelope_Evaluate(dstenv, start_time, 0, 0)
      end
      
      reaper.DeleteEnvelopePointRange(dstenv, start_time, end_time)
       
      for k = 0, env_points_count+1 do
        retval, time, valueOut, shape, tension, selectedOut = reaper.GetEnvelopePoint(srcenv, k)

        if time >= start_time and time <= end_time then
          reaper.InsertEnvelopePoint(dstenv, time, valueOut, shape, tension, 1, true)
        end
      
      end
    
      if preserve_edges == true then
        reaper.InsertEnvelopePoint(dstenv, start_time, valueOut5, 0, 0, true, true) -- INSERT start_time point
      end
        reaper.InsertEnvelopePoint(dstenv, start_time, valueOut3, 0, 0, true, true) -- INSERT start_time point
        reaper.InsertEnvelopePoint(dstenv, end_time, valueOut4, 0, 0, true, true) -- INSERT start_time point
      if preserve_edges == true then
        reaper.InsertEnvelopePoint(dstenv, end_time, valueOut6, 0, 0, true, true) -- INSERT start_time point
      end
      reaper.Envelope_SortPoints(dstenv)
    end
    
  end
  
  function RemoveEnv(env)
    retval, xml_env = reaper.GetEnvelopeStateChunk(env, "", false)
    xml_env = xml_env:gsub("\n", "¤¤")
    retval, xml_env = reaper.SetEnvelopeStateChunk(env, xml_env, false)
    return xml_env
  end
  
  function ClearEnvelope(trn, envn)
    local track = GetTrack(trn)
    if track then
      local env = reaper.GetFXEnvelope(track, math.floor(envn/32), envn % 32, false)
      if env then 
        --[[local plen = reaper.GetProjectLength(0)
        reaper.DeleteEnvelopePointRange(env,-10,plen+10)]]
        RemoveEnv(env)
      end
    end
  end
  
  ------------------------------------------------------------    
  function ConvertColor(c)
    local r,g,b = reaper.ColorFromNative(c)
    return math.floor(r) .. ' ' .. math.floor(g) .. ' ' .. math.floor(b)
  end
  
  function ConvertColorString(s)
    if not s then return end
    local t = {}
    for i in s:gmatch("[%d%.]+") do 
      t[#t+1] = tonumber(i)
    end
    return reaper.ColorToNative(t[1],t[2],t[3])
  end

  function ARun_GroupSetUp()

    if mouse.context == nil then    
      if MOUSE_click(obj.sections[300]) or MOUSE_click_RB(obj.sections[300]) then
        if MOUSE_click(obj.sections[301]) then
          lvar.groupind[1].type = lvar.groupind[1].type + 1
          if lvar.groupind[1].type > #groupind_tab-1 then
            lvar.groupind[1].type = 0
          end
          lupd.update_dialog = true
        elseif MOUSE_click(obj.sections[305]) then
          lvar.groupind[2].type = lvar.groupind[2].type + 1
          if lvar.groupind[2].type > #groupind_tab-1 then
            lvar.groupind[2].type = 0
          end
          lupd.update_dialog = true
        elseif MOUSE_click_RB(obj.sections[301]) then
          lvar.groupind[1].type = lvar.groupind[1].type - 1
          if lvar.groupind[1].type < 0 then
            lvar.groupind[1].type = #groupind_tab-1
          end
          lupd.update_dialog = true
        elseif MOUSE_click_RB(obj.sections[305]) then
          lvar.groupind[2].type = lvar.groupind[2].type - 1
          if lvar.groupind[2].type < 0 then
            lvar.groupind[2].type = #groupind_tab-1
          end
          lupd.update_dialog = true
        elseif MOUSE_click(obj.sections[302]) then
          local ret, v = reaper.GetUserInputs('Repeats:',1,'Enter number of repeats:',lvar.groupind[1].rep)
          if ret and tonumber(v) then
            lvar.groupind[1].rep = math.floor(v)
          end
          lupd.update_dialog = true
        elseif MOUSE_click(obj.sections[303]) then
          local ret, v = reaper.GetUserInputs('On Time:',1,'Enter flash on time:',lvar.groupind[1].on)
          if ret and tonumber(v) then
            lvar.groupind[1].on = v
          end
          lupd.update_dialog = true
        elseif MOUSE_click(obj.sections[304]) then
          local ret, v = reaper.GetUserInputs('Off Time:',1,'Enter flash off/wait time:',lvar.groupind[1].off)
          if ret and tonumber(v) then
            lvar.groupind[1].off = v
          end
          lupd.update_dialog = true

        elseif MOUSE_click(obj.sections[309]) then
          lvar.groupind[1].invert = 1-lvar.groupind[1].invert
          lupd.update_dialog = true
        
        --[[elseif MOUSE_click(obj.sections[306]) then
          local ret, v = reaper.GetUserInputs('Repeats:',1,'Enter number of repeats:',lvar.groupind[2].rep)
          if ret and tonumber(v) then
            lvar.groupind[2].rep = math.floor(v)
          end
          lupd.update_dialog = true]]
        elseif MOUSE_click(obj.sections[307]) then
          local ret, v = reaper.GetUserInputs('On Time:',1,'Enter flash on time:',lvar.groupind[2].on)
          if ret and tonumber(v) then
            lvar.groupind[2].on = v
          end
          lupd.update_dialog = true
        elseif MOUSE_click(obj.sections[308]) then
          local ret, v = reaper.GetUserInputs('Off Time:',1,'Enter flash off/wait time:',lvar.groupind[2].off)
          if ret and tonumber(v) then
            lvar.groupind[2].off = v
          end
          lupd.update_dialog = true

        elseif MOUSE_click(obj.sections[310]) then
          lvar.groupind[2].invert = 1-lvar.groupind[2].invert
          lupd.update_dialog = true

        elseif MOUSE_click(obj.sections[311]) then
          GUI_FlashButton(obj, gui, 311, 'TEST', 0.1, '205 205 205', -1)
          HLGroupButtons()
          if #lvar.groupidx > 0 then
            if lvar.ctlgroup_select == 0 then
              lvar.ctlgroup_select = math.max(lvar.octlgroup_select or 1,1)
            end
            GMFB_FFlashData(lvar.groupind[1].type,lvar.groupind[1].on,lvar.groupind[1].off,lvar.groupind[1].rep,lvar.groupind[1].invert)
            HLGroupButtons(true)
            SendScribbleData()
          end
        end    
        
      elseif MOUSE_click(obj.sections[110]) then
        lvar.livemode = 0
        lupd.update_gfx = true
      
        SaveGroupSettings()
        GMFB_FFlashData(lvar.groupind[1].type,lvar.groupind[1].on,lvar.groupind[1].off,lvar.groupind[1].rep,lvar.groupind[1].invert)
        HLGroupButtons()
        lvar.ctlgroup_select = 0
        SendScribbleData()
      end
    end
    
  end
    
  function SaveGroupSettings()
  
    local fn = paths.resource_path..'group.txt'
    file=io.open(fn,"w")
    
    local key = 'Ind1_'
    file:write('['..key..'type]'..lvar.groupind[1].type..'\n')
    file:write('['..key..'rep]'..lvar.groupind[1].rep..'\n')
    file:write('['..key..'on]'..lvar.groupind[1].on..'\n')
    file:write('['..key..'off]'..lvar.groupind[1].off..'\n')
    file:write('['..key..'invert]'..(lvar.groupind[1].invert or 0)..'\n')    

    local key = 'Ind2_'
    file:write('['..key..'type]'..lvar.groupind[2].type..'\n')
    file:write('['..key..'rep]'..lvar.groupind[2].rep..'\n')
    file:write('['..key..'on]'..lvar.groupind[2].on..'\n')
    file:write('['..key..'off]'..lvar.groupind[2].off..'\n')
    file:write('['..key..'invert]'..(lvar.groupind[2].invert or 0)..'\n')    
    
    file:close()
    
  end
  
  function LoadGroupSettings()

    local fn = paths.resource_path..'group.txt'
    if reaper.file_exists(fn) then
    
      data = {}
      for line in io.lines(fn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          val = string.gsub(val, '[\r]', '') --Remove \r for Mac use
          data[idx] = val
        end
      end
    
      local key = 'Ind1_'
      lvar.groupind[1].type = tonumber(data[key..'type']) or 0  
      lvar.groupind[1].rep = tonumber(data[key..'rep']) or 4  
      lvar.groupind[1].on = tonumber(data[key..'on']) or 0.1  
      lvar.groupind[1].off = tonumber(data[key..'off']) or 0.1  
      lvar.groupind[1].invert = tonumber(data[key..'invert']) or 0  
    
      local key = 'Ind2_'
      lvar.groupind[2].type = tonumber(data[key..'type']) or 0  
      lvar.groupind[2].rep = tonumber(data[key..'rep']) or -1  
      lvar.groupind[2].on = tonumber(data[key..'on']) or 4  
      lvar.groupind[2].off = tonumber(data[key..'off']) or 0.1  
      lvar.groupind[2].invert = tonumber(data[key..'invert']) or 0  
    
    end
    
    GMFB_FFlashData(lvar.groupind[1].type,lvar.groupind[1].on,lvar.groupind[1].off,lvar.groupind[1].rep,lvar.groupind[1].invert)
    
  end

  function TagMenu_Load()
  
    if FFX == nil then return end
    
    local st, cp, rn = '', '#', '#'
    if lvar.tags.trackassoc[FFX.trname] then
      if lvar.tags.show then
        st = '!'
      end
      cp = ''
      rn = ''
    end
    local ps = '#'
    if lvar.tags.copy then
      ps = ''
    end
    if recmode ~= 0 then
      st = '#'..st
    end
    
    local mstr = st..'Show Tag||Clear Tag||'..cp..'Copy Tag|'..ps..'Paste Tag||'..rn..'Rename Tag'
    gfx.x, gfx.y = mouse.mx, mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then

        local v = not (lvar.tags.show or false)
        ToggleShowTag(v)
      
      elseif res == 2 then
      
        SetSelectedTrackTags(nil, nil, true)
        lupd.update_gfx = true
        
        template = LoadFXParamTemplate(FFX)
        TemplateChanged()
      
      elseif res == 3 then
        
        lvar.tags.copy = lvar.tags.trackassoc[FFX.trname].tag

      elseif res == 4 then

        SetSelectedTrackTags(lvar.tags.copy, true)
        lupd.update_gfx = true
        
        template = LoadFXParamTemplate(FFX)
        TemplateChanged()

      elseif res == 5 then
        
        if lvar.tags.trackassoc[FFX.trname] then

          local tag = lvar.tags.trackassoc[FFX.trname].tag
          local ret, ntag = reaper.GetUserInputs('Rename Tag: '..tag, 1, 'Enter New Tag Name:', tag)
          if ret and ntag ~= '' then
            RenameTag(tag, ntag)
            lupd.update_gfx = true
          end
        end
      end
    end
  
  end

  function TagMenu_Save()
  
    if FFX == nil then return end
    
    local st, cp = '', '#'
    if lvar.tags.trackassoc[FFX.trname] then
      if lvar.tags.show then
        st = '!'
      end
      cp = ''
    end
    local ps = '#'
    if lvar.tags.copy then
      ps = ''
    end
    if recmode ~= 0 then
      st = '#'..st
    end
    
    local mstr = st..'Show Tag||Clear Tag||'..cp..'Copy Tag|'..ps..'Paste Tag'
    gfx.x, gfx.y = mouse.mx, mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then

        local v = not (lvar.tags.show or false)
        ToggleShowTag(v)
      
      elseif res == 2 then
      
        SetSelectedTrackTags(nil, nil, true)
        lupd.update_gfx = true
        
        template = LoadFXParamTemplate(FFX)
        TemplateChanged()
      
      elseif res == 3 then
        
        lvar.tags.copy = lvar.tags.trackassoc[FFX.trname].tag

      elseif res == 4 then

        SetSelectedTrackTags(lvar.tags.copy, true)
        lupd.update_gfx = true
        
        template = LoadFXParamTemplate(FFX)
        TemplateChanged()

      end
    end
  
  end

  function ToggleShowTagSlot(slot)

    if recmode ~= 0 then return end

    reaper.PreventUIRefresh(1)
    
    lvar.tags.show = false
    if lvar.tagslots.show == slot then
      lvar.tagslots.show = 0
    else
      lvar.tagslots.show = slot
    end
    if lvar.tagslots.show > 0 then
      if lvar.mode == 3 then
        local trvis = {}
        local slottags = {}
        local slots = lvar.tags.slots[slot] or {}
        if slots then
          
          for i = 1, #slots do
            slottags[slots[i]] = true
          end
          
          local sel
          for t = 0, reaper.CountTracks(0) do
            local tr = reaper.GetTrack(0, t)
            if tr then
              local trnm = reaper.GetTrackState(tr)
              trvis[#trvis+1] = {trguid = reaper.GetTrackGUID(tr), 
                                 vis_tcp = reaper.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP'),
                                 vis_mcp = reaper.GetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER')}
                                 
              if lvar.tags.trackassoc[trnm] and lvar.tags.trackassoc[trnm].tag and slottags[lvar.tags.trackassoc[trnm].tag] then
                --show
                reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINTCP', 1)
                reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER', 1)
                if not sel then
                  reaper.SetOnlyTrackSelected(tr)
                  sel = true
                end
              else
                --hide 
                reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINTCP', 0)
                reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER', 0)
              end
            end
          end
          if not lvar.tags.tagshow_vis then
            lvar.tags.tagshow_vis = trvis
          end
        end
      end
    
    else
      if lvar.tags.tagshow_vis then
            
        local trguids = {}
        for t = 0, reaper.CountTracks(0)-1 do
          local tr = reaper.GetTrack(0, t)
          if tr then
            trguids[reaper.GetTrackGUID(tr)] = t
          end
        end
        
        local trvis = lvar.tags.tagshow_vis
        for i = 1, #trvis do
          local trn = trguids[trvis[i].trguid]
          if trn then
            local tr = reaper.GetTrack(0, trn)
            if tr then
              reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINTCP', trvis[i].vis_tcp)
              reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER', trvis[i].vis_mcp)
            end
          end
        end
        lvar.tags.tagshow_vis = nil
      end
    end

    reaper.PreventUIRefresh(-1)
    reaper.UpdateArrange()
    reaper.TrackList_AdjustWindows(false)
    if lvar.trackoffset_visibleonly > 0 then
      lvar.tracks_vis = Internal_VisibleTracks()
      TemplateChanged()
    end
  end

  function ToggleShowTag(v)
    
    if recmode ~= 0 then return end
    
    reaper.PreventUIRefresh(1)
    
    lvar.tagslots.show = 0
    if v ~= nil then
      lvar.tags.show = v
    end
    if lvar.tags.show then
      if lvar.mode == 3 then
        local trvis = {}
        if lvar.tags.trackassoc[FFX.trname] then
          local tag = lvar.tags.trackassoc[FFX.trname].tag
          
          for t = 0, reaper.CountTracks(0) do
            local tr = reaper.GetTrack(0, t)
            if tr then
              local trnm = reaper.GetTrackState(tr)
              
              trvis[#trvis+1] = {trguid = reaper.GetTrackGUID(tr), 
                                 vis_tcp = reaper.GetMediaTrackInfo_Value(tr, 'B_SHOWINTCP'),
                                 vis_mcp = reaper.GetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER')}
              
              if lvar.tags.trackassoc[trnm] and tag == lvar.tags.trackassoc[trnm].tag then
                --show
                reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINTCP', 1)
                reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER', 1)
              else
                --hide 
                reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINTCP', 0)
                reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER', 0)
              end
            end
          end
        end
        if not lvar.tags.tagshow_vis then
          lvar.tags.tagshow_vis = trvis
        end
      end
    else
      
      if lvar.tags.tagshow_vis then
      
        local trguids = {}
        for t = 0, reaper.CountTracks(0)-1 do
          local tr = reaper.GetTrack(0, t)
          if tr then
            trguids[reaper.GetTrackGUID(tr)] = t
          end
        end
        
        local trvis = lvar.tags.tagshow_vis
        for i = 1, #trvis do
          local trn = trguids[trvis[i].trguid]
          if trn then
            local tr = reaper.GetTrack(0, trn)
            if tr then
              reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINTCP', trvis[i].vis_tcp)
              reaper.SetMediaTrackInfo_Value(tr, 'B_SHOWINMIXER', trvis[i].vis_mcp)
            end
          end
        end
        lvar.tags.tagshow_vis = nil
      end
    end

    reaper.PreventUIRefresh(-1)
    reaper.UpdateArrange()
    reaper.TrackList_AdjustWindows(false)
    if lvar.trackoffset_visibleonly > 0 then
      lvar.tracks_vis = Internal_VisibleTracks()
      TemplateChanged()
    end
    --Stupid workaround to refresh Arrange as UpdateArrange doesn't work here!!
    --RefreshArrange()
    --ScrollTCP()
    --lvar.update_tcp2_A = reaper.time_precise() + 0.05
  end

  function RefreshArrange()
    local tr = GetTrack(0) --reaper.GetSelectedTrack(0,0)
    if tr then
      local sel = reaper.GetMediaTrackInfo_Value(tr,'I_SELECTED')
      if sel == 0 then
        sel = false
      else
        sel = true
      end
      reaper.SetTrackSelected(tr, not sel)
      reaper.SetTrackSelected(tr, sel)
    end
  end

  function SaveDummyData()

    local fn = paths.resource_path..'dummy_setup_data.txt'
    file=io.open(fn,"w")
    for f = 1, lvar.fcount do
      if ctl_template.fader[f].dtype == 999 then
        local key = '['..ctl_template.fader[f].devctl..'_LMODE]'
        file:write(key..string.format('%i',ctl_template.fader[f].lmode)..'\n')
      end
    end
    file:close()
    
  end

  function LoadDummyData()

    local fn = paths.resource_path..'dummy_setup_data.txt'
    if reaper.file_exists(fn) then
      local dummyidx = {}
      for f = 1, lvar.fcount do
        if ctl_template.fader[f].dtype == 999 then
          dummyidx[ctl_template.fader[f].devctl] = f
        end
      end
      
      local data = {}
      for line in io.lines(fn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
    
          local idx2, dtype = string.match(idx, '(.*)%_(.*)')
          if dtype == 'LMODE' then
            local didx = dummyidx[idx2]
            if didx then
              ctl_template.fader[didx].lmode = tonumber(val)
            end
          end
    
        end
      end
    end
    
  end
  
  function SaveTagData()
  
    local fn = paths.tags_path..'tagdata.txt'
    file=io.open(fn,"w")
    for i = 1, 32 do
      local key = '[TAGSLOT_'..string.format('%i',i)..']'
      file:write(key..lvar.tagslots[i].name..'\n')
    end
    for a, b in pairs(lvar.tags.tags) do
      local key = '[TAG]'
      file:write(key..a..'\n')

      local key = '[TAG_'..a..'_'
      file:write(key..'FN]'..b.fn..'\n')
      if b.slot and b.slot ~= '' then
        file:write(key..'SLOT]'..b.slot..'\n')
      end
    end
    
    for a, b in pairs(lvar.tags.trackassoc) do
      local key = '[ASSOC]'
      file:write(key..a..'\n')
      
      local key = '[ASSOC_'..a..'_'
      file:write(key..'TAG]'..b.tag..'\n')
    end
    file:close()
    
  end

  function InitTagSlots()
    lvar.tagslots = {offset = 0}
    for i = 1, 32 do
      lvar.tagslots[i] = {name = 'Tag grp '..string.format('%i',i),
                          selected = nil}
    end
  end

  function LoadTagData()

    InitTagSlots()
    
    local fn = paths.tags_path..'tagdata.txt'
    
    if reaper.file_exists(fn) then
      local data = {}
      local tags = {}
      local assoc = {}
      
      for line in io.lines(fn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          val = string.gsub(val, '[\r]', '') --Remove \r for Mac use
          if idx == 'TAG' then
            tags[#tags+1] = val
          elseif idx == 'ASSOC' then
            assoc[#assoc+1] = val
          else
            data[idx] = val
          end
        end
      end
      
      for i = 1, 32 do
        local tagslotname = data['TAGSLOT_'..string.format('%i',i)]
        if tagslotname then
          lvar.tagslots[i].name = tagslotname
        end
      end
      
      lvar.tags.slots = {}
      for i = 1, #tags do
  
        lvar.tags.tags[tags[i]] = {}
        
        local key = 'TAG_'..tags[i]..'_'
        lvar.tags.tags[tags[i]].fn = data[key..'FN']
        local slot = data[key..'SLOT']
        if slot then
          lvar.tags.tags[tags[i]].slot = slot
          for slotn in string.gmatch(slot,'%[(%d+)%]') do
            slotn = tonumber(slotn)
            if slotn then
              if lvar.tags.slots[slotn] == nil then
                lvar.tags.slots[slotn] = {}
              end
              local idx = #lvar.tags.slots[slotn] + 1
              lvar.tags.slots[slotn][idx] = tags[i]
              --DBG(slotn..' '..idx..' '..tags[i])
            end
          end
        end
      end

      for i = 1, #assoc do
  
        lvar.tags.trackassoc[assoc[i]] = {}
      
        local key = 'ASSOC_'..assoc[i]..'_'
        lvar.tags.trackassoc[assoc[i]].tag = data[key..'TAG']
      
      end
    
    end
    
  end
  
  function SaveTag()
  
    local tag = ''
    if lvar.tags.trackassoc[FFX.trname] then
      tag = lvar.tags.trackassoc[FFX.trname].tag or ''
    end
    
    local ret, tnm = reaper.GetUserInputs('Save Tag', 1, 'Enter Tag:', tag)
    if ret and tnm ~= '' then
      tnm = string.upper(tnm)
      local ffn = 'tag_'..tnm..'.smtemp'
      local fn = paths.tags_path..ffn
      SaveFXParamTemplate(nil, template, fn, nil, false)
      
      lvar.save_highlight = false
      lvar.tags.tags[tnm] = {fn = ffn}
      lvar.tags.trackassoc[FFX.trname] = {tag = tnm}
      SaveTagData()
      lupd.update_gfx = true
    end
    
  end
  
  function GetTagData()
  
    local tags = {}
    for a, b in pairs(lvar.tags.tags) do
      tags[#tags+1] = {tag = a}
    end
    --local tags = table_slowsort_str(tags, 'tag')
    local tags = table_sort(tags, 'tag')
    return tags
  end

  function FilterTagData(tags, filter)

    local ftags = {}
    if filter == '' then
      ftags = table.copy(tags) or {}
    else
      if tags then
        for i = 1, #tags do
          if string.match(tags[i].tag,'.*('..filter..').*') then
            ftags[#ftags+1] = {tag = tags[i].tag}
          end
        end
      end
    end
    ftags.offset = 0
    return ftags
    
  end
  
  function SetSelectedTrackTags(tag, verbose, clear)
  
    if tag or clear then
    
      local txt, txt2
      if clear then
        txt = "Clear tag from multiple tracks?\n\nSelecting 'No' will clear tag only for selected SK2 track"
        txt2 = "Clear Tag"
      else
        txt = "Assign to multiple tracks?\n\nSelecting 'No' will load tag only for selected SK2 track"
        txt2 = "Load Tag"
      end
      local tc = reaper.CountSelectedTracks(0)
      local res = 7
      if not verbose then
        if tc > 1 then
          res = reaper.MB(txt,txt2,3)
        end
      else
        res = 6
      end
      if res == 6 then
        for i = 0, tc-1 do
          local tr = reaper.GetSelectedTrack2(0, i, true)
          if tr then
            local trname = reaper.GetTrackState(tr)
            
            if clear then
              lvar.tags.trackassoc[trname] = nil
            else
              lvar.tags.trackassoc[trname] = {tag = tag}
            end
            
          end
        end
        SaveTagData()
      elseif res == 7 then
        if clear then
          lvar.tags.trackassoc[FFX.trname] = nil
        else
          lvar.tags.trackassoc[FFX.trname] = {tag = tag}
        end
        SaveTagData()
      end
    end
  
  end
  
  function copyfile(src, dest)
    local file = io.open(src, 'rb')
    if file then
      local content = file:read('*a')
      file:close()
      local file = io.open(dest, 'wb')
      file:write(content)
      file:close()
    end
  end

  function DeleteTag(tag)

    local ffn = 'tag_'..tag..'.smtemp'
    local fn = paths.tags_path..ffn
    if reaper.file_exists(fn) then
    
      os.remove(fn)
      
      local tags = {}
      for a, b in pairs(lvar.tags.tags) do
        if a == tag then
        else
          tags[a] = b
        end
      end
      lvar.tags.tags = tags
      
      local tags = {}
      for a, b in pairs(lvar.tags.trackassoc) do
        if b.tag == tag then
        else
          tags[a] = b
        end
      end
      lvar.tags.trackassoc = tags
      
      SaveTagData()
    end
    
  end
  
  function RenameTag(tag, ntag)
  
    --copy file
    ntag = string.upper(ntag)
    if not lvar.tags.tags[ntag] then
      local ffn = 'tag_'..ntag..'.smtemp'
      local fn = paths.tags_path..ffn
  
      tag = string.upper(tag)
      local offn = 'tag_'..tag..'.smtemp'
      local ofn = paths.tags_path..offn
      if reaper.file_exists(ofn) then
      
        copyfile(ofn, fn)
        os.remove(ofn)
        
        local tags = {}
        for a, b in pairs(lvar.tags.tags) do
          if a == tag then
            tags[ntag] = {fn = ffn}
          else
            tags[a] = b
          end
        end
        lvar.tags.tags = tags
        
        local tags = {}
        for a, b in pairs(lvar.tags.trackassoc) do
          if b.tag == tag then
            tags[a] = {tag = ntag}
          else
            tags[a] = b
          end
        end
        lvar.tags.trackassoc = tags
        
        SaveTagData()
      end
    else
      reaper.MB('Tag already exists.', 'Rename Tag', 0)
    end
    
  end

  function ARun_TagSlots(rt)
  
    if gfx.mouse_wheel ~= 0 then
    
      local mx, my = mouse.mx, mouse.my
      mouse.mx = mx - obj.sections[2000].x
      mouse.my = my - obj.sections[2000].y
      
      if MOUSE_over(obj.sections[2002]) then
        local v = GetMW(gfx.mouse_wheel) --gfx.mouse_wheel / 120
        --local
        local r = math.floor((obj.sections[2002].h) / butt_h)
        local a = (lvar.tagslots.offset or 0) - v*(r-1)
        local b = 32
        if a < b then
          lvar.tagslots.offset = F_limit((lvar.tagslots.offset or 0) - v*(r), 0, 32-(r))
        end
        lupd.update_tags = true
      end      
      
      gfx.mouse_wheel = 0
      mouse.mx, mouse.my = mx, my 
      
    end
    
    if MOUSE_click(obj.sections[2000]) or MOUSE_click_RB(obj.sections[2000]) then

      local mx, my = mouse.mx, mouse.my
      mouse.mx = mx - obj.sections[2000].x
      mouse.my = my - obj.sections[2000].y
      
      if MOUSE_click(obj.sections[2002]) then
      
        local rr = math.floor((mouse.my - obj.sections[2002].y) / butt_h) + 1
        if rr >= 1 then
          local r = rr + lvar.tagslots.offset
          if lvar.tagslots[r] then
            
            lvar.tagslots[r].selected = not lvar.tagslots[r].selected
            lupd.update_tags = true
         
          end
          
        end
        
      elseif MOUSE_click_RB(obj.sections[2002]) then

        local rr = math.floor((mouse.my - obj.sections[2002].y) / butt_h) + 1
        if rr >= 1 then
          local r = rr + lvar.tagslots.offset
          if lvar.tagslots[r] then
            local mstr = '#Slot: '..lvar.tagslots[r].name..'||Rename||Clear'
            gfx.x, gfx.y = mx, my
            local res = gfx.showmenu(mstr)
            if res > 0 then
              if res == 2 then
                local name = lvar.tagslots[r].name
                local ret, nname = reaper.GetUserInputs('Rename Slot: '..name, 1, 'Enter New Slot Name:', name)
                if ret and nname ~= '' then
                  lvar.tagslots[r].name = nname
                  
                  lupd.update_tags = true

                end
              elseif res == 3 then
                for i = 1, 32 do
                  lvar.tagslots[i].selected = false
                end
                lupd.update_tags = true
              end
            end
            
          end
        end      
        --lvar.livemode = 0
        --lupd.update_gfx = true
      end
      
      mouse.mx, mouse.my = mx, my 
      
    elseif MOUSE_click(obj.sections[110]) or MOUSE_click_RB(obj.sections[110]) then
      local slots = ''
      for i = 1, 32 do
        if lvar.tagslots[i].selected then
          slots = slots .. '['..string.format('%i',i)..']'
        end
      end
      lvar.tags.tags[lvar.tagslots.tag].slot = slots
      SaveTagData()
      LoadTagData()
      lvar.livemode = 4
      lupd.update_gfx = true
    end

  end
  
  function ARun_Tags(rt)
  
    local c = gfx.getchar()
    if c ~= 0 then
      --DBG(c)
      local upfilt
      if c == 6579564 then --delete
        lvar.tags.filter = ''
        upfilt = true
      elseif c == 8 then --backspace
        lvar.tags.filter = string.sub(lvar.tags.filter, 0, string.len(lvar.tags.filter)-1)
        upfilt = true
      elseif c == 27 then --escape
        lvar.livemode = 0
        lupd.update_gfx = true
      elseif c == 13 then --enter
        if lvar.tagfilt.selected then
          --lvar.tags.trackassoc[FFX.trname] = {tag = lvar.tagfilt.selected}
          --SaveTagData()
          
          SetSelectedTrackTags(lvar.tagfilt.selected)
          lvar.livemode = 0
          lupd.update_gfx = true
          
          template = LoadFXParamTemplate(FFX)
          TemplateChanged()
        end
      elseif c >= 32 and c <= 125 then
        lvar.tags.filter = string.format("%s%c",lvar.tags.filter, c)
        upfilt = true
        
      elseif c == 1885828464 then -- page up
      
        if #lvar.tagfilt > 0 then
          local r = math.floor((obj.sections[2002].h) / butt_h) -1
          if not lvar.tagfilt.selectednum then
            lvar.tagfilt.selectednum = lvar.tagfilt.offset
          end
          lvar.tagfilt.selectednum = math.max(lvar.tagfilt.selectednum - r,1)
          lvar.tagfilt.selected = lvar.tagfilt[lvar.tagfilt.selectednum].tag
          
          local r2 = math.floor(r/2)
          if lvar.tagfilt.offset + lvar.tagfilt.selectednum < lvar.tagfilt.offset + r2 or 
             lvar.tagfilt.offset + lvar.tagfilt.selectednum > lvar.tagfilt.offset + r2 then 
            lvar.tagfilt.offset = lvar.tagfilt.selectednum - r2
          end
          
          lvar.tagfilt.offset = F_limit(lvar.tagfilt.offset,0,#lvar.tagfilt-(r+1))
          
          lupd.update_tags = true
        end
        
      elseif c == 1885824110 then -- page down

        if #lvar.tagfilt > 0 then
          local r = math.floor((obj.sections[2002].h) / butt_h) -1
          if not lvar.tagfilt.selectednum then
            lvar.tagfilt.selectednum = lvar.tagfilt.offset
          end
          lvar.tagfilt.selectednum = math.min(lvar.tagfilt.selectednum + r,#lvar.tagfilt)
          lvar.tagfilt.selected = lvar.tagfilt[lvar.tagfilt.selectednum].tag
    
          local r2 = math.floor(r/2)
          if lvar.tagfilt.offset + lvar.tagfilt.selectednum < lvar.tagfilt.offset + r2 or 
             lvar.tagfilt.offset + lvar.tagfilt.selectednum > lvar.tagfilt.offset + r2 then 
            lvar.tagfilt.offset = lvar.tagfilt.selectednum - r2
          end
          
          lvar.tagfilt.offset = F_limit(lvar.tagfilt.offset,0,#lvar.tagfilt-(r+1))
          
          lupd.update_tags = true
        end
        
      elseif c == 30064 then -- arrow up
      
        if #lvar.tagfilt > 0 then
          local r = math.floor((obj.sections[2002].h) / butt_h) -1
          if not lvar.tagfilt.selectednum then
            lvar.tagfilt.selectednum = lvar.tagfilt.offset
          end
          lvar.tagfilt.selectednum = math.max(lvar.tagfilt.selectednum - 1,1)
          lvar.tagfilt.selected = lvar.tagfilt[lvar.tagfilt.selectednum].tag
  
          local r2 = math.floor(r/2)
          if lvar.tagfilt.offset + lvar.tagfilt.selectednum < lvar.tagfilt.offset + r2 or 
             lvar.tagfilt.offset + lvar.tagfilt.selectednum > lvar.tagfilt.offset + r2 then 
            lvar.tagfilt.offset = lvar.tagfilt.selectednum - r2
          end
          
          lvar.tagfilt.offset = math.max(F_limit(lvar.tagfilt.offset,0,#lvar.tagfilt-(r+1)),0)
  
          lupd.update_tags = true
        end
        
      elseif c == 1685026670 then -- arrow down

        if #lvar.tagfilt > 0 then
          local r = math.floor((obj.sections[2002].h) / butt_h) -1
          if not lvar.tagfilt.selectednum then
            lvar.tagfilt.selectednum = lvar.tagfilt.offset
          end
          lvar.tagfilt.selectednum = math.min(lvar.tagfilt.selectednum + 1,#lvar.tagfilt)
          lvar.tagfilt.selected = lvar.tagfilt[lvar.tagfilt.selectednum].tag
    
          local r2 = math.floor(r/2)
          if lvar.tagfilt.offset + lvar.tagfilt.selectednum < lvar.tagfilt.offset + r2 or 
             lvar.tagfilt.offset + lvar.tagfilt.selectednum > lvar.tagfilt.offset + r2 then 
            lvar.tagfilt.offset = lvar.tagfilt.selectednum - r2
          end
          
          lvar.tagfilt.offset = math.max(F_limit(lvar.tagfilt.offset,0,#lvar.tagfilt-(r+1)),0)
          
          lupd.update_tags = true
        end
        
      end

      if upfilt then
        lvar.tags.filter = string.upper(lvar.tags.filter)
        lvar.tagfilt = FilterTagData(lvar.tagdata, lvar.tags.filter)
        lupd.update_tags = true
      end
    end
    
    if gfx.mouse_wheel ~= 0 then

      local mx, my = mouse.mx, mouse.my
      mouse.mx = mx - obj.sections[2000].x
      mouse.my = my - obj.sections[2000].y
      
      if MOUSE_over(obj.sections[2002]) then
        local v = GetMW(gfx.mouse_wheel) --gfx.mouse_wheel / 120
        --local
        local r = math.floor((obj.sections[2002].h) / butt_h)
        local a = (lvar.tagfilt.offset or 0) - v*(r-1)
        local b = #lvar.tagfilt
        if a < b then
          lvar.tagfilt.offset = F_limit((lvar.tagfilt.offset or 0) - v*(r), 0, #lvar.tagfilt-(r))
        end
        lupd.update_tags = true
      end      
      
      gfx.mouse_wheel = 0
      mouse.mx, mouse.my = mx, my 
      
    end
    
    if MOUSE_click(obj.sections[2000]) or MOUSE_click_RB(obj.sections[2000]) then

      local mx, my = mouse.mx, mouse.my
      mouse.mx = mx - obj.sections[2000].x
      mouse.my = my - obj.sections[2000].y
      
      if MOUSE_click(obj.sections[2002]) then
      
        local rr = math.floor((mouse.my - obj.sections[2002].y) / butt_h) + 1
        if rr >= 1 then
          local r = rr + lvar.tagfilt.offset
          if lvar.tagfilt[r] then
            if mouse.ctrl then
              local tag = lvar.tagfilt[r].tag
              lvar.tagslots.tag = tag
              for i = 1, 32 do
                lvar.tagslots[i].selected = false
              end
              for slot in string.gmatch(lvar.tags.tags[tag].slot or '','%[(%d+)%]') do
                local slot = tonumber(slot)
                if slot then
                  lvar.tagslots[slot].selected = true
                end
              end
              
              lvar.livemode = 5
              lupd.update_gfx = true
              
            elseif mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.2 then
              lvar.tagfilt.selected = lvar.tagfilt[r].tag
              SetSelectedTrackTags(lvar.tagfilt.selected)
              lvar.livemode = 0
              lupd.update_gfx = true
              
              template = LoadFXParamTemplate(FFX)
              TemplateChanged()
            else
              lvar.tagfilt.selected = lvar.tagfilt[r].tag
              lvar.tagfilt.selectednum = r
              lupd.update_tags = true
            end
          else
            lvar.tagfilt.selected = nil
            lvar.tagfilt.selectednum = nil
            lupd.update_tags = true
          end
          
        end
        
      elseif MOUSE_click_RB(obj.sections[2002]) then

        local rr = math.floor((mouse.my - obj.sections[2002].y) / butt_h) + 1
        if rr >= 1 then
          local r = rr + lvar.tagfilt.offset
          if lvar.tagfilt[r] then
            local slottxt = 'Set Groups'
            if lvar.tags.tags[lvar.tagfilt[r].tag].slot and lvar.tags.tags[lvar.tagfilt[r].tag].slot ~= '' then
              local st = ''
              for i in string.gmatch(lvar.tags.tags[lvar.tagfilt[r].tag].slot,'%[(%d+)%]') do
                local idx = tonumber(i)
                if st ~= '' then
                  st = st .. ', '
                end
                local nm = lvar.tagslots[idx].name
                local sn = string.match(nm,'Tag grp (%d+)')
                if sn then
                  nm = sn
                end
                st = st .. nm
              end
              slottxt = 'Groups: '..st
            end
            local mstr = '#Tag: '..lvar.tagfilt[r].tag..'||Rename||Delete||'..slottxt
            gfx.x, gfx.y = mx, my
            local res = gfx.showmenu(mstr)
            if res > 0 then
              if res == 2 then
                local tag = lvar.tagfilt[r].tag
                local ret, ntag = reaper.GetUserInputs('Rename Tag: '..tag, 1, 'Enter New Tag Name:', tag)
                if ret and ntag ~= '' then
                  RenameTag(tag, ntag)
                  
                  lvar.tags.filter = ''
                                      
                  lvar.tagdata = GetTagData()
                  lvar.tagfilt = FilterTagData(lvar.tagdata, lvar.tags.filter)
                  
                  lupd.update_gfx = true

                end
              elseif res == 3 then
                local tag = lvar.tagfilt[r].tag
                local res = reaper.MB('Delete tag?','Delete Tag',4)
                if res == 6 then
                  DeleteTag(tag)

                  lvar.tags.filter = ''
                                      
                  lvar.tagdata = GetTagData()
                  lvar.tagfilt = FilterTagData(lvar.tagdata, lvar.tags.filter)
                  
                  lupd.update_gfx = true
                  
                  template = LoadFXParamTemplate(FFX)
                  TemplateChanged()
                  
                end

              elseif res == 4 then
                local tag = lvar.tagfilt[r].tag
                lvar.tagslots.tag = tag
                for i = 1, 32 do
                  lvar.tagslots[i].selected = false
                end
                for slot in string.gmatch(lvar.tags.tags[tag].slot or '','%[(%d+)%]') do
                  local slot = tonumber(slot)
                  if slot then
                    lvar.tagslots[slot].selected = true
                  end
                end
                
                lvar.livemode = 5
                lupd.update_gfx = true
              
              end
            end
            
          end
        end        
        --lvar.livemode = 0
        --lupd.update_gfx = true
      end
      
      mouse.mx, mouse.my = mx, my 
      
    elseif MOUSE_click(obj.sections[110]) or MOUSE_click_RB(obj.sections[110]) then
      lvar.livemode = 0
      lupd.update_gfx = true
    end

    
  end
  
  function ARun_Colors()

    --local showmenu  
        
    if mouse.context == nil then

      if MOUSE_over(obj.sections[200]) then
        local y = math.floor((mouse.my - (obj.sections[200].y + 20)) / (lvar.colorsel_btnsize + lvar.colorsel_btnsize_spacer))+1
        local m = (mouse.my - (obj.sections[200].y + 20)) % (lvar.colorsel_btnsize + lvar.colorsel_btnsize_spacer)
        if lvar.colordesc_l[y] and m <= lvar.colorsel_btnsize then
          if lvar.colordesc_disp ~= lvar.colordesc_l[y] then
            lvar.colordesc_disp = lvar.colordesc_l[y]
            lupd.update_gfx = true
          end
        else
          lvar.colordesc_disp = nil
        end

      elseif MOUSE_over(obj.sections[202]) then
        local y = math.floor((mouse.my - (obj.sections[200].y + 20)) / (lvar.colorsel_btnsize + lvar.colorsel_btnsize_spacer))+1
        local m = (mouse.my - (obj.sections[200].y + 20)) % (lvar.colorsel_btnsize + lvar.colorsel_btnsize_spacer)
        if lvar.colordesc_r[y] and m <= lvar.colorsel_btnsize then
          if lvar.colordesc_disp ~= lvar.colordesc_r[y] then
            lvar.colordesc_disp = lvar.colordesc_r[y]
            lupd.update_gfx = true
          end
        else
          lvar.colordesc_disp = nil
        end

      else
        lvar.colordesc_disp = nil
      end
      
      if MOUSE_click(obj.sections[200]) then
      
        local y = math.floor((mouse.my - (obj.sections[200].y + 20)) / (lvar.colorsel_btnsize + lvar.colorsel_btnsize_spacer))+1
        local m = (mouse.my - (obj.sections[200].y + 20)) % (lvar.colorsel_btnsize + lvar.colorsel_btnsize_spacer)
        if y <= #ptype_info + 10 and m <= lvar.colorsel_btnsize then
        
          if y <= #ptype_info then
          
            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(ptype_info[y].col))
            if ret ~= 0 then            
              ptype_info[y].col = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+1 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.mainfader))
            if ret ~= 0 then            
              colours.mainfader = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+2 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.layerfader))
            if ret ~= 0 then            
              colours.layerfader = ConvertColor(col)
              lupd.update_gfx = true            
            end
          
          elseif y == #ptype_info+3 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.globalfader))
            if ret ~= 0 then            
              colours.globalfader = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+4 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.permafader))
            if ret ~= 0 then            
              colours.permafader = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+5 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.faderunassigned))
            if ret ~= 0 then            
              colours.faderunassigned = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+6 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.mainbg))
            if ret ~= 0 then            
              colours.mainbg = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+7 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.buttcol))
            if ret ~= 0 then            
              colours.buttcol = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+8 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.devctlunassigned))
            if ret ~= 0 then            
              colours.devctlunassigned = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+9 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.devctlassigned))
            if ret ~= 0 then            
              colours.devctlassigned = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+10 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.faderbg2))
            if ret ~= 0 then            
              colours.faderbg2 = ConvertColor(col)
              lupd.update_gfx = true            
            end
          
          --[[elseif y == #ptype_info+10 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.ibox))
            if ret ~= 0 then            
              colours.ibox = ConvertColor(col)
              lupd.update_gfx = true            
            end]]
            
          end
          --DBG(y)
          SetUnlitFaderCols(0.4)  
          --PType_SetCols()
          
        end

      elseif MOUSE_click_RB(obj.sections[200]) then
      
        local y = math.floor((mouse.my - (obj.sections[200].y + 20)) / (lvar.colorsel_btnsize + lvar.colorsel_btnsize_spacer))+1
        local m = (mouse.my - (obj.sections[200].y + 20)) % (lvar.colorsel_btnsize + lvar.colorsel_btnsize_spacer)
        if y <= #ptype_info + 10 and m <= lvar.colorsel_btnsize then
        
          if y <= #ptype_info then
          
            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(ptype_info[y].btntxt))
            if ret ~= 0 then            
              ptype_info[y].btntxt = ConvertColor(col)
              lupd.update_gfx = true            
            end
          
          elseif y == #ptype_info+1 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.mainfader_txt))
            if ret ~= 0 then            
              colours.mainfader_txt = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+2 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.layerfader_txt))
            if ret ~= 0 then            
              colours.layerfader_txt = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+3 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.globalfader_txt))
            if ret ~= 0 then            
              colours.globalfader_txt = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+4 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.permafader_txt))
            if ret ~= 0 then            
              colours.permafader_txt = ConvertColor(col)
              lupd.update_gfx = true            
            end
          
          elseif y == #ptype_info+5 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.faderunassigned_txt))
            if ret ~= 0 then            
              colours.faderunassigned_txt = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+7 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.buttcollit))
            if ret ~= 0 then            
              colours.buttcollit = ConvertColor(col)
              colours.modebtnhl = ConvertColor(col)
              lupd.update_gfx = true            
            end
          
          elseif y == #ptype_info+8 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.devctlname))
            if ret ~= 0 then            
              colours.devctlname = ConvertColor(col)
              lupd.update_gfx = true            
            end

          elseif y == #ptype_info+10 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.faderborder))
            if ret ~= 0 then            
              colours.faderborder = ConvertColor(col)
              lupd.update_gfx = true            
            end

          --[[elseif y == #ptype_info+10 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.iboxT))
            if ret ~= 0 then            
              colours.iboxT = ConvertColor(col)
              tab_amcol[1] = ConvertColor(col)
              tab_amcol[2] = ConvertColor(col)
              lupd.update_gfx = true            
            end]]
          
          end
        
        end
        
      elseif MOUSE_click(obj.sections[202]) then
      
        --right side
        
        local y = math.floor((mouse.my - (obj.sections[200].y + 20)) / (lvar.colorsel_btnsize + lvar.colorsel_btnsize_spacer))+1
        local m = (mouse.my - (obj.sections[200].y + 20)) % (lvar.colorsel_btnsize + lvar.colorsel_btnsize_spacer)
      
        if y <= 7 and m <= lvar.colorsel_btnsize then  
          if y == 1 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.ibox))
            if ret ~= 0 then            
              colours.ibox = ConvertColor(col)
              lupd.update_gfx = true            
            end
          
          elseif y == 2 then
            
            local res = FaderColor_Menu2(mouse.mx, mouse.my, lvar.ss_color_override_color, true)
            if res then
              if res <= 8 then
                lvar.ss_color_override_color = res-1
              end
            end
            
          elseif y == 3 then

            local res = FaderColor_Menu2(mouse.mx, mouse.my, lvar.ss_color_override_nonautomatable_color, true)
            if res then
              if res <= 8 then
                lvar.ss_color_override_nonautomatable_color = res-1
              end
            end

          elseif y == 4 then
          
            local res = FaderColor_Menu2(mouse.mx, mouse.my, lvar.rec_automap_color_vol, true)
            if res then
              if res <= 8 then
                lvar.rec_automap_color_vol = res-1
              end
            end
          
          elseif y == 5 then
          
            local res = FaderColor_Menu2(mouse.mx, mouse.my, lvar.rec_automap_color_pan, true)
            if res then
              if res <= 8 then
                lvar.rec_automap_color_pan = res-1
              end
            end
          
          elseif y == 6 then
          
            local res = FaderColor_Menu2(mouse.mx, mouse.my, lvar.rec_automap_color_mute, true)
            if res then
              if res <= 8 then
                lvar.rec_automap_color_mute = res-1
              end
            end
          
          elseif y == 7 then
          
            local res = FaderColor_Menu2(mouse.mx, mouse.my, lvar.rec_automap_color_plug, true)
            if res then
              if res <= 8 then
                lvar.rec_automap_color_plug = res-1
              end
            end
          
          end
        end
        
      elseif MOUSE_click_RB(obj.sections[202]) then
      
        local y = math.floor((mouse.my - (obj.sections[200].y + 20)) / (lvar.colorsel_btnsize + lvar.colorsel_btnsize_spacer))+1
        local m = (mouse.my - (obj.sections[200].y + 20)) % (lvar.colorsel_btnsize + lvar.colorsel_btnsize_spacer)
      
        if y <= 7 and m <= lvar.colorsel_btnsize then  
          if y == 1 then

            local ret, col = reaper.GR_SelectColor(_,ConvertColorString(colours.iboxT))
            if ret ~= 0 then            
              colours.iboxT = ConvertColor(col)
              tab_amcol[1] = ConvertColor(col)
              tab_amcol[2] = ConvertColor(col)
              lupd.update_gfx = true            
            end

          end

        end
      
      elseif MOUSE_click(obj.sections[110]) then
        lvar.livemode = 0
        lupd.update_gfx = true
        
        SaveColors()
      end
    end
    
  end
  
  function SaveColors(savefn)
  
    local fn = savefn or (paths.resource_path..'colors.txt')
    file=io.open(fn,"w")
    for i = 1, #ptype_info do
      local key = '['..string.format('%i',i)..']'
      file:write(key..ptype_info[i].col..'\n')
      local key = '['..string.format('%i',i)..'T]'
      file:write(key..ptype_info[i].btntxt..'\n')
    end
    file:write('[faderunassigned]'..colours.faderunassigned..'\n')
    file:write('[faderunassignedT]'..colours.faderunassigned_txt..'\n')
    file:write('[globalfader]'..colours.globalfader..'\n')
    file:write('[globalfaderT]'..colours.globalfader_txt..'\n')
    file:write('[permafader]'..colours.permafader..'\n')
    file:write('[permafaderT]'..colours.permafader_txt..'\n')
    file:write('[layerfader]'..colours.layerfader..'\n')
    file:write('[layerfaderT]'..colours.layerfader_txt..'\n')
    file:write('[mainfader]'..colours.mainfader..'\n')
    file:write('[mainfaderT]'..colours.mainfader_txt..'\n')
    file:write('[mainbg]'..colours.mainbg..'\n')
    file:write('[buttcol]'..colours.buttcol..'\n')
    file:write('[buttcollit]'..colours.buttcollit..'\n')
    file:write('[devctlunassigned]'..colours.devctlunassigned..'\n')
    file:write('[devctlassigned]'..colours.devctlassigned..'\n')
    file:write('[devctlname]'..colours.devctlname..'\n')
    file:write('[faderbg2]'..colours.faderbg2..'\n')
    file:write('[faderborder]'..colours.faderborder..'\n')
    file:write('[ibox]'..colours.ibox..'\n')
    file:write('[iboxT]'..colours.iboxT..'\n')
    
    file:close()
    
  end
  
  function LoadColors()
  
    local fn = paths.resource_path..'colors.txt'
    if reaper.file_exists(fn) then
    
      data = {}
      for line in io.lines(fn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          val = string.gsub(val, '[\r]', '') --Remove \r for Mac use
          data[idx] = val
        end
      end
    
      for i = 1, #ptype_info do
        local key = string.format('%i',i)
        if data[key] then
          ptype_info[i].col = data[key]
        end
        if data[key..'T'] then
          ptype_info[i].btntxt = data[key..'T']
        end
      end
      local c = data['globalfader']
      if c then
        colours.globalfader = c
      end
      local c = data['globalfaderT']
      if c then
        colours.globalfader_txt = c
      end

      local c = data['permafader']
      if c then
        colours.permafader = c
      end
      local c = data['permafaderT']
      if c then
        colours.permafader_txt = c
      end

      local c = data['layerfader']
      if c then
        colours.layerfader = c
      end
      local c = data['layerfaderT']
      if c then
        colours.layerfader_txt = c
      end

      local c = data['mainfader']
      if c then
        colours.mainfader = c
      end
      local c = data['mainfaderT']
      if c then
        colours.mainfader_txt = c
      end

      local c = data['mainbg']
      if c then
        colours.mainbg = c
      end

      local c = data['buttcol']
      if c then
        colours.buttcol = c
      end
      local c = data['buttcollit']
      if c then
        colours.buttcollit = c
        colours.modebtnhl = c
      end

      local c = data['devctlunassigned']
      if c then
        colours.devctlunassigned = c
      end
      local c = data['devctlname']
      if c then
        colours.devctlname = c
      end
      local c = data['devctlassigned']
      if c then
        colours.devctlassigned = c
      end

      local c = data['faderunassigned']
      if c then
        colours.faderunassigned = c
      end
      local c = data['faderunassignedT']
      if c then
        colours.faderunassigned_txt = c
      end
      local c = data['faderbg2']
      if c then
        colours.faderbg2 = c
      end
      local c = data['faderborder']
      if c then
        colours.faderborder = c
      end
      local c = data['ibox']
      if c then
        colours.ibox = c
      end
      local c = data['iboxT']
      if c then
        colours.iboxT = c
        tab_amcol[1] = c
        tab_amcol[2] = c
      end
        
    end
  
  end
  
  ------------------------------------------------------------    
  function ARun_SetUp()
    
    if lvar.midifilteredit then
      if gfx.mouse_wheel ~= 0 then
        local mx, my = mouse.mx, mouse.my
        mouse.mx = mx - obj.sections[10000].x
        mouse.my = my - obj.sections[10000].y

        if MOUSE_over(obj.sections[10008]) then
          local v = GetMW(gfx.mouse_wheel) --gfx.mouse_wheel / 120
          --local 
          lvar.midifilter_ccoffs = F_limit(lvar.midifilter_ccoffs - v*8, 0, 120)
          lupd.update_gfx = true
        end      
        
        gfx.mouse_wheel = 0
        mouse.mx, mouse.my = mx, my 
      end
      
      if MOUSE_click(obj.sections[10000]) or MOUSE_click_RB(obj.sections[10000]) then
        
        local mx, my = mouse.mx, mouse.my
        mouse.mx = mx - obj.sections[10000].x
        mouse.my = my - obj.sections[10000].y
        
        if MOUSE_click(obj.sections[10002]) then

          lvar.midiinput_filt[lvar.midifilteredit].all_cc = 1-lvar.midiinput_filt[lvar.midifilteredit].all_cc 
          lupd.update_gfx = true
        
        elseif MOUSE_click(obj.sections[10003]) then

          lvar.midiinput_filt[lvar.midifilteredit].pb = 1-lvar.midiinput_filt[lvar.midifilteredit].pb 
          lupd.update_gfx = true

        elseif MOUSE_click(obj.sections[10004]) then

          lvar.midiinput_filt[lvar.midifilteredit].pc = 1-lvar.midiinput_filt[lvar.midifilteredit].pc 
          lupd.update_gfx = true
        
        elseif MOUSE_click(obj.sections[10005]) then
        
          lvar.midiinput_filt[lvar.midifilteredit].sysx = 1-lvar.midiinput_filt[lvar.midifilteredit].sysx 
          lupd.update_gfx = true
        
        elseif MOUSE_click(obj.sections[10006]) then
        
          lvar.midiinput_filt[lvar.midifilteredit].at_poly = 1-lvar.midiinput_filt[lvar.midifilteredit].at_poly 
          lupd.update_gfx = true
        
        elseif MOUSE_click(obj.sections[10007]) then
        
          lvar.midiinput_filt[lvar.midifilteredit].at_chan = 1-lvar.midiinput_filt[lvar.midifilteredit].at_chan 
          lupd.update_gfx = true
        
        elseif MOUSE_click(obj.sections[10008]) then
        
          local clx = math.floor((mouse.mx - obj.sections[10008].x) / obj.sections[10008].cw)
          local cly = math.floor((mouse.my - obj.sections[10008].y) / obj.sections[10008].ch)
          
          local cc = clx + cly*8 + lvar.midifilter_ccoffs
          if cc >= 0 and cc <= 127 then
          
            lvar.midiinput_filt[lvar.midifilteredit].ccs[cc] = 1-(lvar.midiinput_filt[lvar.midifilteredit].ccs[cc] or 0)
            lupd.update_gfx = true
          end
        
        elseif MOUSE_click_RB(obj.sections[10008]) then
        
          local mstr = 'Clear All||Select All'
          gfx.x = mx
          gfx.y = my
          local res = gfx.showmenu(mstr)
          if res > 0 then
          
            if res == 1 then
              for i = 0, 127 do
                lvar.midiinput_filt[lvar.midifilteredit].ccs[i] = nil
              end
              lupd.update_gfx = true
            elseif res == 2 then
              for i = 0, 127 do
                lvar.midiinput_filt[lvar.midifilteredit].ccs[i] = 1
              end
              lupd.update_gfx = true
            end
          
          end
        
        end
      
        mouse.mx, mouse.my = mx, my
        
      elseif MOUSE_click(obj.sections[110]) or MOUSE_click_RB(obj.sections[110]) then
        lvar.midiinput_filt[lvar.midifilteredit].active = true
        lvar.midifilteredit = nil
        lupd.update_gfx = true
      end
    
    else
      if mouse.context == nil then    
        local my = mouse.my
        mouse.my = mouse.my - lvar.SetupOffs
        
        if gfx.mouse_wheel ~= 0 then
          if lvar.SetUpMW_DragTimer and lvar.SetUpMW_DragTimer < reaper.time_precise() then
            lvar.SetUpMW_DragTimer = nil
          end
          if MOUSE_over(obj.sections[101]) and not lvar.SetUpMW_DragTimer then
            local v = GetMW(gfx.mouse_wheel) --gfx.mouse_wheel/120
            lvar.MIoffs = F_limit(lvar.MIoffs-v,0,math.max(#mididevices.input-8,0))
            gfx.mouse_wheel = 0
            lupd.update_gfx = true
          elseif MOUSE_over(obj.sections[102]) and not lvar.SetUpMW_DragTimer then
            local v = GetMW(gfx.mouse_wheel) --gfx.mouse_wheel/120
            lvar.MOoffs = F_limit(lvar.MOoffs-v,0,math.max(#mididevices.output-8,0))
            gfx.mouse_wheel = 0
            lupd.update_gfx = true
          else
            local v = GetMW(gfx.mouse_wheel) * 50 --(gfx.mouse_wheel/120) * 50
            local dy = lvar.SetupOffs + v
            local max = math.min(gfx1.main_h-(obj.sections[100].y + obj.sections[100].h + 30),0)
            lvar.SetupOffs = F_limit(dy,max,0)
            lvar.SetUpMW_DragTimer = reaper.time_precise() + 1
            lupd.update_gfx = true
          end
        end
        
        if MOUSE_click(obj.sections[100]) then
        
          lvar.showsetup = nil
          lvar.livemode = 0
          
          local ret
          GetFFX(true)
          --[[FFX, ret = GetFocusedFX(true)
          if ret == 1 and FFX then
            track = GetTrack(FFX.trn)
          end]]
          lupd.update_gfx = true
        
        elseif MOUSE_click(obj.sections[124]) and lvar.enablegroupinputs then
          settings.groupinputs = not settings.groupinputs
          lupd.update_gfx = true
        
        elseif MOUSE_click(obj.sections[126]) then
          local name = 'GLOBAL FILTER'
          if lvar.midiinput_filt[name] then
            lvar.midiinput_filt[name].active = not lvar.midiinput_filt[name].active
          end
          lupd.update_gfx = true
          
        elseif MOUSE_click_RB(obj.sections[126]) then  
          local name = 'GLOBAL FILTER'
          if not lvar.midiinput_filt[name] then
            lvar.midiinput_filt[name] = DefFilter()
          end
          lvar.midifilteredit = name
          lupd.update_gfx = true
          
        elseif MOUSE_click_RB(obj.sections[101]) then
          local p = math.floor((mouse.my - obj.sections[101].y) / (butt_h-8)) + 1
          if mididevices.input[p+lvar.MIoffs] then
            local name = mididevices.input[p+lvar.MIoffs].name
            local bus, skip
            if mouse.mx - obj.sections[101].x > obj.sections[101].x+obj.sections[101].w - 54 then
              
              if lvar.midiinput_ctl[name] or lvar.midiinput_gen[name] then
                skip = true
                if not lvar.midiinput_filt[name] then
                  lvar.midiinput_filt[name] = DefFilter()
                end
                lvar.midifilteredit = name
              end
              
            elseif mouse.mx - obj.sections[101].x > obj.sections[101].x+obj.sections[101].w - 94 then
              if lvar.midiinput_ctl[name] then
                bus = lvar.midiinput_ctl[name].bus - 1
                if bus < 0 then bus = 3 end
              end          
            end
            if not skip then
              if bus then
                if lvar.midiinput_ctl[name] then
                  lvar.midiinput_ctl[name].bus = bus
                end                    
              else
                if not lvar.midiinput_gen[name] then
                  lvar.midiinput_gen[name] = mididevices.input[p+lvar.MIoffs].dev
                  lvar.midiinput_ctl[name] = nil
                else
                  lvar.midiinput_gen[name] = nil
                end
              end
            end
            lupd.update_gfx = true
          end
  
        elseif MOUSE_click(obj.sections[101]) then
          local p = math.floor((mouse.my - obj.sections[101].y) / (butt_h-8)) + 1
          if mididevices.input[p+lvar.MIoffs] then 
            local name = mididevices.input[p+lvar.MIoffs].name
            local bus, skip
            if mouse.mx - obj.sections[101].x > obj.sections[101].x+obj.sections[101].w - 54 then
              --midi filter click
              if lvar.midiinput_ctl[name] then
                skip = true
                if lvar.midiinput_filt[name] then
                  lvar.midiinput_filt[name].active = not lvar.midiinput_filt[name].active
                end
              elseif lvar.midiinput_gen[name] then  
                skip = true
                if lvar.midiinput_filt[name] then
                  lvar.midiinput_filt[name].active = not lvar.midiinput_filt[name].active
                end
              end
            elseif mouse.mx - obj.sections[101].x > obj.sections[101].x+obj.sections[101].w - 94 then
              if lvar.midiinput_ctl[name] then
                bus = lvar.midiinput_ctl[name].bus + 1
                if bus > 3 then bus = 0 end
              end          
            end
            
            if not skip then
              if bus then
                if lvar.midiinput_ctl[name] then
                  lvar.midiinput_ctl[name].bus = bus
                end          
              else
                if not lvar.midiinput_ctl[name] then
                  lvar.midiinput_ctl[name] = {dev = mididevices.input[p+lvar.MIoffs].dev,
                                              bus = 0}
                  lvar.midiinput_gen[name] = nil
                else
                  lvar.midiinput_ctl[name] = nil
                end          
              end
            end
            lupd.update_gfx = true
          end
  
        elseif MOUSE_click(obj.sections[102]) or MOUSE_click_RB(obj.sections[102]) then
          local p = math.floor((mouse.my - obj.sections[102].y) / (butt_h-8)) + 1
          if mididevices.output[p+lvar.MOoffs] then
            local name = mididevices.output[p+lvar.MOoffs].name
            local bus
            if mouse.mx - obj.sections[102].x > obj.sections[102].x+obj.sections[102].w - 54 then
              if lvar.midioutput_ctl[name] then 
                if mouse.LB then
                  bus = lvar.midioutput_ctl[name].bus + 1
                  if bus > 3 then bus = 0 end
                else
                  bus = lvar.midioutput_ctl[name].bus - 1
                  if bus < 0 then bus = 3 end              
                end
              end          
            end
   
            if bus then
              if lvar.midioutput_ctl[name] then
                lvar.midioutput_ctl[name].bus = bus
              end          
            else
              if not lvar.midioutput_ctl[name] then
                lvar.midioutput_ctl[name] = {dev = mididevices.output[p+lvar.MOoffs].dev,
                                             bus = 0}
              else
                lvar.midioutput_ctl[name] = nil
              end          
            end
            lupd.update_gfx = true
          end
  
        elseif MOUSE_click(obj.sections[120]) then
        
          MIDIMapMenu(mouse.mx,my,1)
  
        elseif MOUSE_click(obj.sections[121]) then
        
          MIDIMapMenu(mouse.mx,my,2)
  
        elseif MOUSE_click(obj.sections[122]) then
        
          MIDIMapMenu(mouse.mx,my,3)
  
        elseif MOUSE_click(obj.sections[123]) then
        
          MIDIMapMenu(mouse.mx,my,4)
  
        elseif MOUSE_click(obj.sections[125]) then
        
          MIDIOutMenu(mouse.mx,my,4)      
        
        elseif MOUSE_click(obj.sections[104]) then
  
          --FaderCntMenu(mouse.mx,my)
  
        elseif MOUSE_click(obj.sections[106]) then
  
          settings.rrmode = not nz(settings.rrmode,false)
          lupd.update_gfx = true
  
        --[[elseif MOUSE_click(obj.sections[107]) then
  
          settings.ccsend = not nz(settings.ccsend,false)
          lupd.update_gfx = true]]
  
        elseif MOUSE_click(obj.sections[109]) then
  
          settings.sort = not nz(settings.sort,false)
          lupd.update_gfx = true
  
        elseif MOUSE_click(obj.sections[108]) then
  
          settings.hidectltrack = not nz(settings.hidectltrack,false)
          lupd.update_gfx = true
  
        elseif MOUSE_click(obj.sections[113]) then
  
          settings.liveccfb = not nz(settings.liveccfb,false)
          if settings.liveccfb == true then
            lvar.fbcconseek = lvar.ofbos or true
          else
            lvar.ofbos = lvar.fbcconseek
            lvar.fbcconseek = true
          end
          lupd.update_gfx = true
          
        --elseif MOUSE_click(obj.sections[111]) then
  
          --lvar.createsends = not nz(lvar.createsends,false)
          --lupd.update_gfx = true
  
        elseif MOUSE_click(obj.sections[112]) then
          
          local ret, df = reaper.GetUserInputs('Dummy Faders',1,'Number of dummy faders:',lvar.dummyfaders)
          if ret and tonumber(df) then
            lvar.dummyfaders = math.min(tonumber(df),256)
            lupd.update_gfx = true
          end
          
        elseif MOUSE_click(obj.sections[105]) then
        
          CreateSetUp()
          lvar.showsetup = nil
          lvar.livemode = 0
          lvar.initstage = 1
          lupd.update_gfx = true
        
        elseif MOUSE_clickX(obj.sections[999], mouse.mx, my) then
        
          lvar.hlsb = true
          mouse.context = contexts.vscrollb
          lvar.vscrollb = {my = my, pos = lvar.SetupOffs}
          --lvar.vscrollb_pos = lvar.SetupOffs
          drag = my
          
          lupd.update_gfx = true
        
        elseif MOUSE_click(obj.sections[110]) then
        
          mouse.context = contexts.setupdrag
          drag = mouse.my
  
        elseif MOUSE_click_RB(obj.sections[110]) then
          
          if recmode == 0 then
            --[[lvar.showsetup = nil
            lvar.livemode = 0
            FFX, ret = GetFocusedFX(true, FFX)
            if ret == 1 and FFX then
              track = GetTrack(FFX.trn)
            end]]
            lvar.showsetup = nil
            lvar.livemode = 0
            
            local ret
            GetFFX(true)
            lupd.update_gfx = true
          end
          
          lupd.update_gfx = true
        
        elseif MOUSE_overX(obj.sections[999], mouse.mx, my) then
          if not lvar.hlsb then
            lvar.hlsb = true
            lupd.update_gfx = true
          end
        
        elseif lvar.hlsb then
          lvar.hlsb = nil
          lupd.update_gfx = true
        end
        
        mouse.my = my
      else
        --mouse context
        if mouse.context == contexts.setupdrag then
        
          local dy = mouse.my - drag
          local max = math.min(gfx1.main_h-(obj.sections[100].y + obj.sections[100].h + 30),0)
          lvar.SetupOffs = F_limit(dy,max,0)
          lupd.update_gfx = true
          
        elseif mouse.context == contexts.vscrollb then
          local dy = drag - mouse.my
          local swh = (obj.sections[100].y + obj.sections[100].h + 30)
          local mult = swh/gfx1.main_h
          local max = math.min(gfx1.main_h-swh,0)
          lvar.SetupOffs = math.floor(F_limit(lvar.vscrollb.pos + dy*mult,max,0))
          lupd.update_gfx = true
        
        end
      end
    end
  end
  
  function GetTracks()
  
    local tmp = {}
    local trcnt = reaper.CountTracks(0)
    for t = 0, trcnt do
      local tr = GetTrack(t)
      tmp[t] = reaper.GetTrackState(tr)
    end
    tmp.count = trcnt
    return tmp
    
  end

  function FindTrack(trnm)
  
    local trn
    local trcnt = reaper.CountTracks(0)
    for t = 0, trcnt do
      local tr = GetTrack(t)
      if reaper.GetTrackState(tr) == trnm then
        trn = t
        break
      end
    end
    return trn
    
  end
  
  function SetSoloDefeat(track)
  
    local ret, chunk = reaper.GetTrackStateChunk(track,'',false)
    if ret then
      chunk = string.gsub(chunk, 'MUTESOLO 0 0 0', 'MUTESOLO 0 0 1')
      reaper.SetTrackStateChunk(track,chunk,false)
    end
      
  end
  
  function DeleteCtlTracks()
  
    reaper.Main_OnCommand(40297,0)
    --local t = GetTrack2(LBX_FOL_TRACK)
    --if t then reaper.SetTrackSelected(t, true) end
    local t = GetTrack2(LBX_CTL_TRACK)
    if t then reaper.SetTrackSelected(t, true) end
    local t = GetTrack2(LBX_CC_TRACK)
    if t then reaper.SetTrackSelected(t, true) end
    local t = GetTrack2(LBX_RR_TRACK)
    if t then reaper.SetTrackSelected(t, true) end
    local t = GetTrackByName('LBX_ForRetroRec(MIDI)')
    if t then reaper.SetTrackSelected(t, true) end
    local t = GetTrack2(LBX_IN_TRACK)
    if t then reaper.SetTrackSelected(t, true) end
    for i = 1, #LBX_INPUT_TRACKS do
      local t = GetTrack2(LBX_INPUT_TRACKS[i])
      if t then reaper.SetTrackSelected(t, true) end  
    end
    for i = 1, #LBX_INPUTCC_TRACKS do
      local t = GetTrack2(LBX_INPUTCC_TRACKS[i])
      if t then reaper.SetTrackSelected(t, true) end  
    end
    for i = 1, #LBX_OUT_TRACKS do
      local t = GetTrack2(LBX_OUT_TRACKS[i])
      if t then reaper.SetTrackSelected(t, true) end  
    end
    reaper.Main_OnCommand(40005,0)
    
  end
  
  function CreateSetUp()
  
    --[[local tr = GetTrack(1)
    DBG(reaper.GetTrackState(tr))
    DBG(reaper.GetMediaTrackInfo_Value(tr,'I_RECINPUT'))]]
  
    --GUI_DrawMsg(obj, gui, {'Creating Control Tracks', '', 'Please Wait...',''})
  
    reaper.Undo_BeginBlock2(0)
  
    reaper.PreventUIRefresh(1)
    
    SaveDefCCs()
    SaveSetUp('lastused')
    
    --VALIDATE
    if (lvar.enablegroupinputs and settings.groupinputs and lvar.midiloopbackdev) then
      --reaper.PreventUIRefresh(-1)
      reaper.MB('Warning - You cannot have grouped inputs with a midi loopback device.  You will get unwanted midi feedback.',
                'Set up error',
                0)
              
      --return
    end
    
    FFX = nil
    ofxguid = nil
    template = {dirty = {},
                pos = {},
                sft = {},
                eft = {}}
                
    --Delete existing setup
    --local tracks = GetTracks()
        
    --[[for t = tracks.count, 0, -1 do
      if tracks[t] == LBX_CTL_TRNAME or tracks[t] == LBX_CC_TRNAME or tracks[t] == LBX_IN_TRNAME or
         string.match(tracks[t], 'SK_IN_') or string.match(tracks[t], 'SKCC_IN_') or string.match(tracks[t], '__LBX_OUT_') or 
         tracks[t] == LBX_RR_TRNAME or tracks[t] == LBX_TOUCH_TRNAME then
        local tr = GetTrack(t)
        reaper.DeleteTrack(tr)
      end
    end]]
    --store selected tracks
    reaper.Main_OnCommand(reaper.NamedCommandLookup('_SWS_SAVESEL'), 0)
    
    DeleteCtlTracks()
    
    reaper.Main_OnCommand(reaper.NamedCommandLookup('_SWS_RESTORESEL'), 0)

    LBX_CC_TRACK = nil
    LBX_CC_TRACK_GUID = nil
    LBX_CTL_TRACK = nil
    LBX_CTL_TRACK_GUID = nil
    LBX_RR_TRACK = nil
    LBX_RR_TRACK_GUID = nil
    LBX_IN_TRACK = nil
    LBX_IN_TRACK_GUID = nil
    LBX_INPUT_TRACKS = nil
    LBX_INPUT_TRACK_GUID = nil
    LBX_INPUTCC_TRACKS = nil
    LBX_INPUTCC_TRACK_GUID = nil
    LBX_OUT_TRACKS = nil
    LBX_OUT_TRACK_GUID = nil
    
    --Create new setup    

    --Other inputs
    local others = false
    if lvar.enablegroupinputs and settings.groupinputs then
      others = true
    else
      for a, b in pairs(lvar.midiinput_gen) do
        if a then
          others = true
          break
        end
      end
    end

    local lbxfolderfound = false
    local lbxfolder = FindTrack('LBX')
    if lbxfolder then
      --lbxfolder = lbxfolder
      lbxfolderfound = true
      local tr = GetTrack(lbxfolder)
      reaper.SetMediaTrackInfo_Value(tr,'B_MAINSEND',0)
      reaper.SetMediaTrackInfo_Value(tr,'D_VOL',0)
      reaper.SetMediaTrackInfo_Value(tr,'I_AUTOMODE',0)
      if settings.hidectltrack then
        reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINTCP',0)
        reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINMIXER',0)
      end
    else
      --create folder track at end
      local lt = reaper.GetNumTracks()
      reaper.InsertTrackAtIndex(lt, false)
      local tr = GetTrack(lt+1)
      reaper.GetSetMediaTrackInfo_String(tr, "P_NAME", LBX_FOL_TRNAME, true)
      reaper.SetMediaTrackInfo_Value(tr,'B_MAINSEND',0)
      reaper.SetMediaTrackInfo_Value(tr,'D_VOL',0)      
      reaper.SetMediaTrackInfo_Value(tr,'I_AUTOMODE',0)      
      lbxfolder = lt+1
      lbxfolderfound = true
      if settings.hidectltrack then
        reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINTCP',0)
        reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINMIXER',0)
      end
    end
    
    local tcnt = 0
    
    lvar.tracks = {inst_in = 0,
                   rr = 0,
                   skcc_in = 0,
                   out = 0,
                   tot = 16}
        
    local othtr

--DBG(tostring(lbxfolder)..'  '..tostring(lbxfolderfound))   
--DBG(reaper.GetNumTracks())
--if true then return end
    
    if others == true then
      
      local tr
      reaper.InsertTrackAtIndex(lbxfolder, false)
      tcnt=tcnt+1
      tr = GetTrack(lbxfolder+1)
      reaper.GetSetMediaTrackInfo_String(tr, "P_NAME", LBX_IN_TRNAME, true)
      reaper.SetMediaTrackInfo_Value(tr,'I_FOLDERDEPTH',1)
      reaper.SetMediaTrackInfo_Value(tr,'B_MAINSEND',0) 
      reaper.SetMediaTrackInfo_Value(tr,'D_VOL',0)
      reaper.SetMediaTrackInfo_Value(tr,'I_AUTOMODE',0)                  
      if settings.hidectltrack then
        reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINTCP',0)
        reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINMIXER',0)
      end

      if lvar.midiloopbackdev then
        --create loopback out
        if mididevices.outidx[lvar.midiloopbackdev] then
          local idx = mididevices.outidx2[lvar.midiloopbackdev]
          if mididevices.output[idx] then
            local dev = (mididevices.output[mididevices.outidx2[lvar.midiloopbackdev]].dev << 5)
            reaper.SetMediaTrackInfo_Value(tr, 'I_MIDIHWOUT', dev)
          else
            DBG('Loopback device not found')
          end
        end
        --create rr track
        othtr = tr
      end

      --midi filter
      local a = 'GLOBAL FILTER'
      reaper.gmem_attach('LBX_MF_SharedMem')
      local gmem = reaper.gmem_write
      gmem(255, 0)
      reaper.gmem_attach('LBX_SK2_SharedMem')

      if lvar.midiinput_filt and lvar.midiinput_filt[a] and lvar.midiinput_filt[a].active then
        local filttab = lvar.midiinput_filt[a]
        local f = reaper.TrackFX_AddByName(tr, 'JS:LBX-MidiFilter', false, -1)
        if f >= 0 then
          reaper.TrackFX_Show(tr, f, 2)
        end
        
        reaper.gmem_attach('LBX_MF_SharedMem')
        while reaper.gmem_read(255) ~= 0 do
        end
        
        local gmem = reaper.gmem_write
        gmem(128, filttab.all_cc)
        gmem(129, filttab.pb)
        gmem(130, filttab.sysx)
        gmem(131, filttab.pc)
        gmem(132, filttab.at_poly)
        gmem(133, filttab.at_chan)
        for i = 0, 127 do
          if filttab.ccs[i] == 1 then
            gmem(i,1)
          else
            gmem(i,0)
          end
        end
        gmem(255, 1) --Trigger Update
        reaper.TrackFX_SetParam(tr,0,1,1)
        
        reaper.gmem_attach('LBX_SK2_SharedMem')
        
        if filttab.sysx == 1 then
          local f = reaper.TrackFX_AddByName(tr, 'JS:LBX_SYSXBlocker', false, -1)
          if f >= 0 then
            reaper.TrackFX_Show(tr, f, 2)
          end
        end
      end
      
      if lvar.enablegroupinputs and settings.groupinputs then
        local dev = 4096+(63 << 5)
        reaper.SetMediaTrackInfo_Value(tr,'I_RECINPUT',dev)
        reaper.SetMediaTrackInfo_Value(tr,'I_RECMODE',2)
        reaper.SetMediaTrackInfo_Value(tr,'I_RECARM',1)
        reaper.SetMediaTrackInfo_Value(tr,'I_RECMON',1)
        reaper.SetMediaTrackInfo_Value(tr,'D_VOL',0)
        SetSoloDefeat(tr)
      else
        local p = 1
        for a, b in pairs(lvar.midiinput_gen) do
          reaper.InsertTrackAtIndex(lbxfolder+p, false)
          lvar.tracks.inst_in = lvar.tracks.inst_in + 1
          tcnt=tcnt+1
          tr = GetTrack(lbxfolder+p+1)
          local retval, trname = reaper.GetSetMediaTrackInfo_String(tr, "P_NAME", 'SK_IN_'..a, true)
          SetSoloDefeat(tr)
          local dev = 4096+(b << 5)
          reaper.SetMediaTrackInfo_Value(tr,'I_RECINPUT',dev)
          reaper.SetMediaTrackInfo_Value(tr,'I_RECMODE',2)
          reaper.SetMediaTrackInfo_Value(tr,'I_RECARM',1)
          reaper.SetMediaTrackInfo_Value(tr,'I_RECMON',1)
          reaper.SetMediaTrackInfo_Value(tr,'D_VOL',0)
          reaper.SetMediaTrackInfo_Value(tr,'B_MAINSEND',1)      
          
          --midi filter
          if lvar.midiinput_filt and lvar.midiinput_filt[a] and lvar.midiinput_filt[a].active then
            local filttab = lvar.midiinput_filt[a]
            local f = reaper.TrackFX_AddByName(tr, 'JS:LBX-MidiFilter', false, -1)
            if f >= 0 then
              reaper.TrackFX_Show(tr, f, 2)
            end
            
            reaper.gmem_attach('LBX_MF_SharedMem')
            while reaper.gmem_read(255) ~= 0 do
            end

            local gmem = reaper.gmem_write
            gmem(128, filttab.all_cc)
            gmem(129, filttab.pb)
            gmem(130, filttab.sysx)
            gmem(131, filttab.pc)
            gmem(132, filttab.at_poly)
            gmem(133, filttab.at_chan)
            --DBG(filttab.pb)
            for i = 0, 127 do
              if filttab.ccs[i] == 1 then
                gmem(i,1)
              else
                gmem(i,0)
              end
            end
            
            gmem(255, 1) --Trigger Update
            reaper.TrackFX_SetParam(tr,0,1,1)
            reaper.gmem_attach('LBX_SK2_SharedMem')          

            if filttab.sysx == 1 then
              local f = reaper.TrackFX_AddByName(tr, 'JS:LBX_SYSXBlocker', false, -1)
              if f >= 0 then
                reaper.TrackFX_Show(tr, f, 2)
              end
            end
          end
          
          p=p+1 
          if settings.hidectltrack then
            reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINTCP',0)
            reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINMIXER',0)
          end
        end
        reaper.SetMediaTrackInfo_Value(tr,'I_FOLDERDEPTH',-1)
      end
    end
    
    --SKTOUCH
    --[[lvar.touchenabled = nil
    if settings.touchctl and not settings.rrmode then
      lvar.touchenabled = true
    end
    local trtouch 
    if lvar.touchenabled then
      reaper.InsertTrackAtIndex(0, false)
      trtouch = GetTrack(1)
      tr = trtouch
      reaper.GetSetMediaTrackInfo_String(tr, "P_NAME", LBX_TOUCH_TRNAME, true)
      reaper.SetMediaTrackInfo_Value(tr,'B_MAINSEND',0) 
      if settings.hidectltrack then
        reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINTCP',0)
        reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINMIXER',0)
      end
      reaper.TrackFX_AddByName(tr, 'JS:LBX_SKCC3', false, -1)
      reaper.TrackFX_SetParam(tr,0,0,2)
      reaper.TrackFX_SetParam(tr,0,36,2) --Initialize 
      reaper.TrackFX_SetParam(tr,0,38,2) --Initialize 
      
    end]]
    
    --SKCC
    local skcctr, tr, ctltr
    
    reaper.InsertTrackAtIndex(lbxfolder, false)
    tcnt=tcnt+1
    skcctr = GetTrack(lbxfolder+1)
    reaper.GetSetMediaTrackInfo_String(skcctr, "P_NAME", '__LBX_SKCC', true)
    --reaper.SetMediaTrackInfo_Value(skcctr,'I_FOLDERDEPTH',1)
    reaper.SetMediaTrackInfo_Value(skcctr,'B_MAINSEND',0) 
    reaper.SetMediaTrackInfo_Value(skcctr,'D_VOL',0)      
    reaper.SetMediaTrackInfo_Value(skcctr,'I_AUTOMODE',0)      
    if settings.hidectltrack then
      reaper.SetMediaTrackInfo_Value(skcctr,'B_SHOWINTCP',0)
      reaper.SetMediaTrackInfo_Value(skcctr,'B_SHOWINMIXER',0)
    end

    if lvar.midiloopbackdev then
      if mididevices.outidx[lvar.midiloopbackdev] then
        local idx = mididevices.outidx2[lvar.midiloopbackdev]
        if mididevices.output[idx] then
          local dev = (mididevices.output[mididevices.outidx2[lvar.midiloopbackdev]].dev << 5)
          reaper.SetMediaTrackInfo_Value(skcctr, 'I_MIDIHWOUT', dev)
        else
          DBG('Loopback device not found')
        end
      end
    end

    --SKCTL
    reaper.InsertTrackAtIndex(lbxfolder, false)
    tcnt=tcnt+1
    ctltr = GetTrack(lbxfolder+1)
    reaper.GetSetMediaTrackInfo_String(ctltr, "P_NAME", '__LBX_SKCTL', true)
    reaper.SetMediaTrackInfo_Value(ctltr,'B_MAINSEND',0) 
    reaper.SetMediaTrackInfo_Value(ctltr,'D_VOL',0)
    reaper.SetMediaTrackInfo_Value(ctltr,'I_AUTOMODE',0)      
    SetSoloDefeat(ctltr) 
    --for i = 1, (lvar.fcount/32) do
    local f = reaper.TrackFX_AddByName(ctltr, 'JS:LBX_SKCTL', false, -1)
    if f >= 0 then
      reaper.TrackFX_Show(ctltr, f, 2)
    end
    reaper.TrackFX_SetParam(ctltr,0,0,lvar.fcount)
    GMFB_memset_37()
    GMFB_memset_39()
    
    --reaper.TrackFX_SetParam(ctltr,i-1,36,2) --Initialize 
    --reaper.TrackFX_SetParam(ctltr,i-1,38,2) --Initialize
    --reaper.TrackFX_SetParam(ctltr,i-1,63,i-1) --Instance
    
    if lvar.fbcconseek == true then
      --reaper.TrackFX_SetParam(ctltr,i-1,49,1) --Initialize      
      --reaper.TrackFX_SetParam(ctltr,0,49,1) --Initialize
      reaper.gmem_write(lvar.gm_fb.gswitch50,1)
    else
      reaper.gmem_write(lvar.gm_fb.gswitch50,0)
    end   
    --end
    local f = reaper.TrackFX_AddByName(ctltr, 'JS:LBX_FBOut', false, -1)
    if f >= 0 then
      reaper.TrackFX_Show(ctltr, f, 2)
    end

    --INPUT CC TRACKS
    local p = 2
    for a, bb in pairs(lvar.midiinput_ctl) do
      local b = bb.dev
      local bus = bb.bus+1
      reaper.InsertTrackAtIndex(lbxfolder+p, false)
      lvar.tracks.skcc_in = lvar.tracks.skcc_in + 1
      tcnt=tcnt+1
      tr = GetTrack(lbxfolder+p+1)
      local retval, trname = reaper.GetSetMediaTrackInfo_String(tr, "P_NAME", 'SKCC_IN_'..a, true)
      SetSoloDefeat(tr) 
      local dev = 4096+(b << 5)
      reaper.SetMediaTrackInfo_Value(tr,'B_MAINSEND',0) 
      reaper.SetMediaTrackInfo_Value(tr,'D_VOL',0)
      reaper.SetMediaTrackInfo_Value(tr,'I_AUTOMODE',0)                  
      reaper.SetMediaTrackInfo_Value(tr,'I_RECINPUT',dev)
      reaper.SetMediaTrackInfo_Value(tr,'I_RECMODE',2)
      reaper.SetMediaTrackInfo_Value(tr,'I_RECARM',1)
      reaper.SetMediaTrackInfo_Value(tr,'I_RECMON',1)
      
      local f = reaper.TrackFX_AddByName(tr, 'JS:LBX_SYSXBlocker', false, -1)
      if f >= 0 then
        reaper.TrackFX_Show(tr, f, 2)
      end
      
      if settings.hidectltrack then
        reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINTCP',0)
        reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINMIXER',0)
      end
      --Create send to SKCC
      local idx = reaper.CreateTrackSend(tr, skcctr)
      reaper.SetTrackSendInfo_Value(tr, 0, idx, 'I_SRCCHAN', -1)
      reaper.BR_GetSetTrackSendInfo(tr, 0, idx, 'I_MIDI_SRCCHAN', true, 0)
      reaper.BR_GetSetTrackSendInfo(tr, 0, idx, 'I_MIDI_DSTBUS', true, bus)
      
      --Create send to SKCTL
      local idx = reaper.CreateTrackSend(tr, ctltr)
      reaper.SetTrackSendInfo_Value(tr, 0, idx, 'I_SRCCHAN', -1)
      reaper.BR_GetSetTrackSendInfo(tr, 0, idx, 'I_MIDI_SRCCHAN', true, 0)
      reaper.BR_GetSetTrackSendInfo(tr, 0, idx, 'I_MIDI_DSTBUS', true, 4+bus)
      
      --[[if lvar.touchenabled then
        local idx = reaper.CreateTrackSend(tr, trtouch)
        reaper.SetTrackSendInfo_Value(tr, 0, idx, 'I_SRCCHAN', -1)
        reaper.BR_GetSetTrackSendInfo(tr, 0, idx, 'I_MIDI_DSTBUS', true, bus)
      end]]
      
      --midi filter
      if lvar.midiinput_filt and lvar.midiinput_filt[a] and lvar.midiinput_filt[a].active then
        local filttab = lvar.midiinput_filt[a]
        local f = reaper.TrackFX_AddByName(tr, 'JS:LBX-MidiFilter', false, -1)
        if f >= 0 then
          reaper.TrackFX_Show(tr, f, 2)
        end
        
        reaper.gmem_attach('LBX_MF_SharedMem')
        local gmem = reaper.gmem_write
        gmem(128, filttab.all_cc)
        gmem(129, filttab.pb)
        gmem(130, filttab.sysx)
        gmem(131, filttab.pc)
        gmem(132, filttab.at_poly)
        gmem(133, filttab.at_chan)
        
        for i = 0, 127 do
          if filttab.ccs[i] == 1 then
            gmem(i,1)
          else
            gmem(i,0)
          end
        end
        reaper.TrackFX_SetParam(tr,1,1,1)
        reaper.gmem_attach('LBX_SK2_SharedMem')          
      end
      
      p=p+1
    end    
    --reaper.SetMediaTrackInfo_Value(tr,'I_FOLDERDEPTH',-1)

    --Add SKCC plugin   
    --tr = GetTrack(1)
    local f = reaper.TrackFX_AddByName(skcctr, 'JS:LBX_SKCC', false, -1)
    if f >= 0 then
      reaper.TrackFX_Show(skcctr, f, 2)
    end
    if lvar.touchenabled then  
      reaper.TrackFX_SetParam(skcctr,0,0,1)
    end
    reaper.TrackFX_SetParam(skcctr,0,36,2) --Initialize 
    reaper.TrackFX_SetParam(skcctr,0,38,2) --Initialize 
    
    
    for a, bb in pairs(lvar.midioutput_ctl) do
      local b = bb.dev
      local bus = bb.bus
      --Add output track
      reaper.InsertTrackAtIndex(lbxfolder, false)
      lvar.tracks.out = lvar.tracks.out + 1
      tcnt=tcnt+1
      outtr = GetTrack(lbxfolder+1)
      if settings.hidectltrack then
        reaper.SetMediaTrackInfo_Value(outtr,'B_SHOWINTCP',0)
        reaper.SetMediaTrackInfo_Value(outtr,'B_SHOWINMIXER',0)
      end
      reaper.GetSetMediaTrackInfo_String(outtr, "P_NAME", '__LBX_OUT_'..string.format('%i',bus)..'_'..a, true)
      reaper.SetMediaTrackInfo_Value(outtr,'B_MAINSEND',0)
      reaper.SetMediaTrackInfo_Value(outtr,'D_VOL',0)
      reaper.SetMediaTrackInfo_Value(outtr,'I_AUTOMODE',0)            
      local f = reaper.TrackFX_AddByName(outtr, 'JS:LBX_SYSXOut', false, -1)
      if f >= 0 then
        reaper.TrackFX_Show(outtr, f, 2)
      end
      
      reaper.TrackFX_SetParam(outtr, 0, 7, bus)
      --prevent sysx timeout messages when create stage takes too long
      --we can assume as the jsfx's are new - they will be ready
      --DBG(bus)
      reaper.gmem_write(lvar.gm_sysx.msg_ready+bus*1000,1)
      
      --reaper.TrackFX_AddByName(outtr, 'JS:LBX_BusRouter', false, -1)
      --Set up bus router
      --reaper.TrackFX_SetParam(outtr,i-1,36,2) --Initialize 
      --Set up send from __LBX_SKCTL
      local idx = reaper.CreateTrackSend(ctltr, outtr)
      reaper.SetTrackSendInfo_Value(ctltr, 0, idx, 'I_SRCCHAN', -1)
      reaper.BR_GetSetTrackSendInfo(ctltr, 0, idx, 'I_MIDI_SRCCHAN', true, 0)
      reaper.BR_GetSetTrackSendInfo(ctltr, 0, idx, 'I_MIDI_SRCBUS', true, bus+9)
      reaper.BR_GetSetTrackSendInfo(ctltr, 0, idx, 'I_MIDI_DSTBUS', true, 1)
            
      local dev = (b << 5)
      reaper.SetMediaTrackInfo_Value(outtr, 'I_MIDIHWOUT', dev)
    end
    if settings.hidectltrack then
      reaper.SetMediaTrackInfo_Value(ctltr,'B_SHOWINTCP',0)
      reaper.SetMediaTrackInfo_Value(ctltr,'B_SHOWINMIXER',0)
    end
    --[[if lvar.touchenabled then
      reaper.CreateTrackSend(trtouch, tr)
      reaper.SetTrackSendInfo_Value(trtouch, 0, 0, 'I_SRCCHAN', -1)
    end]]
    
    --RR
    if settings.rrmode then
      local tr
      reaper.InsertTrackAtIndex(lbxfolder, false)
      lvar.tracks.rr = lvar.tracks.rr + 1
      tcnt=tcnt+1
      tr = GetTrack(lbxfolder+1)
      reaper.GetSetMediaTrackInfo_String(tr, "P_NAME", LBX_RR_TRNAME, true)
      local f = reaper.TrackFX_AddByName(tr, 'JS:LBX_RRMIDI', false, -1)
      if f >= 0 then
        reaper.TrackFX_Show(tr, f, 2)
      end
      
      reaper.SetMediaTrackInfo_Value(tr,'I_RECMODE',2)
      reaper.SetMediaTrackInfo_Value(tr,'I_RECINPUT',-1)
      reaper.SetMediaTrackInfo_Value(tr,'B_MAINSEND',0) 
      reaper.SetMediaTrackInfo_Value(tr,'D_VOL',0)
      reaper.SetMediaTrackInfo_Value(tr,'I_AUTOMODE',0)
      if settings.hidectltrack then
        reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINTCP',0)
        reaper.SetMediaTrackInfo_Value(tr,'B_SHOWINMIXER',0)
      end
      if lvar.midiloopbackdev and othtr then
        local idx = reaper.CreateTrackSend(othtr, tr)
        reaper.SetTrackSendInfo_Value(othtr, 0, idx, 'I_SRCCHAN', -1)
        reaper.BR_GetSetTrackSendInfo(othtr, 0, idx, 'I_MIDI_SRCCHAN', true, 0) 
      end
      
      if lvar.midiloopbackdev and others == true then
        local idx = reaper.CreateTrackSend(skcctr, tr)      
        reaper.SetTrackSendInfo_Value(skcctr, 0, idx, 'I_SRCCHAN', -1)
        reaper.BR_GetSetTrackSendInfo(skcctr, 0, idx, 'I_MIDI_SRCCHAN', true, 0) 
      end
      
      if others == false then
        reaper.SetMediaTrackInfo_Value(tr,'I_RECINPUT',4096 | (63<<5))
        reaper.SetMediaTrackInfo_Value(tr,'I_RECARM',1)
        reaper.SetMediaTrackInfo_Value(tr,'I_RECMON',1)
        SetSoloDefeat(tr) 
      end
    end
    
    if lbxfolderfound then
      local tr = GetTrack(lbxfolder)
      reaper.SetMediaTrackInfo_Value(tr, 'I_FOLDERDEPTH', 1)
      local tr = GetTrack(lbxfolder+tcnt)
      reaper.SetMediaTrackInfo_Value(tr, 'I_FOLDERDEPTH', -1)    
    end
    
    --reaper.UpdateArrange()
    reaper.TrackList_AdjustWindows(false)
    
    lvar.tracks.tot = tcnt
    SaveProjectCtlTrackInfo()
    
    local _, trackinfo = GetFOLTrack()
    lvar.trackinfo = trackinfo
    --[[GetCTLTrack()
    GetCCTrack()
    GetINTrack()
    GetInputTracks()
    GetInputCCTracks()
    GetOUTTracks()
    GetRRTrack()]]
    
    ResetLEDs()
    
    lvar.seltrackguid = nil
    lvar.remap_active = false
    LoadDefCCs()
    
    ResetCtlMap()
    for i = 1, 4 do
      if lvar.midimap[i] then
        local fn = paths.ctemplate_path..lvar.midimap[i]..'.skctlmap'
        LoadCtlMap(fn,i)
      end
    end
    SortCtlMap()
    SetCtlMap()
    
    ResetSysXReady()
    
    GetCtlTrackFound()
    SetCCs()
    if lvar.createsends then
      SetSendsAuto(true)
    end
    
    --reload perma template
    --LoadGlobalMap(nil, nil, true)
    
    reaper.gmem_write(lvar.fineamt_idx, lvar.fineamt)
    
    reaper.PreventUIRefresh(-1)
    
    reaper.Undo_EndBlock2(0, 'LBX: SK2 Setup', -1)
    return true
    
  end
  
  function ResetSysXReady()
    for bus = 0, 3 do
      reaper.gmem_write(lvar.gm_sysx.msg_ready+bus*1000,1)
    end
  end
  
  function SaveProjectCtlTrackInfo()
    if lvar.tracks then
      reaper.SetProjExtState(0, SCRIPT, 'TRACKS_INST_IN', lvar.tracks.inst_in)
      reaper.SetProjExtState(0, SCRIPT, 'TRACKS_SKCC_IN', lvar.tracks.skcc_in)
      reaper.SetProjExtState(0, SCRIPT, 'TRACKS_OUT', lvar.tracks.out)
      reaper.SetProjExtState(0, SCRIPT, 'TRACKS_RR', lvar.tracks.rr)
      
      reaper.SetProjExtState(0, SCRIPT, 'TRACKS_TOTAL', lvar.tracks.tot)
    end
  end

  function LoadProjectCtlTrackInfo()
    lvar.tracks = {}
    local r, tcnt = reaper.GetProjExtState(0, SCRIPT, 'TRACKS_TOTAL')
    if r == 1 then
      lvar.tracks.tot = tonumber(tcnt)
    else
      lvar.tracks.tot = 16
    end
  end
    
  function CreateMIDILearns()
  
    local track = GetTrack(LBX_CTL_TRACK)
    local chunk = GetTrackChunk(track)
    
    for fx = 0, (lvar.fcount/32)-1 do
      local parmstr = ''
      
      for f = 1, 32 do
        fader = fx*32 + f
        local data = ctl_template.fader[fader]
        if data then
          local code
          if data.dtype == 0 then
            --CC
            code = (data.dcode << 8) | (176 + data.dchan)
          elseif data.dtype == 1 then
            --Pitch
            code = 224 + data.dchan
          elseif data.dtype == 2 then
            --Note
            code = (data.dcode << 8) | (144 + data.dchan)            
          end
          code = code + data.lmode * 65536
          parmstr = parmstr..'PARMLEARN '..string.format('%i',f-1)..' '..string.format('%i',code)..' 0\n'
        end
        
      end
      
      --Write to chunk
      local fnd, fxchunk, s, e = GetFXChunkFromTrackChunk(track,fx+1,chunk)
      --Remove existing parmlearn entries and add new ones
      string.gsub(fxchunk,'PARMLEARN.-\n','')
      fxchunk = string.gsub(fxchunk,'WAK 0',parmstr..'WAK 0')
      chunk = string.sub(chunk,0,s-1)..fxchunk..string.sub(chunk,e+1)
    end

    SetTrackChunk(track, chunk)
     
  end
  
  function MIDIMapMenu(x,y,d)
  
    gfx.x = x
    gfx.y = y
    local mapstab, mapsstr, mapcnt = GetCtlMaps()
    mapsstr = 'Clear||'..mapsstr
    local res = gfx.showmenu(mapsstr)
    if res > 0 then
      if res == 1 then
        lvar.midimap[d] = nil
      else
        lvar.midimap[d] = mapstab[res-1]
      end
      lvar.fcount = MIDIMap_CountFaders()
      lupd.update_gfx = true
    end
    
  end

  function MIDIOutMenu(x,y,d)
  
    local mstr = 'Clear (use SK2 routing)|'
    for i = 1, #mididevices.output do
      tk = ''
      if d == mididevices.outidx[i] then
        tk = '!'
      end
      mstr = mstr .. '|'..tk .. mididevices.output[i].name 
    end
  
    gfx.x = x
    gfx.y = y
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then
        lvar.midiloopbackdev = nil
      else
        lvar.midiloopbackdev = mididevices.output[res-1].name
      end
      lvar.fcount = MIDIMap_CountFaders()
      lupd.update_gfx = true
    end
    
  end
  
  function MIDIMap_CountFaders()
  
    local f = 0
    for i = 1, #lvar.midimap do
      if lvar.midimap[i] then
        local incheck, outcheck
        for a, b in pairs(lvar.midiinput_ctl) do
          if tonumber(b.bus) == tonumber(i-1) then
            incheck = true
            break
          end
        end
        for a, b in pairs(lvar.midioutput_ctl) do
          if tonumber(b.bus) == tonumber(i-1) then
            outcheck = true
            break
          end
        end
        if ((incheck and outcheck) or not lvar.checkmidiports) then
          local fn = paths.ctemplate_path..lvar.midimap[i]..'.skctlmap'
          local file = io.open(fn,'r')
          for line in file:lines() do
            local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
            if idx then
              if idx == 'FADERS' then
                if tonumber(val) then
                  f = f + tonumber(val)
                end
                break
              end
            end
          end
          file:close()
        end
      end
    end
    return f + lvar.dummyfaders
  end
  
  function FaderCntMenu(x,y)

    gfx.x = x
    gfx.y = y
    mstr = '32|64|96|128|160|192|224|256'
    local res = gfx.showmenu(mstr)
    if res > 0 then
      lvar.fcount = res*32
      lupd.update_gfx = true
    end
  
  end
  
  function ResetFSet()
    local gmem = reaper.gmem_write
    for i = 0, lvar.fcount-1 do
      gmem(lvar.gm_fb.fset+i,-1)
    end
    --local tr = GetTrack(LBX_CTL_TRACK)
    --reaper.TrackFX_SetParam(tr,0,51,1)
  end
  
  function GetItemAtCursor()
  
    --returns item only if midi item exists 
    
    local cursor_pos = reaper.GetCursorPosition() --edit cursor position
    local track = reaper.GetSelectedTrack(0, 0)
    
    if track then
      local itemcnt = reaper.CountTrackMediaItems(track)
      local item_at_cursor
      
      --check if midi items
      local midiitem
      
      for i = 0, itemcnt-1 do 
        local item = reaper.GetTrackMediaItem(track, i)
        local start_pos = reaper.GetMediaItemInfo_Value(item, "D_POSITION");
        local end_pos = start_pos + reaper.GetMediaItemInfo_Value(item, "D_LENGTH");
        
        local take = reaper.GetActiveTake(item)
        local currentmidiitem
        if take and reaper.TakeIsMIDI(take) then
          midiitem = item
          currentmidiitem = true
        end
        if cursor_pos >= start_pos and cursor_pos <= end_pos then 
          local muted = reaper.GetMediaItemInfo_Value(item, 'B_MUTE')
          if muted ~= 1 and midiitem then
            return item
          else
            return
          end
        elseif cursor_pos < start_pos then
          return midiitem
        end
      end
      return midiitem
    end
    
  end
  
  function TriggerCCChaseX()
    lvar.chasenow = true
  end
  
  function TriggerCCChase()
    --ResetFSet()
    lvar.chasenow = nil
    
    if FFX == nil then return end
    local t = reaper.time_precise()
    local tr = GetTrack(LBX_CTL_TRACK)
    if tr then

      reaper.PreventUIRefresh(1)
      --reaper.Undo_BeginBlock2(0)
      
      --if resetfaderpostoprintccvalue then check if item under cursor 
      --if item - do chase - else just print values
      local chase = true
      if lvar.resetfaderpostoprintccvalue then
        if not GetItemAtCursor() then 
          chase = false
        end
      end

      if chase then
        lvar.chasedok = true
        local ret, chasetab = TriggerCCChase2()
  
        if ret == true and chasetab then
  
          local blastccs = false
          local gmem = reaper.gmem_write
          local gmem_rd = reaper.gmem_read
          for i = 0, lvar.fcount-1 do
            --gmem(lvar.gm_fb.fset+i,-1)
            --local fx = math.floor(i/32)
            local tmp
            tmp = GetTemplate(i+1, true)
            if tmp and lvar.finetune_fader[i+1] ~= 1 then
              if tmp.pos[i+1] and tmp.pos[i+1].ptype == ptype.cc and ctl_template.fader[i+1].lmode ~= 4 then
                tmp.dirty[i+1] = true
                local chan = tmp.pos[i+1].ccchan
                local ccnum = tmp.pos[i+1].ccnum
                --local ccset
                if chasetab[chan] and chasetab[chan][ccnum] and chasetab[chan][ccnum].value then
                  --DBG(i..'  '..ccnum..tmp.pos[i+1].pname..'  '..chasetab[chan][ccnum].value)
                  if tmp.pos[i+1].polarity == 1 then
                    chasetab[chan][ccnum].value = 127-chasetab[chan][ccnum].value
                  end
                  gmem(lvar.gm_fb.fset+i,(chasetab[chan][ccnum].value))
                  blastccs = true
                elseif --[[lvar.ccstamp_active == 1 and]] gmem_rd(lvar.gm_ccstamp.cc_enabled+ccnum) == 1
                       and lvar.resetfaderpostoprintccvalue == true 
                       and (tmp.pos[i+1].defcc_val or gmem_rd(lvar.gm_ccstamp.defcc_val+ccnum) >= 0) then
                  local v = tmp.pos[i+1].defcc_val or gmem_rd(lvar.gm_ccstamp.defcc_val+ccnum)
                  if tmp.pos[i+1].polarity == 1 then
                    v = 127-v
                  end
                  gmem(lvar.gm_fb.fset+i, math.max(v,0))
                  --ccset = tmp.pos[i+1].defcc_val
                  blastccs = true            
                end
                --if ccset then
                
                --end
              end
              
            end
          end
          if blastccs == true then
            reaper.TrackFX_SetParam(tr,0,51,1)
            --gmem(lvar.gm_fb.fset_trigger51, 1)
          end
          
          lupd.update_faderbar = true
        
        else
          --chase time exceeded
          lvar.chasedok = false
          for i = 0, lvar.fcount-1 do
            local tmp
            tmp = GetTemplate(i+1, true)
            if tmp and tmp.pos[i+1] and tmp.pos[i+1].cc == true then
              tmp.dirty[i+1] = true
            end 
          end
          
          lupd.update_faderbar = true
        end
        
      else
        --Print Vals only
        local blastccs = false
        local gmem = reaper.gmem_write
        local gmem_rd = reaper.gmem_read
        for i = 0, lvar.fcount-1 do
          local tmp
          tmp = GetTemplate(i+1, true)
          if tmp and lvar.finetune_fader[i+1] ~= 1 then
            if ctl_template.fader[i+1].lmode ~= 4 and tmp.pos[i+1] and tmp.pos[i+1].ptype == ptype.cc then
              tmp.dirty[i+1] = true
              local chan = tmp.pos[i+1].ccchan
              local ccnum = tmp.pos[i+1].ccnum
              
              if --[[lvar.ccstamp_active == 1 and]] gmem_rd(lvar.gm_ccstamp.cc_enabled+ccnum) == 1 
                     and lvar.resetfaderpostoprintccvalue == true 
                     and (tmp.pos[i+1].defcc_val or gmem_rd(lvar.gm_ccstamp.defcc_val+ccnum) >= 0) then
                local v = tmp.pos[i+1].defcc_val or gmem_rd(lvar.gm_ccstamp.defcc_val+ccnum)
                if tmp.pos[i+1].polarity == 1 then
                  v = 127-v
                end
                gmem(lvar.gm_fb.fset+i, math.max(v,0))
                --ccset = tmp.pos[i+1].defcc_val
                blastccs = true            
              end
            end
          end
        end
        if blastccs == true then
          reaper.TrackFX_SetParam(tr,0,51,1)
        end
        
        lupd.update_faderbar = true
      end
      
      --reaper.Undo_EndBlock2(0, "SK Chase CCs", -1)
      reaper.PreventUIRefresh(-1)
    end
    --DBG(reaper.time_precise()-t)
  end
  
  function TriggerCCChase2()
  
  local cursorTimePos = reaper.GetCursorPositionEx(0)
  
  ---------------
  
    -- Select all items in track
    
    local track = reaper.GetSelectedTrack(0,0)
  
    --reaper.Main_OnCommand(reaper.NamedCommandLookup('_SWS_SAVESELITEMS1'),0)
    --[[reaper.Undo_BeginBlock2(0)
    reaper.Main_OnCommand(reaper.NamedCommandLookup('_SWS_SAVEALLSELITEMS1'),0)
    
    reaper.Main_OnCommand(40289,0)          --unselect all items
    reaper.Main_OnCommand(40421,0)          --select all track items]]
  
    -- Set up tables in which the running values will be stored
    local tLastCC = {} -- table with last values for each CC type and channel
    for chan = 0, 15 do -- Some of the table will require subtables for CC lane, or MSB vs LSB.
        tLastCC[chan] = {}
        for lane = 0, 255 do
            tLastCC[chan][lane] = {lastPPQpos = -math.huge}
        end
    end 
  
    -- Loop through all selected items
  
    local ret = true
    local maxtime = reaper.time_precise() + lvar.maxchasetime/1000
    
    if track then
      local i = 0
      local item = reaper.GetTrackMediaItem(track, i)
      
      --for i = 0, reaper.CountSelectedMediaItems(0)-1 do
      local t = reaper.time_precise()
      
      while item do
      --DBG(i..'  '..tostring(item))
      
          local foundFirstBeyond
          --local item = reaper.GetSelectedMediaItem(0, i)
          if reaper.ValidatePtr2(0, item, "MediaItem*") then
              local itemStartTimePos = reaper.GetMediaItemInfo_Value(item, "D_POSITION")
              
              if cursorTimePos >= itemStartTimePos then
                local itemEndTimePos = itemStartTimePos + reaper.GetMediaItemInfo_Value(item, "D_LENGTH")
                --if itemEndTimePos > cursorTimePos+0.000001 then -- Take into account round error, to make sure that really overlap.
            
                    -- Loop through all takes within each selected item
                    --for t = 0, reaper.CountTakes(item)-1 do
                        local take = reaper.GetActiveTake(item)
                        if take then
                          if reaper.ValidatePtr2(0, take, "MediaItemTake*") and reaper.TakeIsMIDI(take) then
                          
                              local MIDIOK, MIDIstring = reaper.MIDI_GetAllEvts(take, "")
                              
                              if not MIDIOK then 
                                  local trackNumber = string.format("%i", tostring(reaper.GetMediaTrackInfo_Value(reaper.GetMediaItemTrack(item), "IP_TRACKNUMBER")))
                                  reaper.MB("Error retrieving MIDI from item in track ".. trackNumber,  "ERROR", 0)
                                  return
                              else
                                  local itemEndPPQpos = reaper.MIDI_GetPPQPosFromProjTime(take, itemEndTimePos)
                                  local itemStartPPQpos = reaper.MIDI_GetPPQPosFromProjTime(take, itemStartTimePos)
                                  local cursorPPQpos = math.ceil(reaper.MIDI_GetPPQPosFromProjTime(take, cursorTimePos)) -- use "ceil" to ensure that CCs are inserting *after* split point
                                  local MIDIlen = MIDIstring:len()
                                  --4194300 = max length of clip 
                                  local runningPPQpos = itemStartPPQpos --0
                                  local stringPos     = 1 -- Position in MIDIstring while parsing
                                  local offset, flags, msg
                                  
                                  while stringPos < MIDIlen do
                                      offset, flags, msg, stringPos = string.unpack("i4Bs4", MIDIstring, stringPos)
                                      runningPPQpos = runningPPQpos + offset
                                      if (not foundFirstBeyond and runningPPQpos > cursorPPQpos) or reaper.time_precise() > maxtime then
                                          foundFirstBeyond = true
                                          --DBG('pp'..runningPPQpos..'   '..tostring(runningPPQpos > cursorPPQpos))
                                          if reaper.time_precise() > maxtime then
                                            ret = false
                                          end
                                          break
                                      elseif runningPPQpos > itemEndPPQpos then
                                        break
                                      end
              
                                      if runningPPQpos <= cursorPPQpos and flags&2 ~= 2 and msg ~= "" then -- ignore muted CCs and empty events
                                          local chanmsg = msg:byte(1)&0xF0
                                          local chan    = msg:byte(1)&0x0F
                                          if chanmsg == 0xB0 then -- CC
                                              local lane = msg:byte(2)
                                              --if runningPPQpos > tLastCC[chan][lane].lastPPQpos then
                                                  tLastCC[chan][lane] = {lastPPQpos = runningPPQpos, value = msg:byte(3)}
                                              --end
                                          end
                                      end
                                  end
                                      
                                  -- If not foundFirstBeyond, then the cursor was beyond even the All-Notes-Off message at the end of the take
                                  if foundFirstBeyond then
                                      break 
                                  end -- if foundFirstBeyond
                                        
                              end -- if not MIDIOK
                          --end -- for t = 0, reaper.CountTakes(item)-1 do
        
                          if foundFirstBeyond then                            
                              break                            
                          end -- if foundFirstBeyond
                        end
                    end -- 
                --end -- if itemStartTimePos < cursorTimePos and itemEndTimePos > cursorTimePos
              else
                foundFirstBeyond = true
              end
          end -- if reaper.ValidatePtr2(0, item, "MediaItem*")
    
          if foundFirstBeyond then                            
              break                            
          end -- if foundFirstBeyond
      
        i=i+1
        item = reaper.GetTrackMediaItem(track, i)
      end -- for i = 0, reaper.CountSelectedMediaItems(0)-1
    
    end
    
    --reaper.Main_OnCommand(reaper.NamedCommandLookup('_SWS_RESTSELITEMS1'),0)
    --reaper.Main_OnCommand(reaper.NamedCommandLookup('_SWS_RESTALLSELITEMS1'),0)
    --reaper.Undo_EndBlock2(0, "SK Chase CCs", -1)
    return ret, tLastCC
    
  end
  
  
  --This function code has been adapted from Julian Sader's JS_Edit: Chase MIDI events to mouse cursor script.
  --[[function TriggerCCChase2()
  
  local cursorTimePos = reaper.GetCursorPositionEx(0)
  
  ---------------
  
    -- Select all items in track
    
    --local track = reaper.GetSelectedTrack(0,0)

    --reaper.Main_OnCommand(reaper.NamedCommandLookup('_SWS_SAVESELITEMS1'),0)
    reaper.Main_OnCommand(reaper.NamedCommandLookup('_SWS_SAVEALLSELITEMS1'),0)
    
    reaper.Main_OnCommand(40289,0)          --unselect all items
    reaper.Main_OnCommand(40421,0)          --select all track items

    -- Set up tables in which the running values will be stored
    local tLastCC = {} -- table with last values for each CC type and channel
    for chan = 0, 15 do -- Some of the table will require subtables for CC lane, or MSB vs LSB.
        tLastCC[chan] = {}
        for lane = 0, 255 do
            tLastCC[chan][lane] = {lastPPQpos = -math.huge}
        end
    end 
  
    -- Loop through all selected items

    local ret = true
    local maxtime = reaper.time_precise() + lvar.maxchasetime/1000
    
    for i = 0, reaper.CountSelectedMediaItems(0)-1 do
    
        local foundFirstBeyond
        local item = reaper.GetSelectedMediaItem(0, i)
        if reaper.ValidatePtr2(0, item, "MediaItem*") then
            local itemStartTimePos = reaper.GetMediaItemInfo_Value(item, "D_POSITION")
            local itemEndTimePos   = itemStartTimePos + reaper.GetMediaItemInfo_Value(item, "D_LENGTH")
            --if itemStartTimePos < cursorTimePos-0.000001 and itemEndTimePos > cursorTimePos+0.000001 then -- Take into account round error, to make sure that really overlap.
        
                -- Loop through all takes within each selected item
                for t = 0, reaper.CountTakes(item)-1 do
                    local take = reaper.GetActiveTake(item)
                    if reaper.ValidatePtr2(0, take, "MediaItemTake*") and reaper.TakeIsMIDI(take) then
                    
                        local MIDIOK, MIDIstring = reaper.MIDI_GetAllEvts(take, "")
                        
                        if not MIDIOK then 
                            local trackNumber = string.format("%i", tostring(reaper.GetMediaTrackInfo_Value(reaper.GetMediaItemTrack(item), "IP_TRACKNUMBER")))
                            reaper.MB("Error retrieving MIDI from item in track ".. trackNumber,  "ERROR", 0)
                            return
                        else
                        
                            local cursorPPQpos = math.ceil(reaper.MIDI_GetPPQPosFromProjTime(take, cursorTimePos)) -- use "ceil" to ensure that CCs are inserting *after* split point
                        
                            local MIDIlen = MIDIstring:len()
                            --4194300 = max length of clip 
                            local runningPPQpos = 0
                            local stringPos     = 1 -- Position in MIDIstring while parsing
                            local offset, flags, msg
                            
                            while stringPos < MIDIlen do
                                offset, flags, msg, stringPos = string.unpack("i4Bs4", MIDIstring, stringPos)
                                runningPPQpos = runningPPQpos + offset
                                if (not foundFirstBeyond and runningPPQpos > cursorPPQpos) or reaper.time_precise() > maxtime then
                                    foundFirstBeyond = true
                                    if reaper.time_precise() > maxtime then
                                      ret = false
                                    end
                                    break
                                end
        
                                if runningPPQpos <= cursorPPQpos and flags&2 ~= 2 and msg ~= "" then -- ignore muted CCs and empty events
                                    local chanmsg = msg:byte(1)&0xF0
                                    local chan    = msg:byte(1)&0x0F
                                    if chanmsg == 0xB0 then -- CC
                                        local lane = msg:byte(2)
                                        --if runningPPQpos > tLastCC[chan][lane].lastPPQpos then
                                            tLastCC[chan][lane] = {lastPPQpos = runningPPQpos, value = msg:byte(3)}
                                        --end
                                    end
                                end
                            end
                            
                            -- If not foundFirstBeyond, then the cursor was beyond even the All-Notes-Off message at the end of the take
                            if foundFirstBeyond then
                                break                            
                            end -- if foundFirstBeyond
                                  
                        end -- if not MIDIOK
                    end -- for t = 0, reaper.CountTakes(item)-1 do

                    if foundFirstBeyond then                            
                        break                            
                    end -- if foundFirstBeyond
                
                end -- 
            --end -- if itemStartTimePos < cursorTimePos and itemEndTimePos > cursorTimePos
        end -- if reaper.ValidatePtr2(0, item, "MediaItem*")

        if foundFirstBeyond then                            
            break                            
        end -- if foundFirstBeyond
    
    end -- for i = 0, reaper.CountSelectedMediaItems(0)-1

    --reaper.Main_OnCommand(reaper.NamedCommandLookup('_SWS_RESTSELITEMS1'),0)
    reaper.Main_OnCommand(reaper.NamedCommandLookup('_SWS_RESTALLSELITEMS1'),0)
    return ret, tLastCC
    
  end]]
  
--[[  function TriggerCCChase()

    if LBX_CTL_TRACK then
      local tr = GetTrack(LBX_CTL_TRACK)
      if tr then
        --Set FB flag
        for i = 0, reaper.TrackFX_GetCount(tr)-2 do
          reaper.TrackFX_SetParam(tr, i, 50, 1)
        end
                
        --[ [reaper.Main_OnCommand(40044,0) 
        local t = reaper.time_precise()
        while reaper.time_precise() < t+0.2 do
        end
        reaper.Main_OnCommand(40044,0)
      end
    end    
  end]]
  
  function GetMirrorIdxs(devA, devB)
  
    local tab = {}
    local ctlidx = {}
    for i = 1, lvar.fcount do
      if ctl_template.fader[i].devbus == devA then
        ctlidx[ctl_template.fader[i].devctl] = i
      end
    end
    for i = 1, lvar.fcount do
      if ctl_template.fader[i].devbus == devB then
        if ctlidx[ctl_template.fader[i].devctl] then
          tab[#tab+1] = {devctl = ctl_template.fader[i].devctl,
                         devA = ctlidx[ctl_template.fader[i].devctl],
                         devB = i}
        end
      end
    end
    return tab
    
  end
  
  function MirrorDevice(devA, devB)
    if not lvar.mirroridxs[devA] then
      lvar.mirroridxs[devA] = {}
    end
    if not lvar.mirroridxs[devA][devB] then
      lvar.mirroridxs[devA][devB] = GetMirrorIdxs(devA, devB)
    end
    
    local tab = lvar.mirroridxs[devA][devB]
    for i = 1, #tab do
      local dA = tab[i].devA
      local dB = tab[i].devB
      template.pos[dB] = table.copy(template.pos[dA])
      if lvar.overtemplate_active and template.layer and template.layer[lvar.overtemplate] then
        template.layer[lvar.overtemplate].pos[dB] = table.copy(template.layer[lvar.overtemplate].pos[dA])
      end
      if lvar.showglobalmap then
        globtemplate.pos[dB] = table.copy(globtemplate.pos[dA])
      end
      permatemplate.pos[dB] = table.copy(permatemplate.pos[dB])
    end
  end
  
  function updatetravellingtracknames(send)
  
    for i = 1, lvar.fcount do
    
      local tmp
      tmp = GetTemplate(i, true)
    
      if tmp then
        --removed ss num check as otherwise - where no ssnum available - track names omitted
        if ctl_template.fader[i] --[[and ctl_template.fader[i].ssnum]] then
          if tmp.pos[i] and tmp.pos[i].ptype == ptype.track then
            local trn = tmp.pos[i].track
            local ttrn, track
            if trn < 0 then
              if trn == -1 then
                track = reaper.GetSelectedTrack2(0,0,true)
                if track then
                  ttrn = tonumber(reaper.GetMediaTrackInfo_Value(track,'IP_TRACKNUMBER')) or 0
                end
              elseif trn == -2 then
                ttrn = Internal_GetTrack2(tmp.pos[i])
                track = GetTrack(ttrn)
              end

              if track and ttrn then
                if tmp.pos[i].trparam ~= -1 then
                  local trnm
                  if settings.includetracknameinss then
                    --if lvar.rec_mapactiveenvstofaders then
                    --  tmp.pos[i].scribov = tmp.pos[i].name or (GenTrackPName(i,''))
                    --else
                      trnm = reaper.GetTrackState(track)
                      if tmp.pos[i].trparam ~= 14 then
                        tmp.pos[i].scribov = tmp.pos[i].name or (string.format('%i',ttrn)..' '.. GenTrackPName(i,string.sub(trnm,1,40)))
                      else
                        tmp.pos[i].scribov = tmp.pos[i].name or (GenTrackPName(i,string.sub(trnm,1,40)))
                      end
                    --end
                    --DBG(string.sub(trnm,1,40))
                  else
                    tmp.pos[i].scribov = tmp.pos[i].name or ('Tr '..string.format('%i',ttrn)..' '.. GenTrackPName(i))
                  end
                  tmp.dirty[i] = true
                  lupd.update_fader = true
                  send = true
                  if lvar.stripperlink then
                    --DBG(tmp.pos[i].scribov)
                    reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', tmp.pos[i].scribov, false)
                  end
                  --DBG(i..'  '..tmp.pos[i].scribov)
                elseif tmp.pos[i].trsend ~= -1 then
                  tmp.pos[i].scribov = GenTrackSName(i, ttrn, track)
                  if lvar.stripperlink then
                    reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', tmp.pos[i].scribov, false)
                  end
                end
              else
                if tmp.pos[i].trparam == -1 then
                  tmp.pos[i].scribov = nil
                else
                  tmp.pos[i].scribov = ''                
                end
                if lvar.stripperlink then
                  reaper.SetExtState('SK2DATA_ASSIGN', string.format('%i',i-1)..'_FXSLOT', ' ', false)
                end
                tmp.dirty[i] = true
                lupd.update_fader = true
                send = true
              end          
            end
          end
        end
      end
      
    end

    if send then
      SendScribbleData()
    end
  end
  
  function TemplateChanged()
    --DBG('TC')
    if lvar.DisableTemplateChanged == true then return end
    
    local tp = reaper.time_precise()
    local str --= ''
    
    lvar.readparams = nil
    tab_SendIdx = nil
    
    lvar.ss_override_sscolor = {}
    lvar.ss_override_name = {}
    lvar.forceSSupdate = true
    
    if lvar.mirrordevices then
      if lvar.mirrordev_1toAll then
        MirrorDevice(0,1)
        MirrorDevice(0,2)
        MirrorDevice(0,3)
      else
        if lvar.mirrordev_1to2 then
          MirrorDevice(0,1)
        end
        if lvar.mirrordev_3to4 then
          MirrorDevice(2,3)
        end
      end
    end
    
    if lvar.ctlgroup_select ~= 0 then
      ResetGrpBState()
    end
    
    --[[if str then
      local tpx = reaper.time_precise() - tp
      tp = reaper.time_precise()
      str = str ..'\nA '..round(tpx,8)
    end]]
    --if lvar.initstage <= 3 then return end 
    SelectFader2(nil, false)

    --[[if str then
      local tpx = reaper.time_precise() - tp
      tp = reaper.time_precise()
      str = str ..'\nB '..round(tpx,8)
    end]]

    if recmode == 1 and not lvar.initstage and not lvar.rec_mapactiveenvstofaders then
      REC_EnvelopeData_Gather()
      Env_AutoShow()
      REC_SetSSOverrideColor(true)
    end

    --[[if str then
      local tpx = reaper.time_precise() - tp
      tp = reaper.time_precise()
      str = str ..'\nC '..round(tpx,8)
    end]]

    SetUpCCStampData()

    --[[if str then
      local tpx = reaper.time_precise() - tp
      tp = reaper.time_precise()
      str = str ..'\nD '..round(tpx,8)
    end]]

    ResetFBOvals() 

    --[[if str then
      local tpx = reaper.time_precise() - tp
      tp = reaper.time_precise()
      str = str ..'\nE '..round(tpx,8)
    end]]

    ResetLEDs()     

    --[[if str then
      local tpx = reaper.time_precise() - tp
      tp = reaper.time_precise()
      str = str ..'\nF '..round(tpx,8)
    end]]
      
    updatetravellingtracknames(true)

    --[[if str then
      local tpx = reaper.time_precise() - tp
      tp = reaper.time_precise()
      str = str ..'\nG '..round(tpx,8)
    end]]

    SetCCs()
    --SendScribbleData()

    --[[if str then
      local tpx = reaper.time_precise() - tp
      tp = reaper.time_precise()
      str = str ..'\nH '..round(tpx,8)
    end]]
    
    if lvar.autochase then
      TriggerCCChaseX()
      --lvar.trigdelay = reaper.time_precise() + lvar.trigdelaytime
    end

    --[[if str then
      local tpx = reaper.time_precise() - tp
      tp = reaper.time_precise()
      str = str ..'\nI '..round(tpx,8)
    end]]
    
    if lvar.filtidx or lvar.mirrordevices then
      UpdateFilter()
    end

    --[[if str then
      local tpx = reaper.time_precise() - tp
      tp = reaper.time_precise()
      str = str ..'\nJ '..round(tpx,8)
    end]]
    
    --local fb = false
    --if reaper.time_precise() > time_delay then
    --  fb = true
    --end
    if lvar.initstage then return end     
    
    if lvar.touchrec_active then
      SetRecTouchMode(true)
    end

    if lvar.virtualss_active then
      reaper.SetExtState('LBXVSS','[DATA_DIRTY]',1,false)
      local layer_info, layer_color
      if lvar.showglobalmap then
        layer_color = colours.globalfader
        layer_info = lvar.globmapnames[lvar.currentglobalmap] or ('GLOBAL '..string.format('%i',lvar.currentglobalmap))
      else
        if lvar.overtemplate_active then
          local txt
          if template.layer and template.layer[lvar.overtemplate] then
            txt = template.layer[lvar.overtemplate].name or ('LAYER '..string.format('%i', lvar.overtemplate))
          else 
            txt = ('LAYER '..string.format('%i', lvar.overtemplate))
          end
          layer_color = colours.layerfader
          layer_info = txt
        else
          layer_color = colours.mainfader
          layer_info = 'DEFAULT LAYER'
        end
      end
      reaper.SetExtState('LBXVSS','[LAYER_INFO]',layer_info or '',false)
      reaper.SetExtState('LBXVSS','[LAYER_COLOR]',layer_color or '160 160 160',false)
    end
    
    --[[if str then
      local tpx = reaper.time_precise() - tp
      tp = reaper.time_precise()
      str = str ..'\nK '..round(tpx,8)
    end
    
    if str then
      local tpx = reaper.time_precise() - tp
      tp = reaper.time_precise()
      str = str ..'\nL '..round(tpx,8)
      DBG(str)
    end]]

    --A_ReadParamVals(true, true, true)
    
  end
  
  function GetFFX(force)
    
    if recmode ~= 0 then return end
    --if lvar.sk2data_setdata_delayaffectsfeedback and lvar.mode == 3 and reaper.time_precise() < (lvar.sk2data_setdata_delay or 0) then return end
     
    lvar.forcefocus = false
    if force then 
      --lvar.seltrackguid = nil
      otrguid = nil
      otrname = nil
      ofxguid = nil
    end

    local change
    local checkfx, ret = GetFocusedFX(force, FFX)
    if checkfx and CTMISSING == nil and (FFX == nil or FFX.fxguid ~= checkfx.fxguid or 
       FFX.fxnum ~= checkfx.fxnum or checkfx.trguid ~= FFX.trguid or checkfx.trname ~= FFX.trname or force == true) then

      change = true
      local a, b
      if FFX and lvar.tags.trackassoc[FFX.trname] then
        a = lvar.tags.trackassoc[FFX.trname].tag
      end
      if lvar.tags.trackassoc[checkfx.trname] then
        b = lvar.tags.trackassoc[checkfx.trname].tag
      end
      
      if lvar.tags.show and lvar.tags.tagshow_vis and a ~= b then
        ToggleShowTag(false)
      end
      
      --ResetLEDs()

      --[[if FFX and FFX.trn ~= checkfx.trn then
        SetAutoMode(FFX.trn,LBX_FX_TRACK_DEFAM)
      end]]
      FFX = checkfx
      --DBG('a')
      --SetAutoMode(FFX.trn,LBX_FX_TRACK_AM)
      --DBG('b')
      template = LoadFXParamTemplate(FFX)
      --if lvar.stripperlink and lvar.mode == 3 then
      --  lvar.loadffx = reaper.time_precise() + 0.5
      --else
        TemplateChanged()
      --end
      
      if CTMISSING == nil then
        lupd.update_gfx = true
        lupd.update_header = true
      end
      --DBG('z')
    elseif ret == 0 then
      --DBG(tostring(FFX)..'  '..tostring(checkfx))
      if FFX or checkfx ~= FFX or lvar.startup then

        change = true
        
        lvar.startup = nil
        FFX = nil
        ofxguid = nil
        template = {dirty = {},
                      pos = {},
                      sft = {}, 
                      eft = {}}
        for i = 1, lvar.fcount do
          template.dirty[i] = true
        end

        --[[lvar.readparams = nil
        ResetLEDs()
        --ResetFaderBox()
        updatetravellingtracknames(true)
        --SendScribbleData()
        A_ReadParamVals(true, true)
        SetUpCCStampData()
        
        DBG('Y')]]
        TemplateChanged()
        lupd.update_gfx = true
      end

      if lvar.focusedfx then
        lupd.update_gfx = true --slow
        lvar.focusedfx = nil
      end
      
    end
    
    if lvar.virtualss_active and change then
      reaper.SetExtState('LBXVSS','[TITLE_DIRTY]',1,false)
      if FFX then
        if lvar.mode == 3 then
          reaper.SetExtState('LBXVSS','[TITLE1]',FFX.trname,false)
        else
          reaper.SetExtState('LBXVSS','[TITLE1]',FFX.fxname,false)
        end
      else
        reaper.SetExtState('LBXVSS','[TITLE1]','',false)
      end
    end
    
    if settings.ccsend then
      local tr = reaper.GetSelectedTrack2(0, 0, true)
      if tr and (force or lvar.seltrackguid ~= reaper.GetTrackGUID(tr)) then
        SetCCSend(reaper.GetMediaTrackInfo_Value(tr, 'IP_TRACKNUMBER')) 
      end      
    end
    --SetCCs()
    
    
  end
  
  function BtnToggle(tmp, i, val)

  if not tmp.pos[i] then return end                 
    if not val then
      val = (16383-(tmp.pos[i].val or 0))/16383
    end
    
    --local track = GetTrack(FFX.trn)
    --local fxnum = FFX.fxnum
    local cc = tmp.pos[i].cc
    
    if cc ~= true then
      --local pnum = tmp.pos[i].pnum
      
      --reaper.TrackFX_SetParamNormalized(track, fxnum, pnum, val)
      SetFaderBoxVal(i, val*16383)
      tmp.dirty[i] = true
      octlval = val
      lupd.update_fader = true
    else
      SetCCVal(i, val, nil, tmp)
      SetFaderBoxVal(i, val*16383)
      tmp.dirty[i] = true
      octlval = val
      lupd.update_fader = true
    end
  end
  
  function GetSelectedAI(env, first)
    local sel = {}
    local cnt = reaper.CountAutomationItems(env)
    for i = 0, cnt-1 do
      local uisel = reaper.GetSetAutomationItemInfo(env,i,'D_UISEL',0,false)
      if uisel == 1 then
        local pos = reaper.GetSetAutomationItemInfo(env,i,'D_POSITION',0,false)
        local pid = reaper.GetSetAutomationItemInfo(env,i,'D_POOL_ID',0,false)
        local len = reaper.GetSetAutomationItemInfo(env,i,'D_LENGTH',0,false)
        local _, nm = reaper.GetSetAutomationItemInfo_String(env,i,'P_POOL_NAME','',false)
        sel[#sel+1] = {idx = i,
                       pos = pos,
                       len = len,
                       pid = pid,
                       nm = nm}
        if first then
          return sel
        end
      end
    end
    return sel  
  end
  
  function InsertAI_slow(amt)
    if lvar.ai.item and #lvar.ai.item > 0 then
          
      local tab = {env = {}}
      for t = 0, reaper.CountTracks(0)-1 do
        local track = GetTrack(t)
        local ecnt = reaper.CountTrackEnvelopes(track)
        local epos = 0
        for e = 0, ecnt-1 do
          local env = reaper.GetTrackEnvelope(track, e)
          local aicnt = reaper.CountAutomationItems(env)
          local apos = 1
          for a = 0, aicnt-1 do
            if reaper.GetSetAutomationItemInfo(env, a, 'D_UISEL', 0, false) == 1 then
              if not tab.env[epos+1] then 
                epos = epos + 1
                tab.env[epos] = {env = env, ai = {}}
              end
              local pos = reaper.GetSetAutomationItemInfo(env,a,'D_POSITION',0,false)
              local pid = reaper.GetSetAutomationItemInfo(env,a,'D_POOL_ID',0,false)
              local len = reaper.GetSetAutomationItemInfo(env,a,'D_LENGTH',0,false)
              local _, nm = reaper.GetSetAutomationItemInfo_String(env,a,'P_POOL_NAME','',false)
              tab.env[epos].ai[apos] = {idx = a,
                                        pos = pos,
                                        len = len,
                                        pid = pid,
                                        nm = nm}
              apos = apos + 1
            end
          end
        end
      end
    
      if #tab.env > 0 then

        local env = tab.env[1].env
        local nm = tab.env[1].ai[1].nm

        local dupidx = lvar.ai.nameidx[nm]
        local duppid, len
        if dupidx then
          dupidx = dupidx + amt
          if dupidx < 0 then dupidx = #lvar.ai.item
          elseif dupidx > #lvar.ai.item then dupidx = 0 end          

          duppid = lvar.ai.item[dupidx].pid
          len = lvar.ai.item[dupidx].len
        else
          duppid = lvar.ai.item[0].pid
          len = lvar.ai.item[0].len
        end
        if duppid then

          reaper.PreventUIRefresh(1)

          --Delete selected automation items
          reaper.Main_OnCommand(42086, 0)
          local resel = {}
          
          for e = 1, #tab.env do
            local env = tab.env[e].env
            local sel = tab.env[e].ai
            resel[e] = {}
            local rscnt = 1
            for i = 1, #sel do
              local idx = reaper.InsertAutomationItem(env, duppid, sel[i].pos, len)
              resel[e][rscnt] = {idx = idx}
              rscnt = rscnt + 1
            end
          end

          for e = 1, #tab.env do
            local env = tab.env[e].env
            --local sel = tab.env[e].ai

            for i = 1, #resel[e] do
              reaper.GetSetAutomationItemInfo(env,resel[e][i].idx,'D_UISEL',1,true)
              local _, nm = reaper.GetSetAutomationItemInfo_String(env,resel[e][i].idx,'P_POOL_NAME','',false)
              resel[e][i].nm = nm
            end
          end
                    
          reaper.Main_OnCommand(42084, 0)

          local npid            
          for e = 1, #tab.env do
            local env = tab.env[e].env
            for i = 1, #resel[e] do
              reaper.GetSetAutomationItemInfo_String(env,resel[e][i].idx,'P_POOL_NAME',resel[e][i].nm,true)
              if not npid then
                npid = reaper.GetSetAutomationItemInfo(env,resel[e][i].idx,'D_POOL_ID',0,false)
              else
                reaper.GetSetAutomationItemInfo(env,resel[e][i].idx,'D_POOL_ID',npid,true)
              end
            end
          end
          
          reaper.PreventUIRefresh(-1)
          
        end      

      else
        --insert
        local env = reaper.GetSelectedEnvelope(0)
        if env then
        
          local pos = reaper.GetCursorPosition()
          duppid = lvar.ai.item[0].pid
          len = lvar.ai.item[0].len
          if duppid then
            --Delete selected automation items
            reaper.PreventUIRefresh(1)
            reaper.Main_OnCommand(42086, 0)
            
            local resel = {}
            local idx = reaper.InsertAutomationItem(env, duppid, pos, len)
            resel[#resel+1] = {idx = idx}
  
            for i = 1, #resel do
              reaper.GetSetAutomationItemInfo(env,resel[i].idx,'D_UISEL',1,true)
              local _, nm = reaper.GetSetAutomationItemInfo_String(env,resel[i].idx,'P_POOL_NAME','',false)
              resel[i].nm = nm
            end
            reaper.Main_OnCommand(42084, 0)
            local npid            
            for i = 1, #resel do
              local _, nm = reaper.GetSetAutomationItemInfo_String(env,resel[i].idx,'P_POOL_NAME',resel[i].nm,true)
            end
  
            reaper.PreventUIRefresh(-1)
          
          end
        end
      end
    end
  end

  function DeleteSelectedAIs(env)

    --local t = reaper.time_precise()
    local _, chunk = reaper.GetEnvelopeStateChunk(env,'',true)
    if chunk then
      local chunk = string.gsub(chunk, 'POOLEDENVINST %d+ %d+[.%d]* %d+[.%d]* %d+[.%d]* %d+[.%d]* 1 .-\n', '')
      reaper.SetEnvelopeStateChunk(env,chunk,true)
    end
    --DBG(reaper.time_precise()-t)
      
  end

  function InsertAI(amt)
    if lvar.ai.item and #lvar.ai.item > 0 then
      local env = reaper.GetSelectedEnvelope(0)
      if env then
        local sel = GetSelectedAI(env)
        if #sel > 0 then
          --replace
          local dupidx = lvar.ai.nameidx[sel[1].nm]
          local duppid, len, amp, bas, plr
          if dupidx then
            dupidx = dupidx + amt
            if dupidx < 0 then dupidx = #lvar.ai.item
            elseif dupidx > #lvar.ai.item then dupidx = 0 end          

            duppid = lvar.ai.item[dupidx].pid
            len = lvar.ai.item[dupidx].len
            amp = lvar.ai.item[dupidx].amp
            bas = lvar.ai.item[dupidx].bas
            plr = lvar.ai.item[dupidx].plr
          else
            duppid = lvar.ai.item[0].pid
            len = lvar.ai.item[0].len
            amp = lvar.ai.item[0].amp
            bas = lvar.ai.item[0].bas
            plr = lvar.ai.item[0].plr
          end
          if duppid then
            reaper.Undo_BeginBlock()
            
            reaper.PreventUIRefresh(1)
                      
            --Delete selected automation items
            DeleteSelectedAIs(env)
            --reaper.Main_OnCommand(42086, 0)
            
            local resel = {}
            for i = 1, #sel do
              local idx = reaper.InsertAutomationItem(env, duppid, sel[i].pos, len)
              resel[#resel+1] = {idx = idx}
            end
            for i = 1, #resel do
              reaper.GetSetAutomationItemInfo(env,resel[i].idx,'D_UISEL',1,true)
              local _, nm = reaper.GetSetAutomationItemInfo_String(env,resel[i].idx,'P_POOL_NAME','',false)
              resel[i].nm = nm
            end
            reaper.Main_OnCommand(42084, 0)
            local npid            
            for i = 1, #resel do
              local _, nm = reaper.GetSetAutomationItemInfo_String(env,resel[i].idx,'P_POOL_NAME',resel[i].nm,true)
              if i == 1 then
                npid = reaper.GetSetAutomationItemInfo(env,resel[i].idx,'D_POOL_ID',0,false)
              else
                reaper.GetSetAutomationItemInfo(env,resel[i].idx,'D_POOL_ID',npid,true)
              end
              reaper.GetSetAutomationItemInfo(env,resel[i].idx,'D_AMPLITUDE',amp,true)
              reaper.GetSetAutomationItemInfo(env,resel[i].idx,'D_BASELINE',bas,true)
              reaper.GetSetAutomationItemInfo(env,resel[i].idx,'D_PLAYRATE',plr,true)              
            end

            reaper.PreventUIRefresh(-1)
            reaper.Undo_EndBlock("LBX Replace AI", 0)
            
          end
        else
          --insert
          local pos = reaper.GetCursorPosition()
          duppid = lvar.ai.item[0].pid
          len = lvar.ai.item[0].len
          if duppid then
            reaper.Undo_BeginBlock()
            
            --Delete selected automation items
            reaper.PreventUIRefresh(1)
            reaper.Main_OnCommand(42086, 0)
            
            local resel = {}
            local idx = reaper.InsertAutomationItem(env, duppid, pos, len)
            resel[#resel+1] = {idx = idx}

            for i = 1, #resel do
              reaper.GetSetAutomationItemInfo(env,resel[i].idx,'D_UISEL',1,true)
              local _, nm = reaper.GetSetAutomationItemInfo_String(env,resel[i].idx,'P_POOL_NAME','',false)
              resel[i].nm = nm
            end
            reaper.Main_OnCommand(42084, 0)
            local npid            
            for i = 1, #resel do
              local _, nm = reaper.GetSetAutomationItemInfo_String(env,resel[i].idx,'P_POOL_NAME',resel[i].nm,true)
            end

            reaper.PreventUIRefresh(-1)
            reaper.Undo_EndBlock("LBX Insert AI", 0)
          
          end
        end
      end
    end
  end
  
  function SetAIProperty(prop, val)
    if lvar.ai.item and #lvar.ai.item > 0 then
      local env = reaper.GetSelectedEnvelope(0)
      if env then
        local sel = GetSelectedAI(env)
        if #sel > 0 then
          for i = 1, #sel do
            reaper.GetSetAutomationItemInfo(env,sel[i].idx,prop,val,true)
          end
        end
      end
    end
    
  end
  
  function ScanAITrack(force)
    if LBX_AI_TRACK then
      local track = GetTrack(LBX_AI_TRACK)
      if track then
        local env = reaper.GetTrackEnvelope(track,0)
        if env then
          local cnt = reaper.CountAutomationItems(env)
          if cnt ~= lvar.ai.cnt or force then
            lvar.ai.cnt = cnt
            lvar.ai.item = {}
            lvar.ai.nameidx = {}
            lvar.ai.pididx = {}
            
            for i = 0, cnt-1 do
              local _, nm = reaper.GetSetAutomationItemInfo_String(env,i,'P_POOL_NAME','',false)
              local pid = reaper.GetSetAutomationItemInfo(env,i,'D_POOL_ID',0,false)
              local len = reaper.GetSetAutomationItemInfo(env,i,'D_LENGTH',0,false)
              local amp = reaper.GetSetAutomationItemInfo(env,i,'D_AMPLITUDE',0,false)
              local plr = reaper.GetSetAutomationItemInfo(env,i,'D_PLAYRATE',0,false)
              local bas = reaper.GetSetAutomationItemInfo(env,i,'D_BASELINE',0,false)
              
              reaper.GetSetAutomationItemInfo(env,i,'D_UISEL',0,true)
              --DBG(nm)
              lvar.ai.item[i] = {name = nm,
                                pid = pid,
                                len = len,
                                amp = amp,
                                bas = bas,
                                plr = plr}
              lvar.ai.nameidx[nm] = i
              lvar.ai.pididx[pid] = i
            end
          end
        end
      end
    end
  end
  
  function initialize()
  
    local rt = reaper.time_precise()
    
    if lvar.initstage == 1 then

      lvar.mainfade_active = true
      GUI_DrawMsg(obj, gui, {'LBX TJL SR SRD','','Smart Knobs 2', '', 'Version: '..lvar.version, '', 'Initializing', '', 'Please Wait...',''},{14,10,18,2}) 

      --Get control tracks
      local _, trackinfo = GetFOLTrack()
      lvar.trackinfo = trackinfo

      CheckAIGUID()
      ScanAITrack()
      --[[CheckFOLGUID()
      CheckCTLGUID()
      CheckCCGUID() 
      CheckINPUTGUID()
      CheckINGUID()
      CheckRRGUID()]]

      GetCtlTrackFound()  
      lvar.track_internal = 0
      if lvar.trackoffset_visibleonly > 0 then
        lvar.tracks_vis = Internal_VisibleTracks()
      end
      
      ResetFSet()
            
      --Reset control surface controls    
      ResetLEDs()
      ResetFaderBox()
      
      --reload perma template
      LoadGlobalMap(nil, nil, true)
      
      local gfn
      if not lvar.currentglobalmap or lvar.currentglobalmap == 1 then
        gfn = paths.globtemplate_path..LBX_DEFGLOBALTMP
      else  
        gfn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',lvar.currentglobalmap) ..'.smtemp'
      end
      LoadGlobalMap(gfn, lvar.currentglobalmap)
      --if not globtemplate then
      --  LoadGlobalMap(paths.globtemplate_path..LBX_DEFGLOBALTMP)
      --end
      
      lvar.running = 0
      time_delay = reaper.time_precise() + lvar.inittime[lvar.initstage]      
      lvar.initstage = 2
    elseif lvar.initstage == 2 then

      if rt > time_delay then

        ResendHandshake()
        SendSetUpSYSX()
        
        --Read settings
        --ResetFSet()
        GetFFX(true)
      
        time_delay = reaper.time_precise() + lvar.inittime[lvar.initstage]
        lvar.initstage = 3
      end
    elseif lvar.initstage == 3 then

      if rt > time_delay then
        
        --Read parameters
        A_ReadParamVals(true, true)
        --lvar.readparams = nil 
      
        time_delay = reaper.time_precise() + lvar.inittime[lvar.initstage]
        lvar.initstage = nil
        
        ShowVSS()
        
      end  
    end
    
  end
  
  function ResendHandshake()
    --resend handshake
    local tmp = ctl_template
    for d = 1, 4 do
      if tmp.devsysx[d-1] and tmp.devsysx[d-1].handshake then
        SetUpHandshake(d-1, tmp.devsysx[d-1].handshake)
      end
    end
  end
  
  function GetLastTouchedParam()
    local ret, trnum, fxnum, pnum = reaper.GetLastTouchedFX()
    if ret == true then
      if not lvar.ctltracks[trnum] then
        lvar.lasttouchedparam = {}
        lvar.lasttouchedparam.trnum = trnum 
        lvar.lasttouchedparam.fxnum = fxnum 
        lvar.lasttouchedparam.pnum = pnum
      end
    end
  end
  
  function LearnMenu(x, y)
  
    local l1, l2 = '', ''
    if lvar.fxlearnmode == 0 then
      l1 = '!'
    else
      l2 = '!'
    end
    mstr = l1..'Link to specific plugin|'..l2..'Link to specific plugin type'
    gfx.x = x
    gfx.y = y
    local res = gfx.showmenu(mstr)
    if res then
      if res == 1 then
        lvar.fxlearnmode = 0
        lupd.update_gfx = true
      elseif res == 2 then
        lvar.fxlearnmode = 1 
        lupd.update_gfx = true
      end
    end
  
  end
  
  function LearnPlug(i)
    
    if lvar.mode == 3 then --track mode
      local lt = lvar.lasttouchedparam
      if lt then

        tmpX = GetTemplatePos(i, true)
        if tmpX and tmpX.ptype == ptype.internal and tmpX.code == 18 and tmpX.codeval <= lvar.qfx_faders then
        
          --Learn to QFX fader
          local idx = tmpX.codeval
          lvar.qfx_data[lvar.qfx_bank*lvar.qfx_faders+idx] = QFX_Learn()
          lvar.readparams = nil
          SaveQFX(lvar.qfx_bank*lvar.qfx_faders+idx)
          lupd.update_gfx = true
        
        else
          local track = GetTrack(lt.trnum)
          if track then
            local tguid = reaper.GetTrackGUID(track)
            local fxguid = reaper.TrackFX_GetFXGUID(track, lt.fxnum, lt.pnum)
            local _, pname = reaper.TrackFX_GetParamName(track, lt.fxnum, lt.pnum, '')
            local _, fxmodule = reaper.BR_TrackFX_GetFXModuleName(track, lt.fxnum)
            local slot = i
            local tmp, tmplayer 
            if lvar.showglobalmap then
              tmp = globtemplate
              tmplayer = 1
            elseif lvar.overtemplate_active then
              if not template.layer then
                template.layer = {}
              end
              if not template.layer[lvar.overtemplate] then
                template.layer[lvar.overtemplate] = {dirty = {},
                                                    pos = {},
                                                    sft = {},
                                                    eft = {}}
              end
              tmp = template.layer[lvar.overtemplate]
              tmplayer = 0
            else
              tmplayer = 0
              tmp = template
            end
            
            --local tmp = GetTemplate(slot, false, true, true)
            local globalhost = 1
            if lvar.fxlearnmode == 1 then
              globalhost = 2
            end
            if tmp then
  
              tmp.pos[slot] = Assign_GetDefaultGlobalHost_Tab(ptype.host,globalhost,lt.trnum,tguid,lt.fxnum,fxguid,lt.pnum,pname,7,fxmodule)
              if ctl_template.fader[slot].lmode == 4 then
                
                local gmem = reaper.gmem_write
                tmp.pos[slot].butstates_arrayidx = {}
                
                for b = 1, tmp.pos[slot].butstates do
                
                  if tmp.pos[slot].ptype == ptype.host then
                    tmp.pos[slot].butstates_arrayidx[math.ceil(tonumber(tmp.pos[slot].butstates_array[b]*100000))/100000] = b
                  else
                    tmp.pos[ii].butstates_arrayidx[tmp.pos[slot].butstates_array[b]] = b
                  end
                 
                end
              end
              lupd.update_gfx = true
              TemplateChanged()
              if tmplayer == 1 then
                lvar.saveglob_highlight = true
              else
                lvar.save_highlight = true
              end
            end
          end
        end
      end
      
    else
    
    end
  
  end
  
  function ClearSlot(i)

    local tmp, gflag
    tmp, gflag = GetTemplate(i)
    
    lvar.readparams = nil
    
    tmp.pos[i] = nil
    tmp.dirty[i] = true
    lupd.update_fader = true
    SetCCs()
    updatetravellingtracknames(true)
    SetUpCCStampData()
    
    if gflag == 3 then
      lvar.saveperm_highlight = true
    elseif gflag == 2 then
      lvar.saveglob_highlight = true
    else
      lvar.save_highlight = true
    end
    
    SelectFader2(i, false)
    
    lupd.update_gfx = true
    
  end
  
  function GetAssignmentDisplay()
    local str, dp1, dp2 = '',false,false
    
    if lvar.showglobalmap and lvar.AKLayerMode == 0 then
      if lvar.currentglobalmap > 9 then
        str = 'G'..string.format('%i',lvar.currentglobalmap-10)
        dp1 = true
      else
        str = 'G'..string.format('%i',lvar.currentglobalmap)
      end
    elseif lvar.overtemplate_active then
      if lvar.overtemplate > 9 then
        str = 'L'..string.format('%i',lvar.overtemplate-10)
        dp1 = true
      else
        str = 'L'..string.format('%i',lvar.overtemplate)
      end
    else
      str = 'df'
    end
    return str, dp1, dp2
  end
  
  function DisplayLayerAssignment(assstr, d1dp, d2dp)

    local d1 = (string.sub(assstr,1,1))
    local d2 = (string.sub(assstr,2,2))
    for d = 0, 3 do      
      if lvar.ass_display[d] then
        local v1 = lvar.ass_display[d].chars[d1]
        local v2 = lvar.ass_display[d].chars[d2]
        local cc1, cc2
        if not d1dp then
          cc1 = lvar.ass_display[d].cc[1]
        else
          cc1 = lvar.ass_display[d].ccdp[1]
        end
        if not d2dp then
          cc2 = lvar.ass_display[d].cc[2]
        else
          cc2 = lvar.ass_display[d].ccdp[2]
        end
        if v1 and v2 and cc1 and cc2 then
          local dev = lvar.hardout[d]
          if dev then
            reaper.StuffMIDIMessage(16+dev, 176, cc1, v1)
            reaper.StuffMIDIMessage(16+dev, 176, cc2, v2)
          end
        end
      end
    end
  end
  
  function CheckTracks()
    
    local rescan
    lvar.ct_data = lvar.ct_data or {}
    for tt = 0, lvar.checktracks_rrobin-1 do
      local t = (lvar.checktracks + tt) % reaper.CountTracks(0)
      local track = GetTrack(t)
      if track then
        lvar.ct_data[t] = lvar.ct_data[t] or {}
        local tn, flags = reaper.GetTrackState(track)
        if lvar.trackoffset_visibleonly > 0 then
          if (flags&512==512) ~= lvar.ct_data[t].tcp then
            lvar.ct_data[t].tcp = (flags&512==512)
            rescan = true
          end
          if (flags&1024==1024) ~= lvar.ct_data[t].mcp then
            lvar.ct_data[t].mcp = (flags&1024==1024)
            rescan = true
          end
        end
        if tn ~= lvar.ct_data[t].tn then
          lvar.ct_data[t].tn = tn
          rescan = true
        end
      end
    end
    lvar.checktracks = (lvar.checktracks + lvar.checktracks_rrobin) % reaper.CountTracks(0)

    if rescan then
      if lvar.trackoffset_visibleonly > 0 then
        lvar.tracks_vis = Internal_VisibleTracks()
      end
      updatetravellingtracknames(true)
      lvar.readparams = nil
    end
    
    
  end
  
  function run()  
    --DBGOut('run')
    
    local rt = reaper.time_precise()
    local lvar = lvar
    
    if lvar.assignmentdisplay and lvar.assignmentdisplay_active then
      
      if lvar.AKLayerMode == 0 or lvar.AKLayerMode == 1 then
        if lvar.showglobalmap ~= lvar.showglobalmap_o or 
           (lvar.showglobalmap and lvar.currentglobalmap ~= lvar.currentglobalmap_o) then
          local str, dp1, dp2 = nil, false, false
          if lvar.showglobalmap then
            --show global layer
            if lvar.currentglobalmap > 9 then
              str = 'G'..string.format('%i',lvar.currentglobalmap-10)
              dp1 = true
            else
              str = 'G'..string.format('%i',lvar.currentglobalmap)
            end
          else
            --show beneath layer
            str, dp1, dp2 = GetAssignmentDisplay()
          end
          DisplayLayerAssignment(str, dp1, dp2)
          local check = str..tostring(dp1)..tostring(dp2)
          lvar.assstr_old = check
          lvar.ass_display.timer = reaper.time_precise() + 2
          
          lvar.currentglobalmap_o = lvar.currentglobalmap
          lvar.showglobalmap_o = lvar.showglobalmap
          
        elseif lvar.overtemplate_active ~= lvar.overtemplate_active_o or 
           (lvar.overtemplate_active and lvar.overtemplate ~= lvar.overtemplate_o) then
          local str, dp1, dp2 = nil, false, false
          if lvar.overtemplate_active then
            if lvar.overtemplate > 9 then
              str = 'L'..string.format('%i',lvar.overtemplate-10)
              dp1 = true
            else
              str = 'L'..string.format('%i',lvar.overtemplate)
            end
          else
            --show beneath layer
            str = 'df'
          end
          DisplayLayerAssignment(str, dp1, dp2)
          local check = str..tostring(dp1)..tostring(dp2)
          lvar.assstr_old = check
          lvar.ass_display.timer = reaper.time_precise() + 2
          
          lvar.overtemplate_active_o = lvar.overtemplate_active
          lvar.overtemplate_o = lvar.overtemplate
        end
          
        if (lvar.ass_display.timer or -1) > 0 then
          if reaper.time_precise() > (lvar.ass_display.timer or -1) then
            lvar.ass_display.timer = nil
          end
        
        else
        
          local assstr, d1dp, d2dp = GetAssignmentDisplay()
          local check = assstr..tostring(d1dp)..tostring(d2dp)
          if check ~= lvar.assstr_old then
            DisplayLayerAssignment(assstr, d1dp, d2dp)
            lvar.assstr_old = check
          end
        
        end
      elseif lvar.AKLayerMode > 1 then
        assstr = '--'
        local check = assstr..tostring(false)..tostring(false)
        if check ~= lvar.assstr_old then
          DisplayLayerAssignment(assstr, false, false)
          lvar.assstr_old = check
        end
      end
      
    elseif lvar.assignmentdisplay then
      assstr = '  '
      local check = assstr
      if check ~= lvar.assstr_old then
        DisplayLayerAssignment(assstr, false, false)
        lvar.assstr_old = check
      end
    end
      
    if lvar.timecodedisplay == true then
      local pos
      local playstate = reaper.GetPlayState()
      if playstate ~= oplaystate2 then
        local track = GetTrack(LBX_CTL_TRACK)
        if track then
          reaper.TrackFX_SetParam(track, 0, 62, 1) --trigger reset of stored digits
        end
        oplaystate2 = playstate
      end

      if playstate > 0 then
        pos = reaper.GetPlayPosition()
      else
        pos = reaper.GetCursorPosition()
      end

      if lvar.tcactive then
        local timestr = reaper.format_timestr_pos(pos, '', 5)
        local beatsstr = reaper.format_timestr_pos(pos, '', 2)
        local hours, mins, sec, frames = string.match(timestr, '(%-*%d+):(%d+):(%d+):(%d+)')
        local bars, beats, sub = string.match(beatsstr, '(%-*%d+).(%d+).(%d+)')
        local gmem = reaper.gmem_write
  
        for d = 0, 3 do      
        
          if lvar.tc_display[d] then
            local tc_disp = lvar.tc_display[d]
            local fdisp
            if lvar.timecodedisplayformat == 0 then
              fdisp = string.format(tc_disp.timeformat,hours,mins,sec,frames)
              lvar.fdisp2 = timestr
            else
              fdisp = string.format(tc_disp.beatformat,bars,beats,sub,frames)
              lvar.fdisp2 = beatsstr
            end
  
            if fdisp ~= lvar.fdisp then
              lvar.fdisp = fdisp
              for i = 1, string.len(fdisp) do
                gmem(lvar.gm_fb.pos_time+(d*16)+(i-1),tc_disp.chars[string.sub(fdisp,i,i)])
              end
            end
          end
        end
      end
      
    end

    if lvar.fflash_duration ~= -1 and lvar.grpflash_timer and rt >= lvar.grpflash_timer then
      lvar.grpflash_timer = nil
      HLGroupButtons2()
    end
    --DBG(reaper.time_precise()-rt)  
    --DBG(reaper.gmem_read(500000))
    
    
    if reaper.Audio_IsRunning() == 1 then
      if lvar.reset then
        lvar.msg = nil
        lvar.reset = nil
        SetMode(lvar.mode)
        lvar.readparams = nil
        lupd.update_gfx = true
      end
      if not lvar.initstage and rt > lvar.sysx_buf_timer and not lvar.sysxinactive then

        if not lvar.disableSSplayback or lvar.forceSSupdate or reaper.GetPlayState() == 0 then
          if not Empty_SysXBuffer() then
            lvar.sysxinactive = true
          end
          lvar.forceSSupdate = nil
        end
        lvar.sysx_buf_timer = rt +lvar.sysx_buf_time
      end
      CheckMasterTrackSolo()
    else
      lvar.msg = 'Audio Not Running'
      lvar.reset = true
      reaper.Audio_Init()
    end
  
    if lvar.display_overlay_active then
      
      --local del = false
      local data = lvar.display_overlay
      --local dataidx = lvar.display_overlay_idx
      local dflag = 0
      local dc = #data
      for d = 1, dc do
        if reaper.time_precise() >= data[d].timeout then
          data[d] = nil
          dflag = dflag + 1
        end
      end
      if dflag > 0 then
        local dt = {}
        local di = {}
        local c = 1
        for d = 1, dc do
          if data[d] then
            local i = data[d].i
            dt[c] = data[d]
            di[i] = c
            c=c+1
          end
        end
        lupd.update_overlay = true      
        lvar.display_overlay_idx = di
        lvar.display_overlay = dt
      end
    end
      
    --[[if round(rt) ~= ort then
      DBG(round(rt))
      ort = round(rt)
    end]]
  
    if gfx.w ~= last_gfx_w or gfx.h ~= last_gfx_h or force_resize or obj == nil then
      local r = false
      if not r or gfx.dock(-1) > 0 then
        gfx1.main_w = math.max(gfx.w,250)
        gfx1.main_h = gfx.h
        win_w = gfx.w
        win_h = gfx.h

        last_gfx_w = gfx.w
        last_gfx_h = gfx.h
                
        gui = GetGUI_vars()
        obj = GetObjects()
        
        lupd.resize_display = true
        lupd.update_gfx = true        
      end
    end
    
    -- Check if project has changed
    
    local proj = reaper.GetProjectName(0, '')
    if proj ~= lvar.projname then

      LoadSetUp_Proj()
      lvar.initstage = 1
      lvar.livemode = 0

      lvar.projname = proj
      lvar.readparams = nil
    
      LoadQFX()
      
      --ResendHandshake()
      --lvar.resendhs_delay = reaper.time_precise() + 2
      
      lvar.reset = true
    end

    if lvar.initstage then

      initialize()
      
    else
      
      lvar.lasttouchparam = GetLastTouchedParam()
      
      if lvar.checktracks then
        --local t = reaper.time_precise()
        CheckTracks()
        --DBG(reaper.time_precise() - t)
      end
      --[[if rt > (lvar.loadffx or math.huge) then
        lvar.loadffx = nil
        TemplateChanged()
      end]]
      
      --Allow quicker track changing 
      if lvar.sk2data_setdata and lvar.sk2data_setdata_delay then
        local tr = reaper.GetSelectedTrack2(0,0,true)
        if tr == lvar.oldtrack then
          lvar.dcount = (lvar.dcount or 1) + 1
        else
          lvar.oldtrack = tr
          lvar.dcount = 1
        end
        if lvar.dcount > 3 then
          lvar.dcount = 1
          lvar.sk2data_setdata_delay = nil
          lvar.sk2go = true
        end
      end

      if lvar.sk2go or (lvar.sk2setdata_spos or 1) > 1 or (lvar.sk2data_setdata and rt > lvar.sk2data_setdata) then
        lvar.sk2go = false
        SK2Data_SetData(lvar.sk2setdata_spos or 1)
      end
          
      if lvar.flash_scribble_timer and rt > lvar.flash_scribble_timer then
        for i = 1, #lvar.flash_scribble do
          local fi = lvar.flash_scribble[i]
          local dev = ctl_template.fader[fi].devbus
          local ii = ctl_template.fader[fi].ssnum --or i

          if lvar.ctlgroup_select == 0 then
            
            local tmp
            tmp = GetTemplate(ii)
            if tmp then
              tmp2 = GetTemplate(fi)
              if tmp2 and tmp2.pos[fi] and tmp2.pos[fi].ss_override then
                ii = lvar.ssnumidx[tmp2.pos[fi].ss_override]
                tmp = GetTemplate(ii)
              end
              --[[if lvar.remap_active then
                ii = lvar.remap.ctl2[ii] or ii
              end]]
              --DBG(tostring(tmp)..'  '..tostring(globtemplate)..'  '..tostring(template)..'  '..tostring(lvar.showglobalmap)..'  '..ii)
              SendScribbleData2(tmp, nil, ii)
            end
          
          else

            local g = lvar.ctlgroup_select
            local gidx = lvar.groupidx[g]
            local sstab = {}
            local i, ssnum, devbus
            if lvar.groupctlidx[gidx] then
              for a, b in pairs(lvar.groupctlidx[gidx]) do
                ssnum = ctl_template.fader[b].ssnum
                if ssnum == ii then
                  i = b
                  devbus = ctl_template.fader[b].devbus
                  break
                end
              end
              if ssnum and i then
                local tmp
                tmp = GetTemplate(i)
                if tmp and ctl_template.fader[i] and tmp.pos[i] then
                  sstab[ssnum] = 1
                  SendScribbleData2(tmp, nil, i)
                end
              end
            end

            if not sstab[ssnum] then
              local i = ii
              if lvar.ctlgroup_scribblemode == 0 and ctl_template.fader[i].devbus == devbus then 
                SendScribbleData2({pos={}}, nil, i)
              else
                local tmp
                tmp = GetTemplate(i)
                if tmp and ctl_template.fader[i] and i == ctl_template.fader[i].ssnum then
                  if not SendScribbleData2(tmp, nil, i) then
                    break
                  end
                end              
              end
            end
          end
          
        end
        lvar.flash_scribble = nil
        lvar.flash_scribble_idx = nil
        lvar.flash_scribble_timer = nil
      end
    
      --if lrnmode == false then
      
        if lvar.running < 2 then
          if rt > time_delay+1 then
            lvar.running = 2          
            
          elseif rt > time_delay then
            lvar.running = 1
          end
        end
        
        --useful way to disable feedback when track in read mode...
        
        if not lvar.fbcconseek or reaper.GetPlayState() == 0 then
          if FBActive2() ~= 1 then
            FBToggle2()
          end
        else
          if FBActive2() ~= 0 then
            FBToggle2()
          end
        end

        CheckFOLGUID()
        local ccchk, cctrack = CheckCCGUID()
        CheckINPUTGUID()
        if LBX_IN_TRACK then
          CheckINGUID()
        end
        local rrchk, rrtrack
        if settings.rrmode then
          rrchk, rrtrack = CheckRRGUID()
        end
        
        local ctlchk, track = CheckCTLGUID()
        
        if lvar.getfound then
          GetCtlTrackFound()
          lvar.getfound = nil
        end
        
        if (lvar.autofocus and reaper.gmem_read(lvar.props.visible) == 0) or lvar.forcefocus then
          --FFX, ret = GetFFX(not ctlchk, FFX)
          if lvar.running then
            lvar.forcefocus = false
            GetFFX(not ctlchk)
          end
        end
        ScanAITrack()
        
        --set lanes
        if lvar.update_midieditor_cclanes == true then

          local hwnd = reaper.MIDIEditor_GetActive()
      
          if hwnd then
          
            local lanestr = ''
            local lanetab = {}
            
            local hwnd2 = reaper.JS_Window_FindChild(hwnd, 'midipianoview', true)
            
            if hwnd2 then
              local arr = reaper.new_array({}, 200)
              reaper.JS_Window_ArrayAllChild(hwnd2, arr)

              local cbarr = arr.table()
              local lane = 1
              local data = {}
              for a, b in pairs(cbarr) do
                local cb_hwnd = reaper.JS_Window_HandleFromAddress(cbarr[a])
                local _, _, t, _, _ = reaper.JS_Window_GetRect(cb_hwnd)
                data[lane] = {hwnd = cb_hwnd,
                              id = cbarr[a],
                              top = t}
                lane = lane + 1
              end           
              
              local fixedcnt = 0
                        
              --Calc VELLANE String
              local _, trnm = GetCCLanesTrack()
              
              if lvar.lanes_xtra.velshow and not lvar.lanes_xtra.velbottom then
                lanestr = lanestr .. '\nVELLANE -1 '..string.format('%i',lvar.midieditor_cclanes_h)..' 0'
                lanetab[#lanetab+1] = 0
                fixedcnt = fixedcnt + 1
              end
              
              if trnm and lvar.lanes_xtra[trnm] then
                for sl = 1, 4 do
                  if lvar.lanes_xtra[trnm][sl] and (lvar.lanes_xtra[trnm][sl].show or lvar.midieditor_cclanes_showallfixed) then
                    if not lvar.lanes_xtra[trnm][sl].bottom then
                      local tab = lvar.cclanes[lvar.lanes_xtra[trnm][sl].tabidx]
                      lanestr = lanestr .. '\nVELLANE '.. string.format('%i',tab.val) ..' '..string.format('%i',lvar.midieditor_cclanes_h)..' 0'
                      lanetab[#lanetab+1] = tab.idx
                      fixedcnt = fixedcnt + 1
                    end
                  end
                end
              end
              
              if lvar.midieditor_cclanes_offset == -1 and (not lvar.lanes_ov_tab[trnm] or not lvar.lanes_ov_enable) then
                lvar.midieditor_cclanes_offset = 0
              end
              if lvar.midieditor_cclanes_offset >= #lvar.idx_cc then 
                lvar.midieditor_cclanes_offset = math.max(#lvar.idx_cc-lvar.midieditor_cclanes_max,0)
              end
              
              --auto lanes
              local autocnt = 0
              if not lvar.midieditor_cclanes_showallfixed then
              
                for lane = 1, lvar.midieditor_cclanes_max do
                  local tmppos
                  local i = lvar.idx_cc[lane + lvar.midieditor_cclanes_offset]
                  if not i then break end
                  
                  tmppos = GetTemplatePos(i)
                  
                  if tmppos then
                    local ccnum = tmppos.ccnum
                    if tmppos.cc14bit == 1 then
                      lanetab[#lanetab+1] = 129+ccnum
                      ccnum = ccnum + 134
                    else
                      lanetab[#lanetab+1] = 9+ccnum
                    end
                    --local cidx = 9+tmppos.ccnum
                    autocnt = autocnt + 1
                    if not lvar.midieditor_cclanes_hideallauto then
                      lanestr = lanestr .. '\nVELLANE '..string.format('%i',ccnum)..' '..string.format('%i',lvar.midieditor_cclanes_h)..' 0'            
                    end
                  end
                end
                
              end
              
              if trnm and lvar.lanes_xtra[trnm] then
                for sl = 1, 4 do
                  if lvar.lanes_xtra[trnm][sl] and (lvar.lanes_xtra[trnm][sl].show or lvar.midieditor_cclanes_showallfixed) then
                    if lvar.lanes_xtra[trnm][sl].bottom then
                      local tab = lvar.cclanes[lvar.lanes_xtra[trnm][sl].tabidx]
                      lanestr = lanestr .. '\nVELLANE '.. string.format('%i',tab.val) ..' '..string.format('%i',lvar.midieditor_cclanes_h)..' 0'
                      lanetab[#lanetab+1] = tab.idx
                      fixedcnt = fixedcnt + 1
                    end
                  end
                end
              end
              if lvar.lanes_xtra.velshow and lvar.lanes_xtra.velbottom then
                lanestr = lanestr .. '\nVELLANE -1 '..string.format('%i',lvar.midieditor_cclanes_h)..' 0'
                lanetab[#lanetab+1] = 0
                fixedcnt = fixedcnt + 1
              end

              if lanestr == '' then
                lanestr = '\nVELLANE 0 0 0'
              end

              --Check visible lane count
              if #lanetab ~= #data or lvar.midieditor_cclanes_fast ~= true then

                --different number of lanes - use chunk
            
                local take = reaper.MIDIEditor_GetTake(hwnd)
                if take and reaper.ValidatePtr2(0, take, "MediaItem_Take*") then
                  --local status, retval = pcall(reaper.GetMediaItemTake_Item, take) --handle possible error when duplicating a track
                  --if status then
                  
                    local item = reaper.GetMediaItemTake_Item(take)
                    --local item = retval
                    local retval, chunk = reaper.GetItemStateChunk(item, '', false)
                    
                    local newh_ov
                    
                    local track, trnm = GetCCLanesTrack()
                    if track then
                    
                      --Height multiplier
                      local hmult
                      if lvar.midieditor_cclanes_heightmulti ~= 1 then
                        hmult = lvar.midieditor_cclanes_heightmulti
                      end
                      local hm = lvar.midieditor_cclanes_hmulti
                      
                      if lvar.lanes_ov_tab[trnm] and lvar.lanes_ov_enable and lvar.midieditor_cclanes_offset == -1 then
                        lanestr = lvar.lanes_ov_tab[trnm].all
                      end                     
                      if hmult ~= 1 then
                        local lanes = mysplit(lanestr, '\n')
                        lanestr = ''
                        for l = 1, #lanes do
    
                            lanestr = lanestr .. '\n' ..string.gsub(lanes[l],
                                        'VELLANE ([-]?%d+) (%d+) (%d+)', 
                                        function(a, b, c) 
                                          return 'VELLANE '..a..' '..string.format('%i',math.floor(tonumber(b)*(hmult or (hm[l] or 1))))..' '..c 
                                        end)
    
                        end
                      end
                    
                      if lvar.lanes_ov_tab[trnm] and lvar.lanes_ov_enable and lvar.midieditor_cclanes_offset == -1 then
                        --lanestr = lvar.lanes_ov_tab[trnm].all
                        if lvar.midieditor_cclanes_solo then
                          newh_ov = CalcSoloLaneHeight_Ov(lanestr)
                        end
                      elseif lvar.midieditor_cclanes_hideallauto then
                        if fixedcnt > 0 then
                          local newh = math.floor(((fixedcnt + autocnt) * lvar.midieditor_cclanes_h) / fixedcnt)
                          lanestr = string.gsub(lanestr, 'VELLANE ([-]?%d+) (%d+) (%d+)', 'VELLANE %1 '..string.format('%i',newh)..' %3')
                          newh_ov = CalcSoloLaneHeight_Ov(lanestr)
                        end
                      else
                        newh_ov = CalcSoloLaneHeight_Ov(lanestr)
                      end
                      if lvar.midieditor_cclanes_solo then
                        if lvar.midieditor_cclanes_solovel then
    
                          --local newh = math.floor((fixedcnt + autocnt) * lvar.midieditor_cclanes_h)
                          lanestr = '\nVELLANE -1 '..string.format('%i',newh_ov or newh)..' 0'            
    
                        elseif lvar.midieditor_cclanes_solo_assign then
        
                          --local newh = math.floor((fixedcnt + autocnt) * lvar.midieditor_cclanes_h)
                          local tmppos
                          local i = lvar.idx_cc[lvar.midieditor_cclanes_solo_assign]
                          if i then
                          
                            tmppos = GetTemplatePos(i)
                            --[[if permatemplate.pos[i] then
                              tmppos = permatemplate.pos[i]
                            elseif globtemplate.pos[i] and lvar.showglobalmap then
                              tmppos = globtemplate.pos[i]
                            else
                              tmppos = template.pos[i]
                            end]]
                            
                            if tmppos then
                              local ccnum = tmppos.ccnum
                              if tmppos.cc14bit == 1 then
                                lanetab[#lanetab+1] = 129+ccnum
                                ccnum = ccnum + 134
                              else
                                lanetab[#lanetab+1] = 9+ccnum
                              end
                              --if not lvar.midieditor_cclanes_hideallauto then
                                lanestr = '\nVELLANE '..string.format('%i',ccnum)..' '..string.format('%i',newh_ov or newh)..' 0'            
                              --end
                            else
                              lvar.midieditor_cclanes_solo = false
                              lvar.midieditor_cclanes_solo_assign = nil
                            end
                          else
                            lvar.midieditor_cclanes_solo = false
                            lvar.midieditor_cclanes_solo_assign = nil                      
                          end
                          
                        else
                          --local newh = math.floor((fixedcnt + autocnt) * lvar.midieditor_cclanes_h)
                          local lanes = mysplit(lanestr, '\n')
                          if lvar.midieditor_cclanes_sololane > #lanes then
                            lvar.midieditor_cclanes_sololane = 1
                          elseif lvar.midieditor_cclanes_sololane < 1 then
                            lvar.midieditor_cclanes_sololane = #lanes
                          end
                          if lanes[lvar.midieditor_cclanes_sololane] then
                            lanestr = '\n'..string.gsub(lanes[lvar.midieditor_cclanes_sololane],
                                                  'VELLANE ([-]?%d+) (%d+) (%d+)', 'VELLANE %1 '..string.format('%i',newh_ov or newh)..' %3')
                          end
                        end
                      
                      end
                    end
                    chunk = chunk:gsub("\nVELLANE [^\n]+", "") -- Remove all existing CC lane fields
                    chunk = chunk:gsub("(\nIGNTEMPO [01] [^\n]+)", "%1" .. lanestr) -- Assume that all take chunks must have IGNTEMPO field
                    
                    reaper.SetItemStateChunk(item, chunk, false)
                    lvar.update_midieditor_cclanes = false
                  --end
                end
              else

                --required lanes are visible - use combobox 
                        
                local CB_SETCURSEL = "0x014E"
                local WM_COMMAND = "0x0111"
                local CBN_SELCHANGE = 1
                local CB_GETCURSEL = "0x0147"
                local CB_GETLBTEXT = "0x0148"
                
                --[[txt2 = {}
                for t = 0, 160 do
                  reaper.JS_WindowMessage_Send(data[1].hwnd, CB_SETCURSEL, t, 0,0,0)
                  local xx = reaper.JS_WindowMessage_Send(data[1].hwnd, CB_GETCURSEL, t, 0,0,0)
                  local txt = reaper.JS_Window_GetTitle(data[1].hwnd)
                  --DBG(t..'  '..xx..'  '..tostring(txt))
                  DBG("lvar.cclanes["..string.format('%i',t+1) .."] = {txt = '"..txt.."', val = "..string.format('%i',t) ..", idx = "..string.format('%i',t).."}")
                end]]
                
                --local data = table_slowsort_gen(data, 'top') 
                local data = table_sort(data, 'top')
                
                local lane = 1
                
                reaper.Undo_BeginBlock()
                
                for lane = 1, #lanetab do

                  local cidx = lanetab[lane]
                  --local xx = reaper.JS_WindowMessage_Send(data[lane].hwnd, CB_GETCURSEL, cidx, 0,0,0)
                  reaper.JS_WindowMessage_Send(data[lane].hwnd, CB_SETCURSEL, cidx, 0,0,0)
                  reaper.JS_WindowMessage_Send(hwnd2, WM_COMMAND, data[lane].id, CBN_SELCHANGE, data[lane].id, 0)
                  
                end
                
                reaper.Undo_EndBlock('SK2: CC Lane Change', -1)
                
                lvar.update_midieditor_cclanes = false
              end
            end
            lvar.update_midieditor_cclanes = false
            
          end
        end
        
        if lvar.update_envelopes then
          Update_Envelopes()
          lvar.update_envelopes = nil
        end
        
        local recmon = reaper.GetExtState(SCRIPT,'ACTIVATE_REC')
        if recmon ~= '' then
          recmode = 1-recmode
          SetRecMode(recmode)
          lupd.update_gfx = true
          reaper.DeleteExtState(SCRIPT,'ACTIVATE_REC',true)
        end
        
        local remote_ctl = reaper.GetExtState(REMSCRIPT,'REMOTE_CTL')
        if remote_ctl ~= '' then
          local func = remote_funcs[remote_ctl]
          if func then
            local remote_data
            if reaper.HasExtState(REMSCRIPT,'REMOTE_DATA') then
              remote_data = reaper.GetExtState(REMSCRIPT,'REMOTE_DATA') 
            end
            func(remote_ctl, remote_data)
          end
          reaper.DeleteExtState(REMSCRIPT,'REMOTE_CTL',true)
          reaper.DeleteExtState(REMSCRIPT,'REMOTE_DATA',true)
        end
          
        if lvar.running == 2 then
          local rv = A_GetFaderBoxVals()
        end
        --if recmode == 0 then -- IS THIS OK TO COMMENT OUT???  NOT SURE WHY IT WAS THERE :|
          local fb = false
          if lvar.running then
            fb = true
          end          
          A_ReadParamVals(fb, true)
        --end
  
        --MIDI Chase
        local playstate = reaper.GetPlayState()
        if lvar.autochase then
          local chasenow
          if lvar.trigdelay and reaper.time_precise() > lvar.trigdelay then
            chasenow = true
            --TriggerCCChase()
            lvar.trigdelay = nil
          end
          if playstate == 0 or (playstate & 2) == 2 then
            local epos = reaper.GetCursorPosition()
            local seltrk = reaper.GetSelectedTrack2(0,0,true)
            if epos ~= lvar.last_epos or seltrk ~= lvar.oseltrk then
              lvar.oseltrk = seltrk
              lvar.last_epos = epos
              --only call triggerccchase after delay or buttons get reset
              --lvar.trigdelay = reaper.time_precise() + lvar.trigdelaytime
              chasenow = true
              --TriggerCCChase()
            end    
          else
            lvar.last_epos = nil
          end
          if chasenow then
            TriggerCCChaseX()
          end
        end
        
        --CC Stamp
        if lvar.ccstamp_active == 1 then
          if playstate & 4 == 4 and oplaystate ~= playstate then
            --recording triggered 
            TriggerCCStamp()
            lvar.last_ppos = reaper.GetPlayPosition()
          elseif playstate & 4 == 4 then
            local ppos = reaper.GetPlayPosition()
            if ppos < (lvar.last_ppos or ppos) then
              --recording looped
              TriggerCCStamp()
            end
            lvar.last_ppos = ppos
          end    
  
          if playstate ~= oplaystate then
            oplaystate = playstate
          end
        end
        
        --[[local playstate = reaper.GetPlayState()
        if playstate == 0 or (playstate & 2) == 2 then
          local epos = reaper.GetCursorPosition()
          if epos ~= lvar.last_epos then
            lvar.chasetimer = reaper.time_precise()+0.5
            if lvar.chasetrig == nil then
              lvar.first_epos = epos
              TriggerCCChase()        
            end
            lvar.chasetrig = true
            lvar.last_epos = epos
          end
          if lvar.chasetimer and lvar.last_epos == epos and reaper.time_precise() > (lvar.chasetimer or 0) then
            lvar.last_epos = epos
            if epos ~= lvar.first_epos then
              TriggerCCChase()
            end
            lvar.chasetimer = nil
            lvar.chasetrig = nil
          end
        end]]
  
      --end
  
      if reaper.GetExtState(PUSCRIPT, 'datadirty') ~= '' then
        reaper.DeleteExtState(PUSCRIPT, 'datadirty', false)
        local writedirty = reaper.GetExtState(PUSCRIPT, 'writedirty')
        if writedirty and tonumber(writedirty) == 1 then
          reaper.DeleteExtState(PUSCRIPT, 'writedirty', false)
          ReadExtParamData()
        end
        if reaper.GetExtState(PUSCRIPT, 'clearselfader') ~= '' then
          reaper.DeleteExtState(PUSCRIPT, 'clearselfader', false)
          lvar.gflag = tonumber(reaper.GetExtState(PUSCRIPT, 'gflag'))
          ClearSelectedFader(lvar.gflag)
        end
        if reaper.GetExtState(PUSCRIPT, 'selectslot') ~= '' then
          local v = tonumber(reaper.GetExtState(PUSCRIPT, 'selectslot'))
          reaper.DeleteExtState(PUSCRIPT, 'selectslot', false)
          local i, forcegflag
          if v == -1 then
            i = (lvar.selectedfader or 0) + 1
          elseif v == -2 then
            i = (lvar.selectedfader or 2) - 1        
          elseif v == 0 then
            i = lvar.selectedfader
            lvar.gflag = tonumber(reaper.GetExtState(PUSCRIPT, 'gflag'))
            forcegflag = lvar.gflag
          else
            i = v
          end
          if ctl_template.fader[i] then
            if lvar.gflag then
              if lvar.gflag == 3 then
                tmp = permatemplate
              elseif lvar.gflag == 2 then
                tmp = globtemplate
              elseif lvar.gflag == 4 then
                tmp = overtemplate
              elseif lvar.gflag == 1 then
                tmp = template
              end
            end
            --DBG(lvar.gflag..'  '..tostring(tmp))
            SelectFader2(i, true, forcegflag)
          end
        end
        if reaper.GetExtState(PUSCRIPT, 'selectslotbyname') ~= '' then
          local sn = reaper.GetExtState(PUSCRIPT, 'selectslotbyname')
          local db = tonumber(reaper.GetExtState(PUSCRIPT, 'selectslotdev'))
          reaper.DeleteExtState(PUSCRIPT, 'selectslotbyname', false)
          reaper.DeleteExtState(PUSCRIPT, 'selectslotdev', false)

          for i = 1, lvar.fcount do
          
            if ctl_template.fader[i] and sn == ctl_template.fader[i].devctl and
                                         db == (ctl_template.fader[i].odevbus or ctl_template.fader[i].devbus) then
                                         
              SelectFader2(i, true)
              break
            end
          end
        
        elseif reaper.GetExtState(PUSCRIPT, 'selectslotdev') ~= '' then
          local db = tonumber(reaper.GetExtState(PUSCRIPT, 'selectslotdev'))
          reaper.DeleteExtState(PUSCRIPT, 'selectslotdev', false)

          for i = 1, lvar.fcount do
          
            if ctl_template.fader[i] and db == (ctl_template.fader[i].odevbus or ctl_template.fader[i].devbus) then
                                         
              SelectFader2(i, true)
              break
            end
          end

        end
        
      end
  
      if lvar.bstate_resettimer then
        if rt > lvar.bstate_resettimer then
          lvar.bstate_resettimer = nil
          ResetBState()
        end
      elseif lvar.setsendsauto_timer then
     
        if rt >= lvar.setsendsauto_timer then
          lvar.setsendsauto_timer = nil
          SetSendsAuto2(lvar.setsendsauto_all)
        end
        
      elseif lvar.running or rt > time_delay then
        if lvar.mainfade_active then
          lvar.mainfade_active = nil
          lvar.mainfade = reaper.time_precise()+lvar.mainfade_time
          lvar.readparams = nil
          --lupd.update_gfx = true
          --SendScribbleData()
        end
        
        if lvar.chasenow then
          TriggerCCChase()
        end
        
        if rt > (lvar.update_tcp2_A or math.huge) then
          lvar.update_tcp2_A = math.huge
          lvar.scrollTCPtoselectedtrack = math.huge
          if lvar.env_spread == 1 then
            ScrollTCP2(tr, true)
          elseif lvar.env_tralign == 1 then
            ScrollTCP2(tr, true)
          elseif lvar.env_tralign == 2 then
            ScrollTCP()
          end
          reaper.UpdateArrange()

        elseif lvar.setscrollpos then
          SetTCPScrollPos2(lvar.setscrollpos)
          lvar.setscrollpos = nil

        elseif rt > (lvar.scrollTCPtoselectedtrack or math.huge) then
          ScrollTCP()

        end
        GUI_draw(obj, gui)
        
        mouse.mx, mouse.my = gfx.mouse_x, gfx.mouse_y
        mouse.LB = gfx.mouse_cap&1==1
        mouse.RB = gfx.mouse_cap&2==2
        mouse.ctrl = gfx.mouse_cap&4==4
        mouse.shift = gfx.mouse_cap&8==8
        mouse.alt = gfx.mouse_cap&16==16
      
        --DBG('Ctrl '..tostring(mouse.ctrl)..' Shift '..tostring(mouse.shift)..' Opt '..tostring(mouse.alt))
      
        --[[local alt = reaper.JS_Mouse_GetState(16)&16==16
        if lvar.lrn_alt_latch and not alt then
          lvar.lrn_alt_latch = false
        end]]
        
        -------------------------------------------
    
        if lvar.livemode > 0 then
        
          if lvar.livemode == 1 then
            ARun_SetUp()
          elseif lvar.livemode == 2 then
            ARun_Colors()
          elseif lvar.livemode == 3 then
            ARun_GroupSetUp()
          elseif lvar.livemode == 4 then
            ARun_Tags(rt)
          elseif lvar.livemode == 5 then
            ARun_TagSlots(rt)
          end
        
        else
        
          if LBX_CTL_TRACK then
          
            --if lrnmode == false then
      
              if lvar.fxopentimer and lvar.fxopentimer < reaper.time_precise() then
                CloseFXGUI(lvar.fxopeninfo.track,lvar.fxopeninfo.fxnum)
                lvar.fxopentimer = nil
                lvar.fxopeninfo = nil
              end
              
              if mouse.context == nil then
                if MOUSE_over(obj.sections[1000]) and not lvar.hlsb then
                  lvar.hlsb = true
                  lupd.update_gfx = true
                elseif not MOUSE_over(obj.sections[1000]) and lvar.hlsb then
                  lvar.hlsb = nil
                  lupd.update_gfx = true
                end
                if lvar.msg and MOUSE_click(obj.sections[400]) then
                  
                  lvar.msg = false
                  ResetDevices()
                  lupd.update_gfx = true
                  
                elseif gfx.mouse_wheel ~= 0 then
                  local z = GetMW(gfx.mouse_wheel) --gfx.mouse_wheel / 120
                  --DBG('Adjusting offset: '..z..'  '..tostring(mouse.shift)..'  '..tostring(mouse.alt))
                  
                  if mouse.my < obj.sections[50].y then
                    if mouse.alt and mouse.ctrl then
                      lvar.fontoffset = F_limit(lvar.fontoffset - z,-10,10)
                      reaper.SetExtState(SCRIPT,'fontoffset',tostring(nz(lvar.fontoffset,0)),true)
                      lupd.update_gfx = true
                    elseif mouse.alt then
                      lvar.fontzoom = F_limit(lvar.fontzoom + (z/10),1,3)
                      lupd.update_gfx = true
                    elseif mouse.ctrl then
                      lvar.guizoom = F_limit(lvar.guizoom + (z/10),1,3)
                      obj = GetObjects()
                      lupd.update_gfx = true
                    end
                  elseif MOUSE_over(obj.sections[50]) or MOUSE_over(obj.sections[1]) then
                    if mouse.alt and mouse.ctrl then
                      lvar.fontoffset = F_limit(lvar.fontoffset - z,-10,10)
                      reaper.SetExtState(SCRIPT,'fontoffset',tostring(nz(lvar.fontoffset,0)),true)
                      lupd.update_gfx = true
                    elseif mouse.alt then
                      lvar.fontzoom2 = F_limit(lvar.fontzoom2 + (z/10),1,3)
                      lupd.update_gfx = true
                    elseif mouse.ctrl then
                      lvar.guizoom2 = F_limit(lvar.guizoom2 + (z/10),1,3)
                      obj = GetObjects()
                    else
                      local fc = lvar.fcountfilt or lvar.fcount
                      if lvar.pcolumns == 1 and not lvar.display_mini then
                        --DBG(mouse.shift)
                        if not mouse.shift then
                          local ycnt = math.floor(obj.sections[50].h / (fader_h+fader_space))
                          z = z * ycnt --math.floor(ycnt/2)
                        end
                        control_offs = F_limit(control_offs-z,0,fc-1)
                      else
                        local ycnt = math.floor(obj.sections[50].h / (fader_h+fader_space))
                        --DBG(fc..'  '..lvar.pcolumns-1 ..'  '..(lvar.pcolumns-1)*ycnt)
                        if fc > (lvar.pcolumns-1)*ycnt then
                          local lc = (fc % ycnt) + (lvar.pcolumns-1)*ycnt
                          control_offs = F_limit(control_offs-z*ycnt,0,fc-lc)
                        end
                      end
                    end
                    lupd.update_gfx = true
                  end
                  gfx.mouse_wheel = 0
    
                elseif MOUSE_click(obj.sections[50]) or MOUSE_click_RB(obj.sections[50]) then
                
                  local ycnt = math.floor(obj.sections[50].h / (fader_h+fader_space))
                  local mxx = math.floor((mouse.mx - obj.sections[50].x) / pname_w)
                  local myy = math.floor((mouse.my - obj.sections[50].y) / (fader_h+fader_space))
      
                  local box, fader, click_box, btn
                  if lvar.pcolumns == 1 and not lvar.display_mini then
                    mxx = 0
                    box = myy + 1 
                    fader = box + control_offs
                    if lvar.filtidx then
                      fader = lvar.filtidx[fader]
                    end
                    
                    local ccw = 60
                    if ctl_template.fader[fader] then
                      local mxxx = (mouse.mx - obj.sections[50].x)
                      if mxxx < box_w then
                        click_box = 4
                      elseif mxxx < 2*(box_w)+2 then
                        click_box = 10
                      elseif mxxx < pname_w + lvar.sscolbox_w then
                        if mxxx < 2*(box_w)+10+lvar.sscolbox_w and ctl_template.fader[fader].sscolor then
                          click_box = 99
                        elseif mxxx > pname_w - ccw + 7 then
                          click_box = 150
                        else
                          click_box = 2
                        end
                      elseif mouse.mx >= obj.sections[1000].x-2 then
                        --scrollbar
                        click_box = 1000
                      else
                        click_box = 1                  
                      end
                    end
                  
                  elseif mouse.my <= obj.sections[50].y + ycnt*(fader_h+fader_space) then 
                    box = mxx * ycnt + myy + 1
                    fader = box + control_offs
                    if lvar.filtidx then
                      fader = lvar.filtidx[fader]
                    end
                    
                    if ctl_template.fader[fader] then
                      local mxxx = (mouse.mx - obj.sections[50].x) - (mxx*pname_w)
                      if mxxx < box_w then
                        click_box = 4
                      elseif mxxx < 2*(box_w)+2 then
                        click_box = 10
                      else
                        if mxxx < 2*(box_w)+10+lvar.sscolbox_w and ctl_template.fader[fader].sscolor then
                          click_box = 99
                        else
                          click_box = 2
                          --DBG(pname_w..'  '.. mxxx)
                          if mxxx > pname_w-20-fader_h and mxxx < pname_w-20 then
                            btn = true
                          end 
                        end
                      end
                    end
                  end
                  
                  local i = fader
                  --click_box:  4 = fader num, 10 = type, 2 = param
                  --DBG(click_box)
                  if click_box then
                    if click_box == 1 and mouse.LB then
    
                      local tmp
                      tmp = GetTemplate(i)
                      --[[if permatemplate.pos[i] then
                        tmp = permatemplate        
                      elseif globtemplate.pos[i] and lvar.showglobalmap then
                        tmp = globtemplate
                      else
                        tmp = template
                      end]]
                    
                      if tmp.pos[i] and FFX then
                    
                        if ctl_template.fader[i].lmode == 4 then
                          if tmp.pos[i].ptype ~= ptype.cc then
                            BtnToggle(tmp, i)
                          else
                            if tmp.pos[i].butstates then
                              local vv = 0
                              local tmppos = tmp.pos[i]
                              tmppos.bpos = (tmppos.bpos or 0) + 1
                              if tmppos.bpos > #tmppos.butstates_array then
                                tmppos.bpos = 1
                              end
                              if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                                vv = tmppos.butstates_array[tmppos.bpos]
                              end
                              if tmppos.cc14bit == 1 then
                                vv = vv/16383
                              else
                                vv = vv/127
                              end
                              SetCCVal(i, vv, nil, tmp)
                              SetFaderBoxVal(i, vv*16383)
                              tmp.dirty[i] = true
                            else
                              BtnToggle(tmp, i)
                            end
                          end
                          
                        else
                          mouse.context = contexts.sliderctl
                          octlval = nil
                          mouse.slideoff = math.floor(obj.sections[1].x + fader_w/2 - mouse.mx)
                          ctlpos = tmp.pos[i].val
                          slider_select = i
                          oms = mouse.shift
                          if tmp.pos[i].cc == true then
                            if tmp.pos[i].ccchan ~= -1 then
                              --touch on
                              local tr = GetTrack(LBX_CTL_TRACK)
                              if tr then
                                GMFB_touchfader(i-1,1)
                              end
                              tr = GetTrack(LBX_CC_TRACK)
                              if tr then
                                local d = tmp.pos[i].ccchan << 7 | tmp.pos[i].ccnum
                                reaper.TrackFX_SetParam(tr,0,10,d)
                                if tmp.pos[i].cc14bit then
                                  local d = tmp.pos[i].ccchan << 7 | (tmp.pos[i].ccnum + 32)
                                  reaper.TrackFX_SetParam(tr,0,11,d)                                
                                end
                              end                  
                            else
                              mouse.context = nil
                              slider_select = nil
                            end
                          else
                            fader_touch2[i] = true
                          end
                        end
                      end
    
                    elseif click_box == 150 and mouse.LB then --enable/disable single print val
                    
                      local tmp, gflag
                      tmp, gflag = GetTemplatePos(i)
                      if tmp and tmp.ptype == ptype.cc then
                        
                        local gmem = reaper.gmem_read
                        local gmem_wr = reaper.gmem_write
                        local cc = tmp.ccnum
                        local ccval = tmp.defcc_val or gmem(lvar.gm_ccstamp.defcc_val+cc)
                              
                        if (ccval or -1) ~= -1 then
                          --DBG('X')
                          gmem_wr(lvar.gm_ccstamp.cc_enabled+cc, 1-gmem(lvar.gm_ccstamp.cc_enabled+cc))
                          lupd.update_gfx = true
                        end
                        
                      elseif tmp and tmp.ptype == ptype.track then
                      
                      
                      
                      end
                    
                    elseif click_box == 2 and mouse.LB and recmode == 0 then

                        local tmp, gflag
                        tmp, gflag = GetTemplate(i)
                        --[[if permatemplate.pos[i] then
                          tmp = permatemplate
                          gflag = 3
                        elseif globtemplate.pos[i] and lvar.showglobalmap then
                          tmp = globtemplate
                          gflag = 2
                        else
                          tmp = template
                          gflag = 1
                        end]]
                        if ctl_template.fader[i] then
                          if lrnmode then
                            --SelectFader2(i, false)
                            if mouse.ctrl then
                              LearnPlug(i)
                            end
                          else
                            if ctl_template.fader[i].lmode == 4 and (lvar.pcolumns ~= 1 or lvar.display_mini) and btn then
                              if tmp.pos[i].ptype ~= ptype.cc then
                                BtnToggle(tmp, i)
                              else
                                if tmp.pos[i].butstates then
                                  local vv = 0
                                  local tmppos = tmp.pos[i]
                                  tmppos.bpos = (tmppos.bpos or 0) + 1
                                  if tmppos.bpos > #tmppos.butstates_array then
                                    tmppos.bpos = 1
                                  end
                                  if (tmppos.butstates_array[tmppos.bpos] or -1) ~= -1 then
                                    vv = tmppos.butstates_array[tmppos.bpos]
                                  end
                                  if tmppos.cc14bit == 1 then
                                    vv = vv/16383
                                  else
                                    vv = vv/127
                                  end
                                  SetCCVal(i, vv, nil, tmp)
                                  SetFaderBoxVal(i, vv*16383)
                                  tmp.dirty[i] = true
                                else
                                  BtnToggle(tmp, i)
                                end
                              end
                            elseif mouse.ctrl then
                              SelectFader2(i, false)
                              if ctl_template.fader[i].dtype == 999 then
                                if ctl_template.fader[i].lmode == 0 or ctl_template.fader[i].lmode == 4 then
                                  ctl_template.fader[i].lmode = 4 - ctl_template.fader[i].lmode 
                                  if tmp.pos[i] then
                                    tmp.pos[i].lmode_ov = ctl_template.fader[i].lmode
                                    if gflag == 3 then
                                      lvar.saveperm_highlight = true
                                    elseif gflag == 2 then
                                      lvar.saveglob_highlight = true
                                    else
                                      lvar.save_highlight = true
                                    end
                                    lupd.update_header = true
                                  end
                                  
                                  SaveDummyData()
                                  lupd.update_gfx = true
                                  
                                end
                                --and save...?
                              end
                            else
                              SelectFader2(i, true)
                            end
                          end
                        end
                    elseif click_box == 2 and mouse.RB and recmode == 0 then
                      --local i = math.floor((mouse.my - obj.sections[2].y) / (fader_h+fader_space))+1 +control_offs
                      local fc = lvar.fcountfilt or lvar.fcount
                      if i <= fc and recmode == 0 then
                     
                        local tmp, gflag
                        tmp, gflag = GetTemplate(i,nil,true)

                        SelectFader2(i, false)
      
                        if (tmp.pos[i] and tmp.pos[i].ptype == ptype.cc) then
                          local v = CCMenu(i)
                          if v then
                            local chase = false
                            if v == 2 then
                              ClearSlot(i)
                            else
                              if v == 3 then
                                for n = 1, lvar.fcount do
                                  tmp.pos[n] = nil
                                  tmp.dirty[n] = true                      
                                end
                                if gflag == 4 then
                                  CheckLayers(template)
                                end
                                lvar.saveglob_highlight = true
                                lvar.save_highlight = true
                              elseif v == 4 then
                                local _, nm = reaper.GetUserInputs('Rename CC parameter',1,'Enter name:,extrawidth=100',tmp.pos[i].name or '')
                                if nm and nm ~= '' then
                                  tmp.pos[i].name = nm
                                else
                                  tmp.pos[i].name = nil
                                end
                              elseif v <= 20 then
                                tmp.pos[i].ccchan = v-5
                                if tmp.pos[i].ccnum == -1 then
                                  tmp.pos[i].ccnum = 0
                                end
                                chase = true
                              else
                                tmp.pos[i].ccnum = v-21
                                if tmp.pos[i].ccchan == -1 then
                                  tmp.pos[i].ccchan = 0
                                end
                                chase = true
                              end
                              lvar.readparams = nil
                              SetCCs()
                              updatetravellingtracknames(true) 
                              SetUpCCStampData()
                              --SendScribbleData()
                              tmp.dirty[i] = true
                              if chase then
                                TriggerCCChase()
                              end
                              if gflag == 3 then
                                lvar.saveperm_highlight = true
                              elseif gflag == 2 then
                                lvar.saveglob_highlight = true
                              else
                                lvar.save_highlight = true
                              end
                              lupd.update_header = true
                            end
                          end
                          lupd.update_fader = true
      
                        elseif (tmp.pos[i] and tmp.pos[i].ptype == ptype.track) then
                          local v, p = TrackMenu(i)
                          if v ~= -4 and p == 2 then
                            ClearSlot(i)
                          elseif v and p then
                            if v == -4 then
                              tmp.pos[i].enc_res = p
                            elseif v == 0 then
                              if p == 2 then
                                --[[tmp.pos[i].track = -2
                                tmp.pos[i].trparam = -1
                                tmp.pos[i].pname = GenTrackPName(i)
                                tmp.dirty[i] = true]]
                              elseif p == 3 then
                                for n = 1, lvar.fcount do
                                  tmp.pos[n] = nil
                                  tmp.dirty[n] = true                      
                                end
                                if gflag == 4 then
                                  CheckLayers(template)
                                end
                                lvar.saveglob_highlight = true
                                lvar.save_highlight = true
                              elseif p == 4 then
                                local _, nm = reaper.GetUserInputs('Rename track parameter',1,'Enter name:,extrawidth=100',tmp.pos[i].name or '')
                                if nm and nm ~= '' then
                                  tmp.pos[i].name = nm
                                else
                                  tmp.pos[i].name = nil
                                end
                                tmp.dirty[i] = true
                              end
                            elseif v == 1 then
                              tmp.pos[i].track = p
                              if p ~= -1 then
                                tmp.pos[i].trguid = reaper.GetTrackGUID(GetTrack(p))
                              else
                                tmp.pos[i].trguid = nil
                              end
                              if (tmp.pos[i].trparam or -1) == -1 then
                                tmp.pos[i].trparam = 1                          
                              end
                              tmp.pos[i].pname = GenTrackPName(i)
                              tmp.dirty[i] = true
                            elseif v == 2 then
                              tmp.pos[i].trparam = p
                              if (tmp.pos[i].track or -99) == -99 then
                                tmp.pos[i].track = -1
                                tmp.pos[i].trguid = ''
                              end
                              tmp.pos[i].pname = GenTrackPName(i)
                              tmp.dirty[i] = true
                            elseif v == 3 then
                              tmp.pos[i].track = -2
                              tmp.pos[i].troff = p
                              tmp.pos[i].trguid = ''
                              if (tmp.pos[i].trparam or -1) == -1 then
                                tmp.pos[i].trparam = 1                          
                              end
                              tmp.pos[i].pname = GenTrackPName(i)
                              tmp.dirty[i] = true
                            end
                            lvar.readparams = nil
                            SetCCs()
                            updatetravellingtracknames(true)
                            SetUpCCStampData()
                            --SendScribbleData()
                            if gflag == 3 then
                              lvar.saveperm_highlight = true
                            elseif gflag == 2 then
                              lvar.saveglob_highlight = true
                            else
                              lvar.save_highlight = true
                            end
                            lupd.update_header = true
                            
                            --DBG(v..'  '..p)
                          end
                          lupd.update_fader = true
                          
                        elseif (tmp.pos[i] and tmp.pos[i].ptype == ptype.action) then
                          local p = ActionMenu(i)
                          if p then
                            if p == 2 then
                              ClearSlot(i)
                              --[[tmp.pos[i].track = -2
                              tmp.pos[i].trparam = -1
                              tmp.pos[i].pname = GenTrackPName(i)
                              tmp.dirty[i] = true]]
                            else  
                              if p == 3 then
                                for n = 1, lvar.fcount do
                                  tmp.pos[n] = nil
                                  tmp.dirty[n] = true                      
                                end                        
                                if gflag == 4 then
                                  CheckLayers(template)
                                end
                                lvar.saveglob_highlight = true
                                lvar.save_highlight = true
                              elseif p == 4 then
                                local _, nm = reaper.GetUserInputs('Rename action trigger',1,'Enter name:,extrawidth=100',tmp.pos[i].name or '')
                                if nm and nm ~= '' then
                                  tmp.pos[i].name = nm
                                else
                                  tmp.pos[i].name = nil
                                end
                                tmp.dirty[i] = true
                              elseif p == 5 then
                                local _, actid = reaper.GetUserInputs('Enter action id',1,'Enter action id:,extrawidth=200',tmp.pos[i].actionid or '')
                                if actid then
                                  tmp.pos[i].actionid = actid
                                  tmp.pos[i].pname = 'Action Set'
                                end
                              elseif p == 6 then
                                tmp.pos[i].actionmon = 1-tmp.pos[i].actionmon
                              elseif p <= 6 + #tab_btntype then
                                p = p - 6
                                tmp.pos[i].buttype = tab_btntype[p].v
                              end
                              lvar.readparams = nil
                              SetCCs()
                              updatetravellingtracknames(true)  
                              SetUpCCStampData()   
                              --SendScribbleData()
                              if pglob then
                              elseif glob then
                                lvar.saveglob_highlight = true
                              else
                                lvar.save_highlight = true
                              end
                              lupd.update_header = true
                            end
                          end
                          lupd.update_fader = true
        
                        elseif (tmp.pos[i] and tmp.pos[i].ptype == ptype.host) and lvar.mode ~= 3 then
                        
                          local p, pn = ParamMenu(i)
                          if p then
                            if p == -1 then          
                              ClearSlot(i)
                              --[[tmp.pos[i] = nil
                              tmp.dirty[i] = true]]
                            else
                              if p == -2 then
                                for n = 1, lvar.fcount do
                                  tmp.pos[n] = nil
                                  tmp.dirty[n] = true                      
                                end
                                if gflag == 4 then
                                  CheckLayers(template)
                                end
                                lvar.saveglob_highlight = true
                                lvar.save_highlight = true
                              elseif p == -3 then 
                                local _, nm = reaper.GetUserInputs('Rename parameter',1,'Enter name:,extrawidth=100',tmp.pos[i].name or '')
                                if nm and nm ~= '' then
                                  tmp.pos[i].name = nm
                                else
                                  tmp.pos[i].name = nil
                                end
                                tmp.dirty[i] = true    
                              elseif p == -4 then 
                                tmp.pos[i].enc_res = pn
                              elseif p == -5 then --but type
                                if pn == 1 then
                                  tmp.pos[i].buttype = 0
                                elseif pn == 2 then
                                  tmp.pos[i].buttype = 4                              
                                end
                              elseif p == -6 then --but states
                                local ret, st = reaper.GetUserInputs('Button States',1,'Number of states:',tmp.pos[i].butstates or 2)
                                if ret and tonumber(st) then
                                  tmp.pos[i].butstates = tonumber(st)
                                end
                              else 
              
                                SetTemplateParam(i, p, pn)
                                
                                local track = GetTrack(FFX.trn)
                                local fxnum = FFX.fxnum
                                local pnum = template.pos[i].pnum
                                local val = reaper.TrackFX_GetParamNormalized(track, fxnum, pnum)
                                tmp.pos[i].val = val
                                SetFaderBoxVal(i, val)
                                
                                tmp.dirty[i] = true
                              end
                              lvar.readparams = nil
                              SetCCs()
                              updatetravellingtracknames(true)
                              SetUpCCStampData()
                              --SendScribbleData()
                              
                              lupd.update_fader = true
                              if pglob then
                              elseif glob then
                                lvar.saveglob_highlight = true
                              else
                                lvar.save_highlight = true
                              end
                              lupd.update_header = true
                            end
                          end

                        elseif (tmp.pos[i] and tmp.pos[i].ptype == ptype.internal) then
                          local p = InternalMenu(i)
                          if p then
                            if p == 2 then
                              ClearSlot(i)
                              --[[tmp.pos[i].track = -2
                              tmp.pos[i].trparam = -1
                              tmp.pos[i].pname = GenTrackPName(i)
                              tmp.dirty[i] = true]]
                            else
                              if p == 3 then
                                for n = 1, lvar.fcount do
                                  tmp.pos[n] = nil
                                  tmp.dirty[n] = true                      
                                end                        
                                if gflag == 4 then
                                  CheckLayers(template)
                                end
                                lvar.saveglob_highlight = true
                                lvar.save_highlight = true
                              elseif p == 4 then
                                local _, nm = reaper.GetUserInputs('Rename internal parameter',1,'Enter name:,extrawidth=100',tmp.pos[i].name or '')
                                if nm and nm ~= '' then
                                  tmp.pos[i].name = nm
                                else
                                  tmp.pos[i].name = nil
                                end
                                tmp.dirty[i] = true
                                
                              elseif p == 5 then
                                tmp.pos[i].actionmon = 1-tmp.pos[i].actionmon
                                
                              elseif p <= 5+#tab_btntype then
  
                                p = p-5
                                tmp.pos[i].buttype = tab_btntype[p].v
  
                              elseif p <= 5+#tab_btntype+#tab_internal_troffs then
                                p = p-(5+#tab_btntype)
                                tmp.pos[i].pname = tab_internal_troffs[p]
                                tmp.pos[i].code = 1
                                tmp.pos[i].codeval = tab_internal_troffs_vals[p]
                                tmp.dirty[i] = true
  
                              elseif p <= 5+#tab_btntype+#tab_internal_troffs+#tab_internal_globtmp then
  
                                p = p-(5+#tab_btntype+#tab_internal_troffs)
                                
                                tmp.pos[i].pname = string.gsub(tab_internal_globtmp[p],'|','')
                                tmp.pos[i].code = 2
                                tmp.pos[i].codeval = p
                                tmp.dirty[i] = true
  
                              elseif p <= 5+#tab_btntype+#tab_internal_troffs+#tab_internal_globtmp+#tab_commonfuncs then
  
                                p = p-(5+#tab_btntype+#tab_internal_troffs+#tab_internal_globtmp)
                                tmp.pos[i].pname = string.gsub(tab_commonfuncs[p],'|','')
                                tmp.pos[i].code = 3
                                tmp.pos[i].codeval = p
                                tmp.dirty[i] = true
                              
                              end  
  
                              lvar.readparams = nil
                              SetCCs()
                              updatetravellingtracknames(true)
                              SetUpCCStampData()
                              --SendScribbleData()
                              
                              lupd.update_fader = true
                              if pglob then
                              elseif glob then
                                lvar.saveglob_highlight = true
                              else
                                lvar.save_highlight = true
                              end
                              lupd.update_header = true
                            end
                          end
                        end
                      end
                    
                    elseif click_box == 10 and mouse.LB and recmode == 0 then
    
                      --[[local tmp
                      local glob, pglob, gflag
                      if permatemplate.pos[i] then
                        tmp = permatemplate
                        pglob = true
                        gflag = 3
                      elseif globtemplate.pos[i] and lvar.showglobalmap then
                        tmp = globtemplate
                        glob = true
                        gflag = 2
                      else
                        tmp = template
                        gflag = 1
                      end

                      if not mouse.ctrl then    
                        if FFX then
                          if tmp.pos[i] then
                            
                            local pt = (tmp.pos[i].ptype or 0)+1
                            tmp.pos[i] = {}
                            tmp.pos[i].ptype = pt
                            
                            if tmp.pos[i].ptype > ptype_cnt then
                              tmp.pos[i].ptype = 1
                            end
                            if (lvar.mode == 3 or glob == true) and tmp.pos[i].ptype == ptype.host then
                              tmp.pos[i].ptype = ptype.cc
                            end
                            if tmp.pos[i].ptype == ptype.host then
                              tmp.pos[i].cc = false
                              tmp.pos[i].ccchan = -1
                              tmp.pos[i].ccnum = -1
                              tmp.pos[i].pnum = -1
                              tmp.pos[i].pname = '<Please select>'
                              tmp.pos[i].track = -1
                              tmp.pos[i].actionid = -1
                              tmp.pos[i].actionmon = 0
                              tmp.pos[i].trparam = 1
                              tmp.pos[i].troff = -1
                              tmp.pos[i].code = -1
                              tmp.pos[i].codeval = 0
                              tmp.pos[i].enc_res = 512
                              
                            elseif tmp.pos[i].ptype == ptype.cc then
                              tmp.pos[i].cc = true
                              tmp.pos[i].ccchan = -1
                              tmp.pos[i].ccnum = -1
                              tmp.pos[i].pnum = -1
                              tmp.pos[i].pname = '<Please select>'
                              tmp.pos[i].track = -1
                              tmp.pos[i].actionid = -1
                              tmp.pos[i].actionmon = 0
                              tmp.pos[i].trparam = -1
                              tmp.pos[i].troff = -1
                              tmp.pos[i].code = -1
                              tmp.pos[i].codeval = 0
                              tmp.pos[i].enc_res = 128

                            elseif tmp.pos[i].ptype == ptype.track then
                              tmp.pos[i].cc = false
                              tmp.pos[i].ccchan = 0
                              tmp.pos[i].ccnum = 0
                              tmp.pos[i].pnum = -1
                              tmp.pos[i].track = -1
                              tmp.pos[i].trparam = -1
                              tmp.pos[i].actionid = -1
                              tmp.pos[i].actionmon = 0
                              tmp.pos[i].pname = '<Please select>'
                              tmp.pos[i].troff = -1
                              tmp.pos[i].code = -1
                              tmp.pos[i].codeval = 0
                              tmp.pos[i].enc_res = 512
                              
                            elseif tmp.pos[i].ptype == ptype.action then
                              tmp.pos[i].cc = false
                              tmp.pos[i].ccchan = 0
                              tmp.pos[i].ccnum = 0
                              tmp.pos[i].pnum = -1
                              tmp.pos[i].track = -1
                              tmp.pos[i].trparam = -1
                              tmp.pos[i].actionid = -1
                              tmp.pos[i].actionmon = 0
                              tmp.pos[i].pname = '<Please select>'
                              tmp.pos[i].troff = -1
                              tmp.pos[i].code = -1
                              tmp.pos[i].codeval = 0
                              tmp.pos[i].enc_res = 512
                              
                            elseif tmp.pos[i].ptype == ptype.internal then
                              tmp.pos[i].cc = false
                              tmp.pos[i].ccchan = 0
                              tmp.pos[i].ccnum = 0
                              tmp.pos[i].pnum = -1
                              tmp.pos[i].track = -1
                              tmp.pos[i].trparam = -1
                              tmp.pos[i].actionid = -1
                              tmp.pos[i].actionmon = 0
                              tmp.pos[i].pname = '<Please select>'
                              tmp.pos[i].troff = -1
                              tmp.pos[i].code = -1
                              tmp.pos[i].codeval = 0
                              tmp.pos[i].enc_res = 512
                              
                            end
                          
                          else
                            tmp.pos[i] = {}
                            if lvar.mode == 3 then
                              tmp.pos[i].ptype = ptype.cc
                              tmp.pos[i].enc_res = 128
                              
                            else
                              tmp.pos[i].ptype = ptype.host
                              tmp.pos[i].enc_res = 512
                              
                            end
                            tmp.pos[i].cc = true
                            tmp.pos[i].ccchan = -1
                            tmp.pos[i].ccnum = -1
                            tmp.pos[i].track = -1
                            tmp.pos[i].trparam = -1
                            tmp.pos[i].troff = -1
                            tmp.pos[i].pnum = -1
                            tmp.pos[i].actionid = -1
                            tmp.pos[i].actionmon = 0
                            tmp.pos[i].pname = '<Please select>'
                            tmp.pos[i].code = -1
                            tmp.pos[i].codeval = 0
                            tmp.pos[i].buttype = 4
                            tmp.pos[i].butstates = 2
                          end
                          SetCCs()
                          updatetravellingtracknames(true)
                          SetUpCCStampData()
                          lupd.update_gfx = true
                        end
                      elseif lvar.showglobalmap and not mouse.shift then
                      
                        lvar.saveglob_highlight = true
                        if globtemplate.pos[i] and lvar.showglobalmap then
                          globtemplate.pos[i] = nil
                        else
                          if tmp.pos[i] and tmp.pos[i].ptype ~= ptype.host then
                            globtemplate.pos[i] = table.copy(tmp.pos[i])
                          else
                            globtemplate.pos[i] = {}
                              
                            local tmp = globtemplate
                            tmp.pos[i] = {}
                            tmp.pos[i].cc = false
                            tmp.pos[i].track = -1
                            tmp.pos[i].trparam = -1
                            tmp.pos[i].troff = -1
                            tmp.pos[i].ccchan = -1
                            tmp.pos[i].ccnum = -1
                            tmp.pos[i].pnum = -1
                            tmp.pos[i].pname = '' 
                            tmp.pos[i].actionid = -1
                            tmp.pos[i].actionmon = 0
                            tmp.pos[i].code = -1
                            tmp.pos[i].codeval = 0
                          end
                        end
                        SetCCs()
                        updatetravellingtracknames(true)
                        SetUpCCStampData()
                        lupd.update_gfx = true

                      elseif mouse.shift then
                      
                        --lvar.saveglob_highlight = true
                        if permatemplate.pos[i] then
                          permatemplate.pos[i] = nil
                        else
                          if globtemplate.pos[i] and lvar.showglobalmap then
                            permatemplate.pos[i] = table.copy(globtemplate.pos[i])                          
                          elseif tmp.pos[i] and tmp.pos[i].ptype ~= ptype.host then
                            permatemplate.pos[i] = table.copy(tmp.pos[i])
                          else
                            permatemplate.pos[i] = {}
                              
                            local tmp = permatemplate
                            tmp.pos[i] = {}
                            tmp.pos[i].cc = false
                            tmp.pos[i].track = -1
                            tmp.pos[i].trparam = -1
                            tmp.pos[i].troff = -1
                            tmp.pos[i].ccchan = -1
                            tmp.pos[i].ccnum = -1
                            tmp.pos[i].pnum = -1
                            tmp.pos[i].pname = '' 
                            tmp.pos[i].actionid = -1
                            tmp.pos[i].actionmon = 0
                            tmp.pos[i].code = -1
                            tmp.pos[i].codeval = 0
                          end
                        end
                        SetCCs()
                        updatetravellingtracknames(true)
                        SetUpCCStampData()
                        lupd.update_gfx = true
                      
                      end
                      SelectFader2(i, true)]]
    
                    elseif click_box == 10 and mouse.RB and recmode == 0 then
                    
                      local tmp, gflag
                      tmp, gflag = GetTemplate(i)
                      --[[if permatemplate.pos[i] then
                        tmp = permatemplate
                        pglob = true
                        gflag = 3
                      elseif globtemplate.pos[i] and lvar.showglobalmap then
                        tmp = globtemplate
                        glob = true
                        gflag = 2
                      else
                        tmp = template
                        gflag = 1
                      end]]
                      
                      lvar.readparams = nil
                      
                      tmp.pos[i] = nil
                      tmp.dirty[i] = true
                      lupd.update_fader = true
                      SetCCs()
                      updatetravellingtracknames(true)
                      SetUpCCStampData()
                      
                      if gflag == 3 then
                        lvar.saveperm_highlight = true
                      elseif gflag == 2 then
                        lvar.saveglob_highlight = true
                      else
                        lvar.save_highlight = true
                      end
                      
                      SelectFader2(i, false)
                      
                      lupd.update_gfx = true
                      
                    elseif click_box == 4 and mouse.LB then
                    
                      local tmp, gflag
                      tmp, gflag = GetTemplate(i)
                      --[[if permatemplate.pos[i] then
                        tmp = permatemplate
                        gflag = 3
                      elseif globtemplate.pos[i] and lvar.showglobalmap then
                        tmp = globtemplate
                        gflag = 2
                      else
                        tmp = template
                        gflag = 1
                      end]]
                      SelectFader2(i, false)
                      if recmode == 1 then
                        
                        if tmp.pos[i] and tmp.pos[i].ptype == ptype.host then 
                          if fader_touch[i] then 
                            fader_touch[i] = nil
                            local track = GetTrack(FFX.trn)
                            local env = reaper.GetFXEnvelope(track, FFX.fxnum, tmp.pos[i].pnum, true)
                            ArmEnv(env, false)
                          else
                            fader_touch[i] = true
                            local track = GetTrack(FFX.trn)          
                            local env = reaper.GetFXEnvelope(track, FFX.fxnum, tmp.pos[i].pnum, true)
                            ArmEnv(env, false)
                          end
                          lupd.update_gfx = true
                        end
                      end
                    
                    elseif click_box == 4 and mouse.RB then
                    
                      --FiltMenu()
                      local slot = i
                      RemapMenu(slot, mouse.mx, mouse.my)
                      
                    elseif click_box == 99 and mouse.LB and recmode == 0 then
                      local tmp, gflag
                      tmp, gflag = GetTemplate(i)
                      --[[if permatemplate.pos[i] then
                        tmp = permatemplate
                        pglob = true        
                      elseif globtemplate.pos[i] and lvar.showglobalmap then
                        tmp = globtemplate
                        glob = true
                      else
                        tmp = template
                      end]]
                      
                      if tmp.pos[i] and ctl_template.fader[i].sscolor then
                        if mouse.shift then
                          local ss = tmp.pos[i].sscolor or 7
                          if ctl_template.fader[i].sscolor == 1 then
                            tmp.pos[i].sscolor = (ss&7) + (((((ss&48)>>4)+1)%4)<<4)
                          elseif ctl_template.fader[i].sscolor == 2 then
                            tmp.pos[i].sscolor = (ss&7) + (((((ss&48)>>4)+2)%4)<<4)                          
                          end
                          lupd.update_gfx = true
                        else
                          local ss = tmp.pos[i].sscolor or 7
                          tmp.pos[i].sscolor = (((ss&7)+1)%8) + (ss&48)
                          lupd.update_gfx = true
                        end

                        --SendScribbleData2(tmp,nil,i)
                        Scribble_FlashVal(i,'')
                        if gflag == 3 then
                          lvar.saveperm_highlight = true
                        elseif gflag == 2 then
                          lvar.saveglob_highlight = true
                        elseif gflag == 1 or gflag == 4 then
                          lvar.save_highlight = true
                        end
                      end
                      
                    elseif click_box == 99 and mouse.RB and recmode == 0 then
                      if not mouse.ctrl then
                        local tmp, gflag
                        tmp, gflag = GetTemplate(i)
                        --[[if permatemplate.pos[i] then
                          tmp = permatemplate
                          pglob = true        
                        elseif globtemplate.pos[i] and lvar.showglobalmap then
                          tmp = globtemplate
                          glob = true
                        else
                          tmp = template
                        end]]
                        
                        if tmp.pos[i] and ctl_template.fader[i].sscolor then
                          if mouse.shift then
                            local ss = tmp.pos[i].sscolor or 7
                            if ctl_template.fader[i].sscolor == 1 then
                              tmp.pos[i].sscolor = (ss&7) + (((((ss&48)>>4)-1)%4)<<4)
                            elseif ctl_template.fader[i].sscolor == 2 then
                              tmp.pos[i].sscolor = (ss&7) + (((((ss&48)>>4)-2)%4)<<4)                          
                            end    
                            lupd.update_gfx = true
                          else
                            local ss = tmp.pos[i].sscolor or 7
                            tmp.pos[i].sscolor = (((ss&7)-1)%8) + (ss&48)
                            lupd.update_gfx = true
                          end
  
                          --SendScribbleData2(tmp,nil,i)
                          Scribble_FlashVal(i,'')
                          if gflag == 3 then
                            lvar.saveperm_highlight = true
                          elseif gflag == 2 then
                            lvar.saveglob_highlight = true
                          elseif gflag == 1 or gflag == 4 then
                            lvar.save_highlight = true
                          end
                        end

                      else
                        --FaderColor_Menu(mouse.mx, mouse.my, i)                    
                      end
                    
                    elseif click_box == 1000 and mouse.LB then
                      local fc = lvar.fcountfilt or lvar.fcount
                      local viscnt = math.floor(obj.sections[1].h/(fader_h + fader_space))
                      if viscnt < fc then
                        local yy = mouse.my - obj.sections[1000].y
                        local bh = math.floor((viscnt/fc)*obj.sections[1000].h)
                        local bt = F_limit(math.floor((control_offs/(fc-viscnt))*(obj.sections[1000].h-bh)),
                                           0, obj.sections[1000].h-bh)
                        --DBG(yy..'   '..bt..'  '..bh)
                        if yy >= bt and yy <= bt+bh then
                          lvar.vscrollb = {offs = yy-bt, bh = bh, viscnt = viscnt}
                          lvar.vscrollb_pos = control_offs
                          mouse.context = contexts.vscrollb
                          lupd.update_gfx = true
                        end
                      end
                    end
                  end
                  
                elseif slider_select then
                  local i = slider_select
                  local tmp
                  tmp = GetTemplate(i)
                  --[[if permatemplate.pos[i] then
                    tmp = permatemplate
                  elseif globtemplate.pos[i] and lvar.showglobalmap then
                    tmp = globtemplate
                  else
                    tmp = template
                  end]]
                  
                  if tmp.pos[i] and tmp.pos[i].cc == true then
                    --touch off
                    local tr = GetTrack(LBX_CTL_TRACK)
                    if tr then
                      --local fxnum = math.floor((i-1) / 32)
                      --reaper.TrackFX_SetParam(tr,fxnum,35,((i-1)%32)+1)
                      GMFB_touchfader(i-1,0)
                    end
                    tr = GetTrack(LBX_CC_TRACK)
                    if tr then
                      reaper.TrackFX_SetParam(tr,0,10,-1)
                    end
                  else
                    fader_touch2[i] = nil
                  end
                  
                  slider_select = nil
                                  
                elseif MOUSE_click(obj.sections[5]) then
                
                  if recmode == 0 then
                    SaveFXParamTemplate(FFX, template, nil, nil, false)
                    GUI_FlashButton(obj, gui, 5, 'SAVE', 0.1, '205 205 205')
                  --else
                    --recmode = 0
                    --SetRecMode(recmode)
                    --lupd.update_gfx = true
                  end
                  lvar.save_highlight = false
                  
                elseif MOUSE_click_RB(obj.sections[5]) then
                
                  SaveBtnMenu()
                  
                elseif MOUSE_click(obj.sections[6]) then
                  
                  --if lvar.mode ~= 3 then
                    if FFX and recmode == 0 then
                      recmode = 1
                      SetRecMode(recmode)
                      lupd.update_gfx = true
                    
                    elseif FFX and recmode == 1 then
                      recmode = -1
                      SetRecMode(recmode)
                      lupd.update_gfx = true
                    
                    end
                  --end
                      
                elseif MOUSE_click_RB(obj.sections[6]) then
                
                  --if lvar.mode ~= 3 then
                    local ret = Menu_AutoMode(LBX_CTL_TRACK)
                  
                    if ret >= 0 then
                      if ret > #tab_automode-1 then
                        --set option
                        ret = ret - (#tab_automode-1)
                        if ret == 1 then
                          lvar.ss_color_override_enabled = not lvar.ss_color_override_enabled                        
                        elseif ret == 2 then
                          lvar.ss_color_override_nonautomatable = not lvar.ss_color_override_nonautomatable
                        elseif ret == 3 then                          
                          if lvar.recoffmode == 0 then
                            lvar.recoffmode = 1
                          else
                            lvar.recoffmode = 0
                          end
                          LBX_FX_TRACK_AM = lvar.recoffmode
                          
                        elseif ret == 4 then                          
                          lvar.rec_starttransportonfadertouch = not lvar.rec_starttransportonfadertouch
                        elseif ret == 5 then
                          lvar.rec_mapactiveenvstofaders2 = not lvar.rec_mapactiveenvstofaders2
                        elseif ret == 6 then
                          lvar.rec_automap_solo = not lvar.rec_automap_solo
                        elseif ret >= 7 and ret <= 11 then
                          if ret == 7 then
                            lvar.rec_automap_device = -1
                          else
                            lvar.rec_automap_device = ret - 7
                          end
                        end
                      else
                        --set auto mode
                        LBX_CTL_TRACK_AM = ret
                        if LBX_CTL_TRACK_AM < 2 then
                          recmode = -2
                          lupd.update_gfx = true
                          SetRecMode(recmode)
                        elseif FFX and recmode == 1 then
                          SetRecMode(recmode)
                          lupd.update_gfx = true
                        end
                      end
                    end
                  --end

                elseif MOUSE_click(obj.sections[1005]) or MOUSE_click(obj.sections[1004]) then
                  
                  --load tags
                  if lvar.mode == 3 then
                    lvar.tags.filter = ''
                    
                    lvar.livemode = 4
                    lvar.tagdata = GetTagData()
                    lvar.tagfilt = FilterTagData(lvar.tagdata, lvar.tags.filter)
                    
                    lupd.update_gfx = true
                  end

                elseif MOUSE_click_RB(obj.sections[1005]) or MOUSE_click_RB(obj.sections[1004]) then
                  
                  if lvar.mode == 3 then
                    TagMenu_Load()
                  end

                elseif MOUSE_click_RB(obj.sections[1003]) then
                  
                  if lvar.mode == 3 then
                    TagMenu_Save()
                  end
                
                elseif MOUSE_click(obj.sections[1003]) then
                  
                  --save tag
                  if lvar.mode == 3 then

                    SaveTag()
                  
                  end
                  
                elseif MOUSE_click(obj.sections[3]) then
                
                  if FFX and recmode ~= 1 then
                    if LBX_FX_TRACK_AM ~= 5 then
                      LBX_FX_TRACK_AM = 5
                    else
                      LBX_FX_TRACK_AM = lvar.recoffmode
                    end
                    SetAutoMode(FFX.trn, LBX_FX_TRACK_AM)
                    lupd.update_gfx = true
                  end

                elseif MOUSE_click_RB(obj.sections[3]) then
                
                  if FFX then
                    FFXMenu()
                  end
                
                elseif MOUSE_click(obj.sections[12]) then
                  
                  SetMode(3)

                elseif MOUSE_click(obj.sections[13]) then
                  
                  SetMode(2)

                elseif MOUSE_click(obj.sections[14]) then
                  
                  SetMode(1)

                elseif MOUSE_click_RB(obj.sections[15]) then
                
                  GlobalMenu()
                
                elseif MOUSE_click_RB(obj.sections[12]) then

                  local ga = GAMenu(lvar.autoglob_track)
                  if ga then
                    if ga == 1 then
                      if not lvar.autoglob_track or lvar.autoglob_track ~= 1 then
                        lvar.autoglob_track = 1
                      else
                        lvar.autoglob_track = 0
                      end
                    elseif ga == 2 then
                      if not lvar.autoglob_track or lvar.autoglob_track ~= 2 then
                        lvar.autoglob_track = 2
                      else
                        lvar.autoglob_track = 0
                      end
                    end                  
                  end
                  
                elseif MOUSE_click_RB(obj.sections[13]) or MOUSE_click_RB(obj.sections[14]) then

                  local ga = GAMenu2(lvar.autoglob_plug)
                  if ga then
                    if ga == 1 then
                      if not lvar.autoglob_plug or lvar.autoglob_plug ~= 1 then
                        lvar.autoglob_plug = 1
                      else
                        lvar.autoglob_plug = 0
                      end
                    elseif ga == 2 then
                      if not lvar.autoglob_plug or lvar.autoglob_plug ~= 2 then
                        lvar.autoglob_plug = 2
                      else
                        lvar.autoglob_plug = 0
                      end
                    elseif ga == 3 then
                    
                      lvar.fxsel_mode = 0
                    
                    elseif ga == 4 then

                      lvar.fxsel_mode = 1

                    elseif ga == 5 then

                      lvar.fxsel_plugtype = 1-lvar.fxsel_plugtype
                    
                    end                  
                  end
                
                elseif MOUSE_click(obj.sections[15]) and not lvar.hide_globalshortcuts2 then
                
                  lvar.showglobalmap = not lvar.showglobalmap
                  TemplateChanged()
                  lupd.update_gfx = true

                elseif MOUSE_click_RB(obj.sections[16]) then
                
                  GSaveMenu()
                
                elseif MOUSE_click(obj.sections[16]) then
                  
                  if lvar.currentglobalmap then
                    if lvar.currentglobalmap == 1 then
                      lvar.saveglob_highlight = false
                      local fn = paths.globtemplate_path..LBX_DEFGLOBALTMP
                      SaveFXParamTemplate(nil, globtemplate, fn, nil, true)
                      GUI_FlashButton(obj, gui, 16, 'SAVING', 0.1, '205 205 205')
                    else
                      local p = lvar.currentglobalmap
                      lvar.saveglob_highlight = false
                      local fn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',p) ..'.smtemp'
                      SaveFXParamTemplate(nil, globtemplate, fn, nil, true)
                      GUI_FlashButton(obj, gui, 16, 'SAVING', 0.1, '205 205 205')
                    end
                  end
                  if lvar.saveperm_highlight then
                    local fn = paths.globtemplate_path..LBX_PERMATMP
                    SaveFXParamTemplate(nil, permatemplate, fn, true, true)
                    lvar.saveperm_highlight = false
                  end
                  
                elseif MOUSE_click(obj.sections[19]) then
                  FlipParams()
                  BState_DelReset(i)

                elseif MOUSE_click_RB(obj.sections[1001]) then
                  FiltMenu(mouse.shift)
                elseif MOUSE_click(obj.sections[1001]) then
                  if lvar.filtidx then
                    lvar.filtidx = nil
                    lvar.filtidx2 = nil
                    lvar.fcountfilt = nil
                  else
                    UpdateFilter()
                  end
                  lupd.update_gfx = true

                elseif MOUSE_click(obj.sections[1002]) then
                  local bw = math.floor(obj.sections[1002].w/8)
                  local p = math.floor((mouse.mx - obj.sections[1002].x)/bw) + 1
                  if p >= 1 and p <= 8 then
                    if lvar.userfilter[p] then
                      if lvar.userfilter.select ~= p or not lvar.filtidx then
                        lvar.lstfilt = table.copy(lvar.userfilter[p].filter)
                        lvar.lstfiltsel = {}
                        for i = 1, #lvar.lstfilt do
                          lvar.lstfiltsel[lvar.lstfilt[i]] = true
                        end
                        lvar.userfilter.select = p
                        UpdateFilter()
                        lupd.update_gfx = true
                      else
                        lvar.filtidx = nil
                        lvar.filtidx2 = nil
                        lvar.fcountfilt = nil
                        lupd.update_gfx = true
                      end
                    end
                  end             
                     
                elseif MOUSE_click_RB(obj.sections[1002]) then
                  local bw = math.floor(obj.sections[1002].w/8)
                  local p = math.floor((mouse.mx - obj.sections[1002].x)/bw) + 1
                  if p >= 1 and p <= 8 then
                    if lvar.userfilter[p] or #lvar.lstfilt > 0 then
                      local dis = ''
                      if not lvar.userfilter[p] then
                        dis = '#'
                      end
                      local fil2 = ''
                      if lvar.restorelastfilter then
                        fil2 = '#'
                      end
                      local fil = ''
                      if lvar.defaultfilter == p and not lvar.restorelastfilter then
                        fil = '!'
                      end
                      local rla = ''
                      if lvar.restorelastfilter then
                        rla = '!'
                      end
                      local menustr = 'Store current filter||'..dis..'Rename filter||Clear filter||'..fil2..fil..'Set as default|'..fil2..'Clear default||'..rla..'Restore last active filter on load'
                      gfx.x = mouse.mx
                      gfx.y = mouse.my
                      local res = gfx.showmenu(menustr)
                      if res > 0 then
                        if res == 1 then
                        
                          lvar.userfilter[p] = {}
                          lvar.userfilter[p].filter = table.copy(lvar.lstfilt)
                          local ftxt
                          if #lvar.lstfilt > 1 then
                            ftxt = 'MULTI FILTER'
                          else --if lvar.filtidx then
                            ftxt = string.gsub((tab_filters[lvar.lstfilt[1]] or 'User '..string.format('%i',p)),'|','')
                          --[[else
                            ftxt = 'User '..string.format('%i',p)]]
                          end
                          lvar.userfilter[p].name = ftxt --'User '..string.format('%i',p)
                          lvar.userfilter.select = p
                          lupd.update_gfx = true
                        
                        elseif res == 2 then
                        
                          local ret, nm = reaper.GetUserInputs('User Filter Rename',1,'Please enter name for filter '..string.format('%i',p)..':,extrawidth=200','')
                          if ret and nm then
                            lvar.userfilter[p].name = nm
                            lupd.update_gfx = true
                          end                        

                        elseif res == 3 then
                          lvar.userfilter[p] = nil
                          lvar.userfilter.select = nil
                          lupd.update_gfx = true

                        elseif res == 4 then
                          lvar.restorelastfilter = false
                          lvar.defaultfilter = p

                        elseif res == 5 then
                          lvar.defaultfilter = nil

                        elseif res == 6 then
                          lvar.restorelastfilter = not lvar.restorelastfilter
                          
                        end
                      end
                    end
                  end
                  
                elseif MOUSE_click_RB(obj.sections[20]) then
                  if lvar.ccstamp_active == 1 or not mouse.shift then
                    if mouse.shift then
                      GUI_FlashButton(obj, gui, 20, 'PRINT VAL', 0.1, ptype_info[2].col, -4)
                    else
                      GUI_FlashButton(obj, gui, 20, 'PRINT VAL', 0.1, '205 205 205', -4)
                    end
                    if lvar.ccstamp_active ~= 1 then
                      lvar.ccstamp_active = 1
                      SetUpCCStampData()
                      StampSelectedItems()
                      lvar.ccstamp_active = 0
                      SetUpCCStampData()
                    else
                      StampSelectedItems()
                    end
                  end
                elseif MOUSE_click(obj.sections[20]) then
                  lvar.ccstamp_active = 1-lvar.ccstamp_active
                  SetUpCCStampData()
                  lupd.update_gfx = true

                elseif MOUSE_click(obj.sections[23]) then
                  --AUTO LANES
                  lvar.midieditor_cclanes = not lvar.midieditor_cclanes
                  if lvar.midieditor_cclanes == true then
                    lvar.update_midieditor_cclanes = true
                  end
                  lupd.update_gfx = true
                
                elseif MOUSE_click_RB(obj.sections[23]) then
                  LanesMenu()
                  
                elseif MOUSE_click(obj.sections[24]) then
                  if mouse.ctrl then
                    StoreLaneOverrideData()
                    lupd.update_gfx = true
                  else
                    --enable/disable override
                    lvar.lanes_ov_enable = not lvar.lanes_ov_enable
                    lvar.midieditor_cclanes_offset = -1
                    --[[local track, trnm = GetCCLanesTrack()
                    DBG(lvar.lanes_ov_tab[trnm].all)]]
                    if lvar.midieditor_cclanes == true then
                      lvar.update_midieditor_cclanes = true
                    end
                    lupd.update_gfx = true
                  end
                  
                elseif MOUSE_click_RB(obj.sections[24]) then
                  if mouse.ctrl then
                    local track, trnm = GetCCLanesTrack()
                    if track then
                      lvar.lanes_ov_tab[trnm] = nil
                      if lvar.lanes_presets[trnm] then
                        lvar.lanes_presets[trnm].select = nil
                      end
                      lupd.update_gfx = true
                    end
                  else
                    LanesOvMenu()
                  end

                elseif MOUSE_click(obj.sections[25]) then
                  local _, trnm = GetCCLanesTrack()
                  if lvar.lanes_presets[trnm] then
                    local p = F_limit(math.floor((mouse.mx - obj.sections[25].x)/(obj.sections[25].w/8)) + 1,1,8)
                    if lvar.lanes_presets[trnm][p] then
                      if p ~= lvar.lanes_presets[trnm].select or not lvar.lanes_ov_enable then
                        lvar.lanes_ov_enable = true
                        lvar.lanes_presets[trnm].select = p
                        lvar.lanes_ov_tab[trnm] = {all = lvar.lanes_presets[trnm][p]}
                        lvar.midieditor_cclanes_offset = -1
                        if lvar.midieditor_cclanes == true then
                          lvar.update_midieditor_cclanes = true
                        end
                      else
                        lvar.lanes_ov_enable = not lvar.lanes_ov_enable
                        lvar.midieditor_cclanes_offset = -1
                        if lvar.midieditor_cclanes == true then
                          lvar.update_midieditor_cclanes = true
                        end
                      end
                      lupd.update_gfx = true
                    else
                      LanesPresetMenu(p)
                    end
                  else
                    local p = F_limit(math.floor((mouse.mx - obj.sections[25].x)/(obj.sections[25].w/8)) + 1,1,8)
                    LanesPresetMenu(p)                  
                  end
                
                elseif MOUSE_click_RB(obj.sections[25]) then
                  
                  local p = F_limit(math.floor((mouse.mx - obj.sections[25].x)/(obj.sections[25].w/8)) + 1,1,8)
                  LanesPresetMenu(p)

                elseif MOUSE_click(obj.sections[31]) then
                  --SHOW CTL
                  lvar.showcontrolname = not lvar.showcontrolname
                  lupd.update_gfx = true

                elseif MOUSE_click(obj.sections[32]) then
                  if mouse.ctrl then
                    local playstate = reaper.GetPlayState()
                    if playstate == 0 then 
                      lvar.rr_defeat_active = not lvar.rr_defeat_active
                      lupd.update_gfx = true
                    end
                  else
                    local playstate = reaper.GetPlayState()
                    if playstate == 0 and lvar.rr_defeat_active then 
                      lvar.rrsettings.overdubnotes = 1-lvar.rrsettings.overdubnotes
                      reaper.SetExtState(RRSCRIPT,'overdubnotes',nz(lvar.rrsettings.overdubnotes,1),true)
                      lupd.update_gfx = true
                    end
                  end

                elseif MOUSE_click_RB(obj.sections[32]) then
                  --RR SETTINGS
                  RRMenu()

                elseif MOUSE_click(obj.sections[33]) then
                  --FINETUNE
                  lvar.finetune_active = not lvar.finetune_active
                  TriggerCCChase() --ensure CC values are correct
                  SetFineTune()
                  TemplateChanged()
                  lupd.update_gfx = true
                  --SetCCs()
                  --lvar.readparams = nil
                  --A_ReadParamVals(nil, nil, true)

                elseif MOUSE_click_RB(obj.sections[33]) then
                  FTMenu()
                  
                elseif MOUSE_click(obj.sections[28]) then
                  --AUTO ENV
                  if recmode == 0 then
                    lvar.autoenv = not lvar.autoenv
                    lupd.update_gfx = true
                  end

                elseif MOUSE_click_RB(obj.sections[28]) then
                  --AUTO ENV
                  if recmode == 0 then
                    AutoEnvMenu()
                  end

                elseif MOUSE_click(obj.sections[29]) then
                  --layer
                  lvar.overtemplate_active = not lvar.overtemplate_active
                  TemplateChanged()
                  lupd.update_gfx = true

                elseif MOUSE_click_RB(obj.sections[29]) then
                                    
                  LayerBtnMenu()
                                    
                elseif MOUSE_click(obj.sections[26]) then
                  local p = F_limit(math.floor((mouse.mx - obj.sections[26].x)/math.floor(obj.sections[26].w/lvar.overtmp_cnt)) + 1,1,lvar.overtmp_cnt)
                  if lvar.overtemplate == p then
                    lvar.overtemplate_active = not lvar.overtemplate_active
                  else
                    lvar.overtemplate_active = true
                    lvar.overtemplate = p
                  end
                  TemplateChanged()
                  lupd.update_gfx = true

                elseif MOUSE_click_RB(obj.sections[26]) then
                  local p = F_limit(math.floor((mouse.mx - obj.sections[26].x)/math.floor(obj.sections[26].w/lvar.overtmp_cnt)) + 1,1,lvar.overtmp_cnt)                
                  LayerMenu(p)
                  
                elseif MOUSE_click(obj.sections[21]) then
                  if #lvar.groupidx > 0 then
                    HLGroupButtons()
                    if lvar.ctlgroup_select == 0 then
                      lvar.ctlgroup_select = lvar.octlgroup_select or 1
                      HLGroupButtons(true)
                    else
                      lvar.octlgroup_select = lvar.ctlgroup_select
                      lvar.ctlgroup_select = 0
                    end
                    SendScribbleData()
                    lupd.update_gfx = true
                  end                  
                elseif MOUSE_click(obj.sections[22]) then
                  if #lvar.groupidx > 0 then
                    HLGroupButtons()
                    lvar.ctlgroup_select = lvar.ctlgroup_select +1
                    if lvar.ctlgroup_select > #lvar.groupidx then
                      lvar.ctlgroup_select = 0
                    end
                    HLGroupButtons(true)
                    SendScribbleData()
                    lupd.update_gfx = true
                  end                  
                elseif MOUSE_click_RB(obj.sections[22]) then
                  if #lvar.groupidx > 0 then
                    HLGroupButtons()
                    lvar.ctlgroup_select = lvar.ctlgroup_select -1
                    if lvar.ctlgroup_select < 0 then
                      lvar.ctlgroup_select = #lvar.groupidx
                    end
                    HLGroupButtons(true)
                    SendScribbleData()
                    lupd.update_gfx = true
                  end                  
                elseif MOUSE_click(obj.sections[27]) then
                
                  if lvar.takeover.active == -1 then
                    lvar.takeover.active = 1
                  elseif lvar.takeover.active == 4 then
                    lvar.takeover.active = -1
                  else
                    lvar.takeover.active = lvar.takeover.active+1
                  end
                  InsertTakeoverAssignments()
                  TemplateChanged()
                  lupd.update_gfx = true
                
                elseif MOUSE_click_RB(obj.sections[27]) then
                  TOMenuRB()
                  
                elseif MOUSE_click_RB(obj.sections[17]) and not lvar.hide_globalshortcuts then
                  local ww = obj.sections[17].w / (lvar.gbc/2)
                  local hh = 22*lvar.guizoom
                  
                  local res = math.floor((mouse.mx-obj.sections[17].x) / ww) + math.floor((mouse.my-obj.sections[17].y) / hh)*(lvar.gbc/2) + 1
                  GlobalBtnMenu(res)
                               
                elseif MOUSE_click(obj.sections[17]) and not lvar.hide_globalshortcuts then
                  local ww = obj.sections[17].w / (lvar.gbc/2)
                  local hh = 22*lvar.guizoom
                  
                  local res = math.floor((mouse.mx-obj.sections[17].x) / ww) + math.floor((mouse.my-obj.sections[17].y) / hh)*(lvar.gbc/2) + 1
                  if not lvar.showglobalmap or res ~= lvar.currentglobalmap then
                    if res == 1 then
                      local fn = paths.globtemplate_path..LBX_DEFGLOBALTMP
                      lvar.showglobalmap = true
                      LoadGlobalMap(fn)
                      TemplateChanged() --have removed - don't think it's required - but need to check
                      --updatetravellingtracknames()
                      lupd.update_gfx = true
                    else
                      local p = res
                      local fn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',p) ..'.smtemp'
                      lvar.showglobalmap = true
                      LoadGlobalMap(fn, p)
                      TemplateChanged()
                      --updatetravellingtracknames()
                      lupd.update_gfx = true
                    end
                  else
                    lvar.showglobalmap = false
                    TemplateChanged()
                    --updatetravellingtracknames()
                    lupd.update_gfx = true                    
                  end
                
                elseif MOUSE_click_RB(obj.sections[8]) then
                
                  LearnMenu(mouse.mx, mouse.my)
                  
                elseif MOUSE_click(obj.sections[8]) then
                  lrnmode = not lrnmode
                  lupd.update_gfx = true
                  
                  --[[if lvar.autofocus ~= true then
                    lvar.forcefocus = true
                  else
                    if FFX then
                      lasttouched = nil
                      --chktm = reaper.time_precise()+1
                      lrnmode = not lrnmode
                      if lvar.mode == 3 then
                        lrnmode = false
                        reaper.MB('Learn function not available for current mode','Learn',0)
                      end
                      lupd.update_gfx = true
                    else
                      lrnmode = false
                      lupd.update_gfx = true            
                    end
                  end]]
                elseif MOUSE_click(obj.sections[9]) then
    
                  lvar.SetupOffs = 0
                  lvar.livemode = 1
                  lvar.showsetup = true
                  lupd.update_gfx = true
    
                elseif MOUSE_click(obj.sections[150]) then
                  if mouse.ctrl then
                    lvar.disableSSplayback = not lvar.disableSSplayback
                  else
                    ToggleFBMode()
                  end
                  --else
                  --  FBToggle()
                  --end
                  
                elseif MOUSE_click_RB(obj.sections[150]) then
                
                  FBMenu()
                  
                elseif MOUSE_click_RB(obj.sections[9]) then
                  
                  SettingsMenu()
                  
                end
              end
              
              if mouse.context and mouse.context == contexts.sliderctl then
        
                local i = slider_select
                local xywh = {x = obj.sections[1].x+4,
                              y = math.floor(obj.sections[1].y + (i-1)*(fader_h+fader_space)),
                              w = obj.sections[1].w-8,
                              h = fader_h}
                local val = MOUSE_slider_horiz2(xywh,mouse.slideoff)
                if val ~= nil then
                  
                  if val < 0 then val = 0 end
                  if val > 1 then val = 1 end
                  if val ~= octlval then
  
                    local tmp
                    tmp = GetTemplate(i)
                    --[[if permatemplate.pos[i] then
                      tmp = permatemplate
                    elseif globtemplate.pos[i] and lvar.showglobalmap then
                      tmp = globtemplate
                    else
                      tmp = template
                    end]]
                    
                    BtnToggle(tmp, i, val)
                    
                    --[[local track = GetTrack(FFX.trn)
                    local fxnum = FFX.fxnum
                    local cc = tmp.pos[i].cc
                    if cc ~= true then
                      local pnum = tmp.pos[i].pnum
                                  
                      reaper.TrackFX_SetParamNormalized(track, fxnum, pnum, val)
                      SetFaderBoxVal(i, val*16383)
                      tmp.dirty[i] = true
                      octlval = val
                      lupd.update_fader = true
                    else
                    --DBG('A')
                      SetCCVal(i, val)
                      SetFaderBoxVal(i, val*16383)
                      tmp.dirty[i] = true
                      octlval = val
                      lupd.update_fader = true
                    end]]
                  end
                end
                
              elseif mouse.context and mouse.context == contexts.vscrollb then
                local fc = lvar.fcountfilt or lvar.fcount
                local data = lvar.vscrollb
                local yy = F_limit(mouse.my - data.offs - obj.sections[1000].y,0,obj.sections[1000].h-data.bh)
                local pos = yy/(obj.sections[1000].h-data.bh)
                local co = round(pos*(fc-data.viscnt))
                if co ~= lvar.vscrollb_pos then
                  control_offs = co
                  lvar.vscrollb_pos = co
                  lupd.update_gfx = true
                end
              
              elseif mouse.context == nil and lvar.vscrollb then
                lvar.vscrollb = nil
                lupd.update_gfx = true  
              end
            
            --[[else
              --Learn mode
              if FFX then
                if mouse.context == nil and MOUSE_click(obj.sections[8]) then
                  lrnmode = not lrnmode
                  lupd.update_gfx = true
                end
              
                local retval, trn, fxn, pn = reaper.GetLastTouchedFX()
                if retval == true then
                  if lasttouched == nil then
                    lasttouched = {trn = trn, fxn = fxn, pn = pn}
                  
                  elseif (trn == FFX.trn and fxn == FFX.fxnum and pn ~= lasttouched.pn) then
        
                    lasttouched = {trn = trn, fxn = fxn, pn = pn}
        
                    local fnd = false
                    for i = 1, lvar.fcount do
                      if template.pos[i] and string.format('%i',template.pos[i].pnum) == string.format('%i',pn) then
                        fnd = true
                        break
                      end
                    end
                    if fnd == false then
                      local i = #template.pos+1
                      local track = GetTrack(FFX.trn)
                      local _, pname = reaper.TrackFX_GetParamName(track, FFX.fxnum, pn, '')
                      SetTemplateParam(i, pn, pname)
                                      
                      local fxnum = FFX.fxnum
                      local pnum = template.pos[i].pnum
                      local val = reaper.TrackFX_GetParamNormalized(track, fxnum, pnum)
                      template.pos[i].val = val
                      SetFaderBoxVal(i, val)
                      
                      template.dirty[i] = true
                      lupd.update_fader = true
                    end
                  end
                end
              end
            end]]
          else
            lvar.livemode = 1
            LoadSetUp_Proj()
            lvar.showsetup = true
            lupd.update_gfx = true
          end  
        end
      end

      for i = 1, lvar.fcount do
        local tmp
        if lvar.rec_mapactiveenvstofaders and rectemplate.sft[i] then
          tmp = rectemplate
        elseif lvar.strippertemplate_active and strippertemplate.sft[i] then
          tmp = strippertemplate
        elseif lvar.tmptoplayer_active and tmptoplayer.sft[i] then
          tmp = tmptoplayer
        elseif totemplate.sft[i] then
          tmp = totemplate  
        elseif permatemplate.sft[i] then
          tmp = permatemplate
        elseif globtemplate.sft[i] then
          tmp = globtemplate
        elseif template.layer and lvar.overtemplate_active and 
               template.layer[lvar.overtemplate] and template.layer[lvar.overtemplate].sft[i] then
          tmp = template.layer[lvar.overtemplate] 
        else
          tmp = template 
        end

        if tmp.sft[i] and tmp.sft[i] <= reaper.time_precise() and tmp.eft[i] > reaper.time_precise() then
          lupd.update_fader = true
          break
        end
      end

   end
      
    -------------------------------------------
    
    if not mouse.LB and not mouse.RB then mouse.context = nil end
    local char = gfx.getchar() 
    if char then 
      if char == 32 then reaper.Main_OnCommandEx(40044, 0,0) end
      if char>=0 and char~=27 then --[[DBGOut('exit func: run (defer)')]] reaper.defer(run) end
    else
      --DBGOut('exit func: run (defer)')
      reaper.defer(run)
    end
    --gfx.update()
    mouse.last_LB = mouse.LB
    mouse.last_RB = mouse.RB
    mouse.last_x = mouse.mx
    mouse.last_y = mouse.my
    if mouse.LB then
      mouse.lastLBclicktime = rt
    end
    gfx.mouse_wheel = 0
    
    if refresh_gfx and mouse.context == nil and reaper.time_precise() >= refresh_gfx then
      refresh_gfx = nil
      lupd.update_gfx = true
    end    
    
    --[[if sfade and sfade <= reaper.time_precise() and efade > reaper.time_precise() then
      lupd.update_fader = true
    end]]
    
    --DBG(reaper.time_precise()-rt)
    
  end
  
  function quit()
  
    if recmode ~= 0 then
    
      SetRecMode(-1)
      --REC_AutoTracks_Restore()
    end
    if lvar.tags.tagshow_vis then
      ToggleShowTag(false)
    end
  
    SaveSettings()      
    gfx.quit()
    reaper.SetToggleCommandState(0, lvar.lbx_commid, 0)
    reaper.RefreshToolbar2(0, lvar.lbx_commid)
    ShowVSS(false)
    
  end
  
  function GES(key, nilallowed)
    if nilallowed == nil then nilallowed = false end
    
    local val = reaper.GetExtState(SCRIPT,key)
    if nilallowed then
      if val == '' then
        val = nil
      end
    end
    return val
  end
  
  function GetCtlMaps(sub)
    
    local i = 0
    local ii = 1
    local tmp = {}
    local mapf = reaper.EnumerateFiles(paths.ctemplate_path,i)
    while mapf ~= nil do
      local mapn, mape = string.match(mapf,'(.+)%.(.*)') 
      if mape == 'skctlmap' then
        tmp[ii] = mapn
        ii = ii + 1
      end
      i=i+1
      mapf = reaper.EnumerateFiles(paths.ctemplate_path,i)
    end
    
    ii=ii-1
    local str = ''
    if sub then
      str = '|>Controller Maps'
    end
    for i = 1, ii do
      if i == ii and sub then
        str = str .. '|<' .. tmp[i]      
      else
        str = str .. '|' .. tmp[i]
      end
    end
    if not sub then
      str = string.sub(str,2)
    end
    return tmp, str, ii
  end
  
  function SetAllFadersDirty()
    for i = 1, lvar.fcount do
      local tmp
      tmp = GetTemplate(i)
      --[[if permatemplate.pos[i] then
        tmp = permatemplate
      elseif globtemplate.pos[i] and lvar.showglobalmap then
        tmp = globtemplate
      else
        tmp = template
      end]]
      tmp.dirty[i] = true
    end
    lupd.update_fader = true
  end
  
  function GlobalSave()
    if lvar.currentglobalmap then
      if lvar.currentglobalmap == 1 then
        lvar.saveglob_highlight = false
        local fn = paths.globtemplate_path..LBX_DEFGLOBALTMP
        SaveFXParamTemplate(nil, globtemplate, fn, nil, true)
        GUI_FlashButton(obj, gui, 16, 'GLOBAL SAVE', 0.1, '205 205 205')
      else
        local p = lvar.currentglobalmap
        lvar.saveglob_highlight = false
        local fn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',p) ..'.smtemp'
        SaveFXParamTemplate(nil, globtemplate, fn, nil, true)
        GUI_FlashButton(obj, gui, 16, 'GLOBAL SAVE', 0.1, '205 205 205')
      end
    end
  end
  
  function GSaveMenu()

    local cop = '#'
    if lvar.copytemplate then
      cop = ''
    end
    
    local svmap = 'Save to global map 1'
    for i = 1, lvar.globmapcnt do

      svmap = svmap .. '|'
      local mp = lvar.globmapnames[i+1] 
      if not mp then
        mp = 'Save to global map '..string.format('%i',i+1)
      else
        mp = 'Save to global map: '..mp
      end
      svmap = svmap..mp
    end
    mstr = 'Copy global map|'..cop..'Paste global map||'..svmap ..'||Save global map|Load global map'
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then
        lvar.copytemplate2 = nil        
        lvar.copytemplate = {dirty = {},
                            pos = {},
                            sft = {},
                            eft = {}}
        lvar.copytemplate.pos = table.copy(globtemplate.pos)
        
      elseif res == 2 then
      
        if lvar.copytemplate then
          globtemplate = table.copy(lvar.copytemplate)
          lvar.saveglob_highlight = true
          lvar.showglobalmap = true
          TemplateChanged()
          lupd.update_gfx = true
        end
        
      elseif res == 3 then
        lvar.saveglob_highlight = false
        local fn = paths.globtemplate_path..LBX_DEFGLOBALTMP
        SaveFXParamTemplate(nil, globtemplate, fn, nil, true)
        GUI_FlashButton(obj, gui, 16, 'SAVE', 0.1, '205 205 205')
        
      elseif res < 3+lvar.globmapcnt then
        local p = res
        lvar.saveglob_highlight = false
        local fn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',p) ..'.smtemp'
        SaveFXParamTemplate(nil, globtemplate, fn, nil, true)
        GUI_FlashButton(obj, gui, 16, 'SAVE', 0.1, '205 205 205')
        
      elseif res == 3+lvar.globmapcnt + 1 then
        
        local retval, fn = reaper.JS_Dialog_BrowseForSaveFile('Save Global Map', paths.savedtemplate_path, 
                                                              '', "SK2 template files (.smtemp)\0*.smtemp\0\0")
        if retval == 1 then
          if not string.match(fn, '.*%.smtemp$') then
            fn = fn .. '.smtemp'
          end
          SaveFXParamTemplate(nil, globtemplate, fn, nil, true)
        end
      elseif res == 3+lvar.globmapcnt + 2 then
        
        local ret, fn = reaper.GetUserFileNameForRead(paths.savedtemplate_path..'.','Load Map','*.smtemp')
        if ret then
          globtemplate = {dirty = {},
                          pos = {},
                          sft = {},
                          eft = {}}
          globtemplate = LoadFXParamTemplate(nil, fn, true, true)
          SetCCs()
          SendScribbleData()
          SetUpCCStampData()
          lvar.saveglob_highlight = true
          lupd.update_gfx = true
        end        
      end
    end  
  end

  function GlobalBtnMenu(idx)

    local cop = '#'
    if lvar.copytemplate then
      cop = ''
    end
    local mstr = 'Copy global map|'..cop..'Paste global map||Clear'
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then
        lvar.copytemplate2 = nil        
        lvar.copytemplate = LoadGlobalMap2(idx)
      elseif res == 2 then
        if lvar.copytemplate then
          lvar.currentglobalmap = idx
          globtemplate = table.copy(lvar.copytemplate)
          lvar.saveglob_highlight = true
          lvar.showglobalmap = true
          TemplateChanged()
          lupd.update_gfx = true
        end
      elseif res == 3 then
        lvar.currentglobalmap = idx
        globtemplate = {dirty = {},
                        pos = {},
                        sft = {},
                        eft = {}}
        lvar.saveglob_highlight = true
        lvar.showglobalmap = true
        TemplateChanged()
        lupd.update_gfx = true        
      end
    end

  end
  
  function GlobalMenu()

    local tk1,tk2,tk3,tk4 = '','','',''
    local p = lvar.currentglobalmap
    if lvar.globmapdata[p] and lvar.globmapdata[p].solo == 1 then
      tk1 = '!'
    end
    local gm_mode = 'OFF'
    if lvar.globmapdata[p] and lvar.globmapdata[p].setmode == 3 then
      tk2 = '!'
      gm_mode = 'TRACK'
    elseif lvar.globmapdata[p] and lvar.globmapdata[p].setmode == 2 then
      tk3 = '!'
      gm_mode = 'INSTANCE'
    elseif lvar.globmapdata[p] and lvar.globmapdata[p].setmode == 1 then
      tk4 = '!'
      gm_mode = 'PLUGIN'
    end

    local ldmap = 'Rename current global map||'..tk1..'Solo global map when active|>Set global map mode: '..gm_mode..'|'..tk2..'Track mode|'..tk3..'Instance mode|<'..tk4..'Plugin mode|'
    for i = 0, lvar.globmapcnt do
      ldmap = ldmap .. '|'
      local mp = lvar.globmapnames[i+1] 
      if not mp then
        mp = 'Select global map '..string.format('%i',i+1)
      else
        mp = 'Select global map: '..mp
      end
      ldmap = ldmap..mp
    end
    
    mstr = ldmap
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then
        local p = lvar.currentglobalmap
        RenameCurrentGlobalMap(p)
      elseif res == 2 then
        --solo global map
        if lvar.globmapdata[p] then
          lvar.globmapdata[p].solo = 1 - lvar.globmapdata[p].solo
        end
        SaveGlobalMapNames()
        TemplateChanged()

      elseif res == 3 then --track
        if lvar.globmapdata[p] then
          if lvar.globmapdata[p].setmode == 3 then
            lvar.globmapdata[p].setmode = -1
          else
            lvar.globmapdata[p].setmode = 3
          end
        end
        SaveGlobalMapNames()

      elseif res == 4 then --instance
        if lvar.globmapdata[p] then
          if lvar.globmapdata[p].setmode == 2 then
            lvar.globmapdata[p].setmode = -1
          else
            lvar.globmapdata[p].setmode = 2
          end
        end
        SaveGlobalMapNames()

      elseif res == 5 then --plugin
        if lvar.globmapdata[p] then
          if lvar.globmapdata[p].setmode == 1 then
            lvar.globmapdata[p].setmode = -1
          else
            lvar.globmapdata[p].setmode = 1
          end
        end
        SaveGlobalMapNames()
      
      elseif res > 5 then
        res = res - 5
        if res == 1 then
          local fn = paths.globtemplate_path..LBX_DEFGLOBALTMP
          LoadGlobalMap(fn)
          updatetravellingtracknames()
          lupd.update_gfx = true
        else
          local p = res
          local fn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',p) ..'.smtemp'
          LoadGlobalMap(fn, p)
          updatetravellingtracknames()
          lupd.update_gfx = true
        end
      end
    end
    
  end
    
  function SaveBtnMenu()
  
    local cop = '#'
    if lvar.copytemplate then
      cop = ''
    end
    local cop2 = '#'
    if lvar.copytemplate or lvar.copytemplate2 then
      cop2 = ''
    end
    
    local show = 'Show'
    if lvar.showglobalmap then
      show = 'Hide'
    end
    local sdm = ''
    if lvar.mode ~= 3 then
      sdm = '#'
    end
    local mstr = 'Copy map|'..cop..'Paste map||Copy main layer|'..cop2..'Paste main layer||Clear main layer|Clear all||Load map|Save map||'
                 ..sdm..'Save to default map|'..sdm..'Replace current map with default map'
    
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then

      if res == 1 then

        lvar.copytemplate2 = nil
        lvar.copytemplate = table.copy(template)

      elseif res == 2 then

        if lvar.copytemplate then
          template = table.copy(lvar.copytemplate)
          lvar.save_highlight = true
          TemplateChanged()
          lupd.update_gfx = true

        end
                
      elseif res == 3 then
      
        lvar.copytemplate = nil
        lvar.copytemplate2 = {dirty = {},
                            pos = {},
                            sft = {},
                            eft = {}}
        lvar.copytemplate2.pos = table.copy(template.pos)
        lvar.copytemplate = lvar.copytemplate2
        
      elseif res == 4 then
        local cpl = lvar.copytemplate2 or lvar.copytemplate
        if cpl then
          --preserve layers
          local layer = template.layer
          template = table.copy(cpl)
          template.layer = layer
          lvar.save_highlight = true
          TemplateChanged()
          lupd.update_gfx = true
        end

      elseif res == 5 then
      
        local layer = template.layer
        template = {dirty = {},
                    pos = {},
                    sft = {},
                    eft = {}}
        template.layer = layer
        lvar.save_highlight = true
        TemplateChanged()
        
        --delete template file
        --os.remove()
        
        lupd.update_gfx = true
      
      elseif res == 6 then
        
        template = {dirty = {},
                    pos = {},
                    sft = {},
                    eft = {}}
        lvar.save_highlight = true
        TemplateChanged()
        lupd.update_gfx = true
              
      elseif res == 7 then
        local ret, fn = reaper.GetUserFileNameForRead(paths.savedtemplate_path..'.','Load map','*.smtemp')
        if ret then
          template = LoadFXParamTemplate(nil, fn, true)
          SetCCs()
          SendScribbleData()
          SetUpCCStampData()
          lupd.update_gfx = true
        end
      elseif res == 8 then
        --local ret, fn = reaper.GetUserInputs('Save template',1,'Please enter filename:,extrawidth=200','')
        local retval, fn = reaper.JS_Dialog_BrowseForSaveFile('Save map', paths.savedtemplate_path, 
                                                              '', "SK2 template files (.smtemp)\0*.smtemp\0\0")
        if retval == 1 then
          if not string.match(fn, '.*%.smtemp$') then
            fn = fn .. '.smtemp'
          end
          --local ffn = paths.savedtemplate_path..fn..'.smtemp'
          SaveFXParamTemplate(nil, template, fn, nil, false)
          GUI_FlashButton(obj, gui, 5, 'SAVE', 0.1, '205 205 205')
        end
      
      elseif res == 9 then
      
        local fn = paths.deftemplate_path..lvar.defaulttemplate_fn
        SaveFXParamTemplate(FFX, template, fn, nil, false)
        
        lvar.save_highlight = nil
        lupd.update_gfx = true
      
      elseif res == 10 then
      
        if not lvar.deflayout and reaper.MB('Clear assigned track map or tag from current track?', 'Use Default Map', 4) == 6 then
          --clear all
          template = {dirty = {},
                      pos = {},
                      sft = {},
                      eft = {}}
          --save
          SaveFXParamTemplate(FFX, template, nil, nil, false)
          
          SetSelectedTrackTags(nil, true, true)
  
          GUI_FlashButton(obj, gui, 5, 'SAVE', 0.1, '205 205 205')
        
          GetFFX(true)
          lvar.save_highlight = nil
          lupd.update_gfx = true
        end
        
      end
    end
  end
  
  function LoadGlobalMapNames()
  
    local ffn = paths.globtemplate_path..'mapnames'
    if ffn and reaper.file_exists(ffn) then  
      local file
      
      data = {}
      for line in io.lines(ffn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          val = string.gsub(val, '[\r]', '') --Remove \r for Mac use
          data[idx] = val
        end
      end
  
      for i = 1, lvar.globmapcnt+1 do
        local key = string.format('%i',i)
        lvar.globmapnames[i] = zn(data[key])
        lvar.globmapdata[i] = {solo = tonumber(zn(data[key..'_solo'])) or 0,
                               setmode = tonumber(zn(data[key..'_setmode'])) or -1}
      end
    end
  end

  function SaveGlobalMapNames()
    local ffn = paths.globtemplate_path..'mapnames'

    file=io.open(ffn,"w")
    for i = 1, lvar.globmapcnt+1 do
      local key = '['..string.format('%i',i)..']'
      file:write(key..(lvar.globmapnames[i] or '')..'\n')
      
      --data
      local key = '['..string.format('%i',i)..'_solo]'
      if lvar.globmapdata[i] then
        file:write(key..(lvar.globmapdata[i].solo or 0)..'\n')
      else
        file:write(key.. '0' ..'\n')
      end

      local key = '['..string.format('%i',i)..'_setmode]'
      if lvar.globmapdata[i] then
        file:write(key..(lvar.globmapdata[i].setmode or -1)..'\n')
      else
        file:write(key.. '-1' ..'\n')
      end
      
    end
    
    file:close()
  end
    
  function RenameCurrentGlobalMap(mapno)
    
    local ret, name = reaper.GetUserInputs('Rename Global Map',1,'Enter name:,extrawidth=150',lvar.globmapnames[mapno] or '')
    if ret then
      if (name or '') ~= '' then
        lvar.globmapnames[mapno] = name
      else
        lvar.globmapnames[mapno] = nil
      end
      SaveGlobalMapNames()
      lupd.update_gfx = true
      
    end
  end
  
  function LoadGlobalMap(fn, mapno, permanent)
    if permanent then
    
      fn = paths.globtemplate_path..LBX_PERMATMP
      permatemplate = LoadFXParamTemplate(nil, fn)
      SetUpCCStampData()
    else
      lvar.saveglob_highlight = false
      if mapno then
        lvar.currentglobalmap = mapno
      else
        lvar.currentglobalmap = 1
      end
      --DBG(lvar.currentglobalmap..'  '..fn)
      globtemplate = LoadFXParamTemplate(nil, fn)
      SetUpCCStampData()
      
      local p = lvar.currentglobalmap
      if lvar.globmapdata[p] and lvar.globmapdata[p].setmode and lvar.globmapdata[p].setmode ~= -1 then
        lvar.DisableTemplateChanged = true
        SetMode(lvar.globmapdata[p].setmode)
        lvar.DisableTemplateChanged = nil
      end
    end
  end

  function LoadGlobalMap2(mapno)
    local fn
    if mapno == 1 then
      fn = paths.globtemplate_path..LBX_DEFGLOBALTMP
    else  
      fn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',mapno) ..'.smtemp'
    end
    return LoadFXParamTemplate(nil, fn)
  end
    
  function SetMode(m)

    if not lvar.maplocked then
      lvar.mode = m
      reaper.SetExtState(PUSCRIPT, 'sk2mode', m, false)
      lvar.readparams = nil
      
      if m ~= 3 then
        if lvar.livemode == 4 or lvar.livemode == 5 then
          lvar.livemode = 1
        end
        
        if lvar.autoglob_plug == 1 then
          lvar.showglobalmap = true
        elseif lvar.autoglob_plug == 2 then
          lvar.showglobalmap = false
        end
      else
        if lvar.autoglob_track == 1 then
          lvar.showglobalmap = true
        elseif lvar.autoglob_track == 2 then
          lvar.showglobalmap = false      
        end
      end
      GetFFX(true)
      
      if lvar.filtidx then
        UpdateFilter()
      end
      
      SelectFader2(nil, false)
      lupd.update_gfx = true
    end
  end
  
  function GetCCMenuString()
  
    local cclanes = lvar.cclanes
    local lc = #cclanes

    local max = 9
    local str = '|>General'
    for i = 1, max do
      if i == max then
        str = str .. '|<' .. cclanes[i].txt
      else
        str = str .. '|' .. cclanes[i].txt
      end
    end
    local max = 41
    local str = str..'|>CC 0-31'
    for i = 10, max do
      if i == max then
        str = str .. '|<' .. cclanes[i].txt
      else
        str = str .. '|' .. cclanes[i].txt
      end
    end
    local max = 73
    local str = str..'|>CC 32-63'
    for i = 42, max do
      if i == max then
        str = str .. '|<' .. cclanes[i].txt
      else
        str = str .. '|' .. cclanes[i].txt
      end
    end
    local max = 105
    local str = str..'|>CC 64-95'
    for i = 74, max do
      if i == max then
        str = str .. '|<' .. cclanes[i].txt
      else
        str = str .. '|' .. cclanes[i].txt
      end
    end
    local max = 129
    local str = str..'|>CC 96-119'
    for i = 106, max do
      if i == max then
        str = str .. '|<' .. cclanes[i].txt
      else
        str = str .. '|' .. cclanes[i].txt
      end
    end
    local max = 161
    local str = str..'|>14 bit CC 0-31'
    for i = 130, max do
      if i == max then
        str = str .. '|<' .. cclanes[i].txt
      else
        str = str .. '|' .. cclanes[i].txt
      end
    end
    str = str .. '|<'
    
    
    
    --[[for i = 1, lc do
      if i == lc then
        str = str .. '|<' .. cclanes[i].txt
      else
        str = str .. '|' .. cclanes[i].txt
      end
    end]]
    return str
    
  end
  
  function InitTakeoverTypes()
    lvar.takeover_types[1] = {menutxt = 'VOLUME',
                              pname = 'Vol SEL',
                              trparam = 1,
                              trsend = -1,
                              troff = -1,
                              ptype = 3, cc = false, cc14bit = 0, ccchan = 0, ccnum = 0, pnum = -1, track = -1, actionid = -1, actionmon = 0, buttype = 4,
                              butstates = 2, code = -1, codeval = 0, enc_res = 512, defcc_val = -1, loc = '', sscolor = 7}

    lvar.takeover_types[2] = {menutxt = 'PAN',
                              pname = 'Pan SEL',
                              trparam = 2,
                              trsend = -1,
                              troff = -1,
                              ptype = 3, cc = false, cc14bit = 0, ccchan = 0, ccnum = 0, pnum = -1, track = -1, actionid = -1, actionmon = 0, buttype = 4,
                              butstates = 2, code = -1, codeval = 0, enc_res = 512, defcc_val = -1, loc = '', sscolor = 7}

    lvar.takeover_types[3] = {menutxt = 'SEND 1 VOLUME',
                              pname = 'Send 1 Vol',
                              trparam = -1,
                              trsend = 1,
                              troff = -1,
                              ptype = 3, cc = false, cc14bit = 0, ccchan = 0, ccnum = 0, pnum = -1, track = -1, actionid = -1, actionmon = 0, buttype = 4,
                              butstates = 2, code = -1, codeval = 0, enc_res = 512, defcc_val = -1, loc = '', sscolor = 7}

    lvar.takeover_types[4] = {menutxt = 'SEND 1 PAN',
                              pname = 'Send 1 Pan',
                              trparam = -1,
                              trsend = 2,
                              troff = -1,
                              ptype = 3, cc = false, cc14bit = 0, ccchan = 0, ccnum = 0, pnum = -1, track = -1, actionid = -1, actionmon = 0, buttype = 4,
                              butstates = 2, code = -1, codeval = 0, enc_res = 512, defcc_val = -1, loc = '', sscolor = 7}

    lvar.takeover_types[5] = {menutxt = 'SEND 2 VOLUME',
                              pname = 'Send 2 Vol',
                              trparam = -1,
                              trsend = 4,
                              troff = -1,
                              ptype = 3, cc = false, cc14bit = 0, ccchan = 0, ccnum = 0, pnum = -1, track = -1, actionid = -1, actionmon = 0, buttype = 4,
                              butstates = 2, code = -1, codeval = 0, enc_res = 512, defcc_val = -1, loc = '', sscolor = 7}

    lvar.takeover_types[6] = {menutxt = 'SEND 2 PAN',
                              pname = 'Send 2 Pan',
                              trparam = -1,
                              trsend = 5,
                              troff = -1,
                              ptype = 3, cc = false, cc14bit = 0, ccchan = 0, ccnum = 0, pnum = -1, track = -1, actionid = -1, actionmon = 0, buttype = 4,
                              butstates = 2, code = -1, codeval = 0, enc_res = 512, defcc_val = -1, loc = '', sscolor = 7}

    lvar.takeover_types[7] = {menutxt = 'SEND 3 VOLUME',
                              pname = 'Send 3 Vol',
                              trparam = -1,
                              trsend = 7,
                              troff = -1,
                              ptype = 3, cc = false, cc14bit = 0, ccchan = 0, ccnum = 0, pnum = -1, track = -1, actionid = -1, actionmon = 0, buttype = 4,
                              butstates = 2, code = -1, codeval = 0, enc_res = 512, defcc_val = -1, loc = '', sscolor = 7}

    lvar.takeover_types[8] = {menutxt = 'SEND 3 PAN',
                              pname = 'Send 3 Pan',
                              trparam = -1,
                              trsend = 8,
                              troff = -1,
                              ptype = 3, cc = false, cc14bit = 0, ccchan = 0, ccnum = 0, pnum = -1, track = -1, actionid = -1, actionmon = 0, buttype = 4,
                              butstates = 2, code = -1, codeval = 0, enc_res = 512, defcc_val = -1, loc = '', sscolor = 7}

    lvar.takeover_types[9] = {menutxt = 'SEND 4 VOLUME',
                              pname = 'Send 3 Vol',
                              trparam = -1,
                              trsend = 10,
                              troff = -1,
                              ptype = 3, cc = false, cc14bit = 0, ccchan = 0, ccnum = 0, pnum = -1, track = -1, actionid = -1, actionmon = 0, buttype = 4,
                              butstates = 2, code = -1, codeval = 0, enc_res = 512, defcc_val = -1, loc = '', sscolor = 7}

    lvar.takeover_types[10] = {menutxt = 'SEND 4 PAN',
                              pname = 'Send 3 Pan',
                              trparam = -1,
                              trsend = 11,
                              troff = -1,
                              ptype = 3, cc = false, cc14bit = 0, ccchan = 0, ccnum = 0, pnum = -1, track = -1, actionid = -1, actionmon = 0, buttype = 4,
                              butstates = 2, code = -1, codeval = 0, enc_res = 512, defcc_val = -1, loc = '', sscolor = 7}
      
  end
  
  function InitCCTable()
  
    lvar.cclanes = {}

    lvar.cclanes[1] = {txt = 'Velocity', val = -1, idx = 0}
    lvar.cclanes[2] = {txt = 'Off Velocity', val = 167, idx = 1}
    lvar.cclanes[3] = {txt = 'Pitch', val = 128, idx = 2}
    lvar.cclanes[4] = {txt = 'Program', val = 129, idx = 3}
    lvar.cclanes[5] = {txt = 'Channel Pressure', val = 130, idx = 4}
    lvar.cclanes[6] = {txt = 'Bank/Program Select', val = 131, idx = 5}
    lvar.cclanes[7] = {txt = 'Text Events', val = 132, idx = 6}
    lvar.cclanes[8] = {txt = 'Notation Events', val = -99, idx = 7}
    lvar.cclanes[9] = {txt = 'Sysex', val = 133, idx = 8}
    lvar.cclanes[10] = {txt = '00 Bank Select MSB', val = 0, idx = 9}
    lvar.cclanes[11] = {txt = '01 Mod Wheel MSB', val = 1, idx = 10}
    lvar.cclanes[12] = {txt = '02 Breath MSB', val = 2, idx = 11}
    lvar.cclanes[13] = {txt = '03 ', val = 3, idx = 12}
    lvar.cclanes[14] = {txt = '04 Foot Pedal MSB', val = 4, idx = 13}
    lvar.cclanes[15] = {txt = '05 Portamento MSB', val = 5, idx = 14}
    lvar.cclanes[16] = {txt = '06 Data Entry MSB', val = 6, idx = 15}
    lvar.cclanes[17] = {txt = '07 Volume MSB', val = 7, idx = 16}
    lvar.cclanes[18] = {txt = '08 Balance MSB', val = 8, idx = 17}
    lvar.cclanes[19] = {txt = '09 ', val = 9, idx = 18}
    lvar.cclanes[20] = {txt = '10 Pan Position MSB', val = 10, idx = 19}
    lvar.cclanes[21] = {txt = '11 Expression MSB', val = 11, idx = 20}
    lvar.cclanes[22] = {txt = '12 Control 1 MSB', val = 12, idx = 21}
    lvar.cclanes[23] = {txt = '13 Control 2 MSB', val = 13, idx = 22}
    lvar.cclanes[24] = {txt = '14 ', val = 14, idx = 23}
    lvar.cclanes[25] = {txt = '15 ', val = 15, idx = 24}
    lvar.cclanes[26] = {txt = '16 GP Slider 1', val = 16, idx = 25}
    lvar.cclanes[27] = {txt = '17 GP Slider 2', val = 17, idx = 26}
    lvar.cclanes[28] = {txt = '18 GP Slider 3', val = 18, idx = 27}
    lvar.cclanes[29] = {txt = '19 GP Slider 4', val = 19, idx = 28}
    lvar.cclanes[30] = {txt = '20 ', val = 20, idx = 29}
    lvar.cclanes[31] = {txt = '21 ', val = 21, idx = 30}
    lvar.cclanes[32] = {txt = '22 ', val = 22, idx = 31}
    lvar.cclanes[33] = {txt = '23 ', val = 23, idx = 32}
    lvar.cclanes[34] = {txt = '24 ', val = 24, idx = 33}
    lvar.cclanes[35] = {txt = '25 ', val = 25, idx = 34}
    lvar.cclanes[36] = {txt = '26 ', val = 26, idx = 35}
    lvar.cclanes[37] = {txt = '27 ', val = 27, idx = 36}
    lvar.cclanes[38] = {txt = '28 ', val = 28, idx = 37}
    lvar.cclanes[39] = {txt = '29 ', val = 29, idx = 38}
    lvar.cclanes[40] = {txt = '30 ', val = 30, idx = 39}
    lvar.cclanes[41] = {txt = '31 ', val = 31, idx = 40}
    lvar.cclanes[42] = {txt = '32 Bank Select LSB', val = 32, idx = 41}
    lvar.cclanes[43] = {txt = '33 Mod Wheel LSB', val = 33, idx = 42}
    lvar.cclanes[44] = {txt = '34 Breath LSB', val = 34, idx = 43}
    lvar.cclanes[45] = {txt = '35 ', val = 35, idx = 44}
    lvar.cclanes[46] = {txt = '36 Foot Pedal LSB', val = 36, idx = 45}
    lvar.cclanes[47] = {txt = '37 Portamento LSB', val = 37, idx = 46}
    lvar.cclanes[48] = {txt = '38 Data Entry LSB', val = 38, idx = 47}
    lvar.cclanes[49] = {txt = '39 Volume LSB', val = 39, idx = 48}
    lvar.cclanes[50] = {txt = '40 Balance LSB', val = 40, idx = 49}
    lvar.cclanes[51] = {txt = '41 ', val = 41, idx = 50}
    lvar.cclanes[52] = {txt = '42 Pan Position LSB', val = 42, idx = 51}
    lvar.cclanes[53] = {txt = '43 Expression LSB', val = 43, idx = 52}
    lvar.cclanes[54] = {txt = '44 Control 1 LSB', val = 44, idx = 53}
    lvar.cclanes[55] = {txt = '45 Control 2 LSB', val = 45, idx = 54}
    lvar.cclanes[56] = {txt = '46 ', val = 46, idx = 55}
    lvar.cclanes[57] = {txt = '47 ', val = 47, idx = 56}
    lvar.cclanes[58] = {txt = '48 ', val = 48, idx = 57}
    lvar.cclanes[59] = {txt = '49 ', val = 49, idx = 58}
    lvar.cclanes[60] = {txt = '50 ', val = 50, idx = 59}
    lvar.cclanes[61] = {txt = '51 ', val = 51, idx = 60}
    lvar.cclanes[62] = {txt = '52 ', val = 52, idx = 61}
    lvar.cclanes[63] = {txt = '53 ', val = 53, idx = 62}
    lvar.cclanes[64] = {txt = '54 ', val = 54, idx = 63}
    lvar.cclanes[65] = {txt = '55 ', val = 55, idx = 64}
    lvar.cclanes[66] = {txt = '56 ', val = 56, idx = 65}
    lvar.cclanes[67] = {txt = '57 ', val = 57, idx = 66}
    lvar.cclanes[68] = {txt = '58 ', val = 58, idx = 67}
    lvar.cclanes[69] = {txt = '59 ', val = 59, idx = 68}
    lvar.cclanes[70] = {txt = '60 ', val = 60, idx = 69}
    lvar.cclanes[71] = {txt = '61 ', val = 61, idx = 70}
    lvar.cclanes[72] = {txt = '62 ', val = 62, idx = 71}
    lvar.cclanes[73] = {txt = '63 ', val = 63, idx = 72}
    lvar.cclanes[74] = {txt = '64 Hold Pedal (on/off)', val = 64, idx = 73}
    lvar.cclanes[75] = {txt = '65 Portamento (on/off)', val = 65, idx = 74}
    lvar.cclanes[76] = {txt = '66 Sostenuto (on/off)', val = 66, idx = 75}
    lvar.cclanes[77] = {txt = '67 Soft Pedal (on/off)', val = 67, idx = 76}
    lvar.cclanes[78] = {txt = '68 Legato Pedal (on/off)', val = 68, idx = 77}
    lvar.cclanes[79] = {txt = '69 Hold 2 Pedal (on/off)', val = 69, idx = 78}
    lvar.cclanes[80] = {txt = '70 Sound Variation', val = 70, idx = 79}
    lvar.cclanes[81] = {txt = '71 Timbre/Resonance', val = 71, idx = 80}
    lvar.cclanes[82] = {txt = '72 Sound Release', val = 72, idx = 81}
    lvar.cclanes[83] = {txt = '73 Sound Attack', val = 73, idx = 82}
    lvar.cclanes[84] = {txt = '74 Brightness/Cutoff Freq', val = 74, idx = 83}
    lvar.cclanes[85] = {txt = '75 Sound Control 6', val = 75, idx = 84}
    lvar.cclanes[86] = {txt = '76 Sound Control 7', val = 76, idx = 85}
    lvar.cclanes[87] = {txt = '77 Sound Control 8', val = 77, idx = 86}
    lvar.cclanes[88] = {txt = '78 Sound Control 9', val = 78, idx = 87}
    lvar.cclanes[89] = {txt = '79 Sound Control 10', val = 79, idx = 88}
    lvar.cclanes[90] = {txt = '80 GP Button 1 (on/off)', val = 80, idx = 89}
    lvar.cclanes[91] = {txt = '81 GP Button 2 (on/off)', val = 81, idx = 90}
    lvar.cclanes[92] = {txt = '82 GP Button 3 (on/off)', val = 82, idx = 91}
    lvar.cclanes[93] = {txt = '83 GP Button 4 (on/off)', val = 83, idx = 92}
    lvar.cclanes[94] = {txt = '84 ', val = 84, idx = 93}
    lvar.cclanes[95] = {txt = '85 ', val = 85, idx = 94}
    lvar.cclanes[96] = {txt = '86 ', val = 86, idx = 95}
    lvar.cclanes[97] = {txt = '87 ', val = 87, idx = 96}
    lvar.cclanes[98] = {txt = '88 ', val = 88, idx = 97}
    lvar.cclanes[99] = {txt = '89 ', val = 89, idx = 98}
    lvar.cclanes[100] = {txt = '90 ', val = 90, idx = 99}
    lvar.cclanes[101] = {txt = '91 Effects Level', val = 91, idx = 100}
    lvar.cclanes[102] = {txt = '92 Tremolo Level', val = 92, idx = 101}
    lvar.cclanes[103] = {txt = '93 Chorus Level', val = 93, idx = 102}
    lvar.cclanes[104] = {txt = '94 Celeste Level', val = 94, idx = 103}
    lvar.cclanes[105] = {txt = '95 Phaser Level', val = 95, idx = 104}
    lvar.cclanes[106] = {txt = '96 Data Button Inc', val = 96, idx = 105}
    lvar.cclanes[107] = {txt = '97 Data Button Dec', val = 97, idx = 106}
    lvar.cclanes[108] = {txt = '98 Non-Reg Parm LSB', val = 98, idx = 107}
    lvar.cclanes[109] = {txt = '99 Non-Reg Parm MSB', val = 99, idx = 108}
    lvar.cclanes[110] = {txt = '100 Reg Parm LSB', val = 100, idx = 109}
    lvar.cclanes[111] = {txt = '101 Reg Parm MSB', val = 101, idx = 110}
    lvar.cclanes[112] = {txt = '102 ', val = 102, idx = 111}
    lvar.cclanes[113] = {txt = '103 ', val = 103, idx = 112}
    lvar.cclanes[114] = {txt = '104 ', val = 104, idx = 113}
    lvar.cclanes[115] = {txt = '105 ', val = 105, idx = 114}
    lvar.cclanes[116] = {txt = '106 ', val = 106, idx = 115}
    lvar.cclanes[117] = {txt = '107 ', val = 107, idx = 116}
    lvar.cclanes[118] = {txt = '108 ', val = 108, idx = 117}
    lvar.cclanes[119] = {txt = '109 ', val = 109, idx = 118}
    lvar.cclanes[120] = {txt = '110 ', val = 110, idx = 119}
    lvar.cclanes[121] = {txt = '111 ', val = 111, idx = 120}
    lvar.cclanes[122] = {txt = '112 ', val = 112, idx = 121}
    lvar.cclanes[123] = {txt = '113 ', val = 113, idx = 122}
    lvar.cclanes[124] = {txt = '114 ', val = 114, idx = 123}
    lvar.cclanes[125] = {txt = '115 ', val = 115, idx = 124}
    lvar.cclanes[126] = {txt = '116 ', val = 116, idx = 125}
    lvar.cclanes[127] = {txt = '117 ', val = 117, idx = 126}
    lvar.cclanes[128] = {txt = '118 ', val = 118, idx = 127}
    lvar.cclanes[129] = {txt = '119 ', val = 119, idx = 128}
    lvar.cclanes[130] = {txt = '00/32 Bank Select 14-bit', val = 134, idx = 129}
    lvar.cclanes[131] = {txt = '01/33 Mod Wheel 14-bit', val = 135, idx = 130}
    lvar.cclanes[132] = {txt = '02/34 Breath 14-bit', val = 136, idx = 131}
    lvar.cclanes[133] = {txt = '03/35 14-bit', val = 137, idx = 132}
    lvar.cclanes[134] = {txt = '04/36 Foot Pedal 14-bit', val = 138, idx = 133}
    lvar.cclanes[135] = {txt = '05/37 Portamento 14-bit', val = 139, idx = 134}
    lvar.cclanes[136] = {txt = '06/38 Data Entry 14-bit', val = 140, idx = 135}
    lvar.cclanes[137] = {txt = '07/39 Volume 14-bit', val = 141, idx = 136}
    lvar.cclanes[138] = {txt = '08/40 Balance 14-bit', val = 142, idx = 137}
    lvar.cclanes[139] = {txt = '09/41 14-bit', val = 143, idx = 138}
    lvar.cclanes[140] = {txt = '10/42 Pan Position 14-bit', val = 144, idx = 139}
    lvar.cclanes[141] = {txt = '11/43 Expression 14-bit', val = 145, idx = 140}
    lvar.cclanes[142] = {txt = '12/44 Control 1 14-bit', val = 146, idx = 141}
    lvar.cclanes[143] = {txt = '13/45 Control 2 14-bit', val = 147, idx = 142}
    lvar.cclanes[144] = {txt = '14/46 14-bit', val = 148, idx = 143}
    lvar.cclanes[145] = {txt = '15/47 14-bit', val = 149, idx = 144}
    lvar.cclanes[146] = {txt = '16/48 GP Slider 1 14-bit', val = 150, idx = 145}
    lvar.cclanes[147] = {txt = '17/49 GP Slider 2 14-bit', val = 151, idx = 146}
    lvar.cclanes[148] = {txt = '18/50 GP Slider 3 14-bit', val = 152, idx = 147}
    lvar.cclanes[149] = {txt = '19/51 GP Slider 4 14-bit', val = 153, idx = 148}
    lvar.cclanes[150] = {txt = '20/52 14-bit', val = 154, idx = 149}
    lvar.cclanes[151] = {txt = '21/53 14-bit', val = 155, idx = 150}
    lvar.cclanes[152] = {txt = '22/54 14-bit', val = 156, idx = 151}
    lvar.cclanes[153] = {txt = '23/55 14-bit', val = 157, idx = 152}
    lvar.cclanes[154] = {txt = '24/56 14-bit', val = 158, idx = 153}
    lvar.cclanes[155] = {txt = '25/57 14-bit', val = 159, idx = 154}
    lvar.cclanes[156] = {txt = '26/58 14-bit', val = 160, idx = 155}
    lvar.cclanes[157] = {txt = '27/59 14-bit', val = 161, idx = 156}
    lvar.cclanes[158] = {txt = '28/60 14-bit', val = 162, idx = 157}
    lvar.cclanes[159] = {txt = '29/61 14-bit', val = 163, idx = 158}
    lvar.cclanes[160] = {txt = '30/62 14-bit', val = 164, idx = 159}
    lvar.cclanes[161] = {txt = '31/63 14-bit', val = 165, idx = 160}

  end
  
  function CalcSoloLaneHeight_Ov(lanestr)
    local lanes = mysplit(lanestr, '\n')
    local h = 0
    for i = 1, #lanes do
      hh = tonumber(string.match(lanes[i],'VELLANE [-]?%d+ (%d+) %d+'))
      if hh then
        h = h + hh
      end
    end
    return h
  end
  
  function GetCCLanesTrack(notags)
    local track = reaper.GetSelectedTrack2(0,0,true)
    if track then
      local trnm = reaper.GetTrackState(track)
      if not notags and lvar.tags.trackassoc[trnm] then
        if lvar.tags.trackassoc[trnm].tag then
          trnm = 'TAG_'..lvar.tags.trackassoc[trnm].tag
        end
      end
      
      return track, trnm
    end
  end
  
  function RestoreSelectedItems()

    local cnt2 = tonumber(reaper.GetExtState(RRSCRIPT,'seli_count')) or 0
    if cnt2 > 0 then
    
      --Store current
      local cnt = reaper.CountSelectedMediaItems(0)
      local iguids = {}
      
      if cnt > 0 then
        for i = 0, cnt-1 do
          local item = reaper.GetSelectedMediaItem(0, i)
          local itemguid = reaper.BR_GetMediaItemGUID(item)
          iguids[i] = itemguid
        end
      end
    
      reaper.SelectAllMediaItems(0,0)
      for i = 0, cnt2-1 do
        local key = 'ITEM_'..string.format('%i',i)..'_'
        local guid = reaper.GetExtState(RRSCRIPT, key..'seli_guid')
        local item = reaper.BR_GetMediaItemByGUID(0, guid)
        if item then
          reaper.SetMediaItemInfo_Value(item, 'B_UISEL', 1)
        end
      end
      if cnt > 0 then
        for i = 0, cnt-1 do
          local key = 'ITEM_'..string.format('%i',i)..'_'
          reaper.SetExtState(RRSCRIPT, key..'seli_guid', iguids[i], false)
        end
      end
      reaper.SetExtState(RRSCRIPT, 'seli_count', cnt, false)

      reaper.UpdateArrange()
    end
  end

  function FTMenu()
    mstr = 'Set Range ('..string.format('%i', lvar.fineamt/128)..')'
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then
        local res, val = reaper.GetUserInputs('Finetune Range',1,'Range +/- (1-64):',string.format('%i', lvar.fineamt/128))
        if res and tonumber(val) then
          val = math.floor(F_limit(tonumber(val),1,64))
          lvar.fineamt = val*128
          reaper.gmem_write(lvar.fineamt_idx, lvar.fineamt)
        end
      end
    end
    
  end
  
  function RRMenu()
    local t = ''
    if lvar.rrsettings.autoquantize ~= 0 then
      t = '!'
    end

    local t1 = ''
    if lvar.rrsettings.merge ~= 0 then
      t1 = '!'
    end

    local t2 = ''
    if lvar.rrsettings.extend ~= 0 then
      t2 = '!'
    end
    
    local t3 = ''
    if lvar.rrsettings.overdubnotes ~= 0 then
      t3 = '!'
    end

    local t4 = ''
    if lvar.rrsettings.timeselection ~= 0 then
      t4 = '!'
    end

    local t5 = ''
    if lvar.rrsettings.trackoffset ~= 0 then
      t5 = '!'
    end
    
    local sp2 = ''
    if lvar.cc_starttransportonfadertouch then
      sp2 = '!'
    end
    
    local sp3 = ''
    if lvar.rrsettings.autorestore == 1 then
      sp3 = '!'
    end
    
    local ccrel = ''
    if lvar.fdata_sendcconrel == 1 then
      ccrel = '!'
    end
    
    mstr = t1..'Merge With Existing Item|'..t2..'Extend Captured/Merged Item|'..t3..'Overdub Notes|'..t4..'Time Selection Mode|'
           ..t5..'Compensate Track Playback Offset|'..ccrel..'Send Last CC Value When Fader Released|'
           ..t..'Auto Quantize After Capture||Quantize Strength: '..string.format('%i',lvar.rrsettings.quantize_strength)
           ..'||'..sp3..'Restore Selected Item/s After Capture||'..sp2..'Start transport on fader touch (track mode)'
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then
        lvar.rrsettings.merge = 1 - lvar.rrsettings.merge
        reaper.SetExtState(RRSCRIPT,'merge',nz(lvar.rrsettings.merge,1),true)

      elseif res == 2 then
        lvar.rrsettings.extend = 1 - lvar.rrsettings.extend
        reaper.SetExtState(RRSCRIPT,'extend',nz(lvar.rrsettings.extend,1),true)

      elseif res == 3 then
        lvar.rrsettings.overdubnotes = 1 - lvar.rrsettings.overdubnotes
        reaper.SetExtState(RRSCRIPT,'overdubnotes',nz(lvar.rrsettings.overdubnotes,1),true)
        lupd.update_header = true
        
      elseif res == 4 then
        lvar.rrsettings.timeselection = 1 - lvar.rrsettings.timeselection
        reaper.SetExtState(RRSCRIPT,'timeselection',nz(lvar.rrsettings.timeselection,0),true)

      elseif res == 5 then
        lvar.rrsettings.trackoffset = 1 - lvar.rrsettings.trackoffset
        reaper.SetExtState(RRSCRIPT,'trackoffset',nz(lvar.rrsettings.trackoffset,0),true)

      elseif res == 6 then
        lvar.fdata_sendcconrel = 1-lvar.fdata_sendcconrel
        reaper.gmem_write(lvar.gm_cc.fdata_sendcconrel, lvar.fdata_sendcconrel)
        
      elseif res == 7 then
        lvar.rrsettings.autoquantize = 1 - lvar.rrsettings.autoquantize
        reaper.SetExtState(RRSCRIPT,'autoquantize',nz(lvar.rrsettings.autoquantize,0),true)
        
      elseif res == 8 then
        local res, val = reaper.GetUserInputs('Auto Quantize',1,'Quantize strength (0-100):',lvar.rrsettings.quantize_strength)
        if res and tonumber(val) then
          val = F_limit(tonumber(val),0,100)
          lvar.rrsettings.quantize_strength = val
          reaper.SetExtState(RRSCRIPT,'quantize_strength',lvar.rrsettings.quantize_strength,true)
        end

      elseif res == 9 then
        --RestoreSelectedItems()
        lvar.rrsettings.autorestore = 1-lvar.rrsettings.autorestore
        reaper.SetExtState(RRSCRIPT,'autorestore',lvar.rrsettings.autorestore,true)

      elseif res == 10 then
        lvar.cc_starttransportonfadertouch = not lvar.cc_starttransportonfadertouch
      end
    end
    
    
  end  
  
  function LanesPresetMenu(p)

    local _, trnm = GetCCLanesTrack()
    local cop = '#'
    if trnm then
      if lvar.lanes_presets[trnm] and lvar.lanes_presets[trnm][p] then
        cop = ''
      end
    end
    local pas = '#'
    if lvar.copylanepreset then
      pas = ''
    end
    local mstr = 'Store Current Lane Viewset||'..cop..'Clear Preset||'..cop..'Copy Preset|'..pas..'Paste Preset'
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then
        StoreLaneOverrideData(p)
        lupd.update_gfx = true
        
      elseif res == 2 then
        local _, trnm = GetCCLanesTrack()
        if trnm and lvar.lanes_presets[trnm] then
          lvar.lanes_presets[trnm][p] = nil
          if lvar.lanes_presets[trnm].select == p then
            lvar.lanes_presets[trnm].select = nil
          end
          
          lupd.update_gfx = true
        end
        
      elseif res == 3 then
        local _, trnm = GetCCLanesTrack()
        if trnm then
          lvar.copylanepreset = lvar.lanes_presets[trnm][p]
          lupd.update_gfx = true
        end
      
      elseif res == 4 then
        local _, trnm = GetCCLanesTrack()
        if trnm then
          if not lvar.lanes_presets[trnm] then
            lvar.lanes_presets[trnm] = {}
          end
          lvar.lanes_presets[trnm][p] = lvar.copylanepreset
          lupd.update_gfx = true
        end
      end
    end    
  
  end
  
  function LanesOvMenu()
  
    local mstr = 'Save||Clear||Copy Preset'
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then
        StoreLaneOverrideData()
        lupd.update_gfx = true
      elseif res == 2 then
        local track, trnm = GetCCLanesTrack()
        if track then
          lvar.lanes_ov_tab[trnm] = nil
          if lvar.lanes_presets[trnm] then
            lvar.lanes_presets[trnm].select = nil
          end
          lupd.update_gfx = true
        end
      elseif res == 3 then
        --copy preset
        local track, trnm = GetCCLanesTrack()
        if track then
          lvar.copylanepreset = lvar.lanes_ov_tab[trnm].all
        end        
      end
    end    
    
  end
  
  function LanesMenu()
  
    local cc_t1 = ''
    if lvar.midieditor_cclanes == true then
      cc_t1 = '!'
    end
    local cc_a1,cc_a2,cc_a3,cc_a4 = '','','',''
    local cc_b1,cc_b2,cc_b3,cc_b4 = '','','',''
    local cc_c1,cc_c2,cc_c3,cc_c4 = '#','#','#','#'
    local cc_vel = ''
    
    local track, trnm = GetCCLanesTrack()
    
    if track then
      if not lvar.lanes_xtra[trnm] then
        lvar.lanes_xtra[trnm] = {}
      end
      
      if lvar.lanes_xtra.velbottom then
        cc_vel = '!'
      end
      
      if lvar.lanes_xtra[trnm][1] and lvar.lanes_xtra[trnm][1].tabidx then
        cc_a1 = ' ['..lvar.cclanes[lvar.lanes_xtra[trnm][1].tabidx].txt..']'
        cc_c1 = ''
        if lvar.lanes_xtra[trnm][1].bottom then
          cc_b1 = '!'
        end
      end
      if lvar.lanes_xtra[trnm][2] and lvar.lanes_xtra[trnm][2].tabidx then
        cc_a2 = ' ['..lvar.cclanes[lvar.lanes_xtra[trnm][2].tabidx].txt..']'
        cc_c2 = ''
        if lvar.lanes_xtra[trnm][2].bottom then
          cc_b2 = '!'
        end
      end
      if lvar.lanes_xtra[trnm][3] and lvar.lanes_xtra[trnm][3].tabidx then
        cc_a3 = ' ['..lvar.cclanes[lvar.lanes_xtra[trnm][3].tabidx].txt..']'
        cc_c3 = ''
        if lvar.lanes_xtra[trnm][3].bottom then
          cc_b3 = '!'
        end
      end
      if lvar.lanes_xtra[trnm][4] and lvar.lanes_xtra[trnm][4].tabidx then
        cc_a4 = ' ['..lvar.cclanes[lvar.lanes_xtra[trnm][4].tabidx].txt..']'
        cc_c4 = ''
        if lvar.lanes_xtra[trnm][4].bottom then
          cc_b4 = '!'
        end
      end
    end
    local cls = '#'
    if lvar.copylanesettings then
      cls = ''
    end
    local cc = GetCCMenuString()
    local mstr = cc_t1..'Enable Auto Lane Update||Max Dynamic CC Lanes ['..string.format('%i',lvar.midieditor_cclanes_max)..
                  ']|CC Lane Height ['..string.format('%i',lvar.midieditor_cclanes_h)..
                  ']||>Velocity Lane|<'..cc_vel..'Locate Under Dynamic Lanes||>Fixed Lane 1'..cc_a1..'|'..cc_c1..'Clear||'..cc_c1..cc_b1..'Locate Under Dynamic Lanes|'..cc..
                  '|>Fixed Lane 2'..cc_a2..'|'..cc_c2..'Clear||'..cc_c2..cc_b2..'Locate Under Dynamic Lanes|'..cc..
                  '|>Fixed Lane 3'..cc_a3..'|'..cc_c3..'Clear||'..cc_c3..cc_b3..'Locate Under Dynamic Lanes|'..cc..
                  '|>Fixed Lane 4'..cc_a4..'|'..cc_c4..'Clear||'..cc_c4..cc_b4..'Locate Under Dynamic Lanes|'..cc..
                  '||Copy Fixed Lane Settings|'..cls..'Paste Fixed Lane Settings'
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
    
      if res == 1 then
              
        lvar.midieditor_cclanes = not lvar.midieditor_cclanes
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
        lupd.update_gfx = true
               
      elseif res == 2 then
        
        local ret, num = reaper.GetUserInputs('CC Lanes',1,'Max number of dynamic CC lanes:','')
        if ret and tonumber(num) then
          lvar.midieditor_cclanes_max = tonumber(num)
          if lvar.midieditor_cclanes == true then
            lvar.update_midieditor_cclanes = true
          end
        end

      elseif res == 3 then

        local ret, num = reaper.GetUserInputs('CC Lanes',1,'Enter lane height:','')
        if ret and tonumber(num) then
          lvar.midieditor_cclanes_h = tonumber(num)
          if lvar.midieditor_cclanes == true then
            lvar.update_midieditor_cclanes = true
          end
        end

      elseif res == 4 then
        lvar.lanes_xtra.velbottom = not (lvar.lanes_xtra.velbottom or false)
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
        
      elseif res == 5 then        
        lvar.lanes_xtra[trnm][1] = {}
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
        
      elseif res == 6 then
        lvar.lanes_xtra[trnm][1].bottom = not lvar.lanes_xtra[trnm][1].bottom
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
        
      elseif res >= 7 and res < 168 then
        --Fixed slot 1
        lvar.lanes_xtra[trnm][1] = {tabidx = res-6, show = true, bottom = false}        
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end

      elseif res == 168 then
        lvar.lanes_xtra[trnm][2] = {}
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end

      elseif res == 169 then
        lvar.lanes_xtra[trnm][2].bottom = not lvar.lanes_xtra[trnm][2].bottom
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end

      elseif res >= 170 and res < 331 then
        --Fixed slot 2
        lvar.lanes_xtra[trnm][2] = {tabidx = res-169, show = true, bottom = false}        
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end

      elseif res == 331 then
        lvar.lanes_xtra[trnm][3] = {}
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
      elseif res == 332 then
        lvar.lanes_xtra[trnm][3].bottom = not lvar.lanes_xtra[trnm][3].bottom
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end

      elseif res >= 333 and res < 494 then
        --Fixed slot 3
        lvar.lanes_xtra[trnm][3] = {tabidx = res-332, show = true, bottom = false}        
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end

      elseif res == 494 then
        lvar.lanes_xtra[trnm][4] = {}
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end
      elseif res == 495 then
        lvar.lanes_xtra[trnm][4].bottom = not lvar.lanes_xtra[trnm][4].bottom
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end

      elseif res >= 496 and res < 657 then
        --Fixed slot 4
        lvar.lanes_xtra[trnm][4] = {tabidx = res-495, show = true, bottom = false}        
        if lvar.midieditor_cclanes == true then
          lvar.update_midieditor_cclanes = true
        end

      elseif res == 657 then
        --copy
        lvar.copylanesettings = table.copy(lvar.lanes_xtra[trnm])
        
      elseif res == 658 then
        --paste
        lvar.lanes_xtra[trnm] = table.copy(lvar.copylanesettings)
        
      end
    
    end
    
  end
  
  function CheckLayers(tmp)
    if tmp.layer then
      for l = 1, lvar.overtmp_cnt do
        if tmp.layer[l] then
          local pfnd = false
          for a,b in pairs(tmp.layer[l].pos) do
            pfnd = true
            break
          end
          if not pfnd then
            tmp.layer[l] = nil
            lupd.update_gfx = true
          end
        end 
      end
    end
  end
  
  function ClearLayer(layer)
    if template.layer and template.layer[layer] then
      template.layer[layer] = nil
      lvar.save_highlight = true
      if layer == lvar.overtemplate then
        lvar.overtemplate_active = false
        TemplateChanged()
      end
      lupd.update_gfx = true
    end
  end

  function LayerBtnMenu()
  
    local layer = lvar.overtemplate
    local ren = '#'
    if template.layer and template.layer[layer] then
      ren = ''
    end
    
    local cop = '#'
    if lvar.copyalllayers then
      cop = ''
    end
    local mstr = 'Copy all layers|'..cop..'Paste all layers||Clear all layers||'..ren..'Rename selected layer'
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then
        if template.layer then
          lvar.copyalllayers = table.copy(template.layer)
        end
        
      elseif res == 2 then        
        if lvar.copyalllayers then
          template.layer = table.copy(lvar.copyalllayers)
          lvar.save_highlight = true
          TemplateChanged()
          lupd.update_gfx = true
        end

      elseif res == 3 then
        template.layer = nil
        lvar.save_highlight = true
        lvar.overtemplate_active = false
        TemplateChanged()
        lupd.update_gfx = true
               
      elseif res == 4 then

        if template.layer[layer] then
          RenameSelectedLayer(layer)
        end

      end
    end        
  end
  
  function RenameSelectedLayer(layer)
    
    local ret, name = reaper.GetUserInputs('Rename Layer',1,'Enter name:,extrawidth=150',template.layer[layer].name or '')
    if ret then
      if (name or '') ~= '' then
        template.layer[layer].name = name
      else
        template.layer[layer].name = nil
      end
      lvar.save_highlight = true
      lupd.update_gfx = true      
    end
  end
  
  function LayerMenu(layer)
  
    local cop = '#'
    if lvar.copytemplate then
      cop = ''
    end
  
    local mstr = 'Copy layer|'..cop..'Paste layer||Clear'
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then
        lvar.copytemplate2 = nil        
        lvar.copytemplate = {dirty = {},
                             pos = {},
                             sft = {},
                             eft = {}}
        if template.layer and template.layer[layer] then
          lvar.copytemplate.pos = table.copy(template.layer[layer].pos)
          lvar.copytemplate.name = template.layer[layer].name
        end
        
      elseif res == 2 then        
        if lvar.copytemplate then
          if not template.layer then
            template.layer = {}
          end
          if not template.layer[layer] then
            template.layer[layer] = {dirty = {},
                                     pos = {},
                                     sft = {},
                                     eft = {}}
          end
          template.layer[layer] = table.copy(lvar.copytemplate)
          lvar.save_highlight = true
          TemplateChanged()
          lupd.update_gfx = true
        end
        
      elseif res == 3 then
        ClearLayer(layer)        
      end
    end    
  end
  
  function AutoEnvMenu()
  
    local m0, m1, m2, m3, m4, m5 = '','','','','',''
    if lvar.autoenv_mode == 0 then
      m0 = '!'
    elseif lvar.autoenv_mode == 1 then 
      m1 = '!'
    elseif lvar.autoenv_mode == 2 then 
      m2 = '!'
    elseif lvar.autoenv_mode == 3 then 
      m3 = '!'
    elseif lvar.autoenv_mode == 4 then 
      m4 = '!'
    elseif lvar.autoenv_mode == 5 then 
      m5 = '!'
    end
    
    local slip = '#'
    if lvar.chanstrips.count > 0 then
      slip = ''
      if lvar.autoenv_assslip then
        slip = '!'
      end
    end
    
    local spr = ''
    if lvar.env_spread == 1 then
      spr = '!'    
    end
    local sprl
    if lvar.env_spread_limit == 0 then
      sprl = 'Off'
    else
      sprl = string.format('%i',lvar.env_spread_limit)
    end
    local minth, maxth = string.format('%i',lvar.env_mintrackheight), string.format('%i',lvar.env_maxtrackheight)
    if lvar.env_mintrackheight == 0 then
      minth = 'Off'
    end
    if lvar.env_maxtrackheight == 0 then
      maxth = 'Off'
    end
    local at, am = '', ''
    if lvar.env_tralign == 1 then
      at = '!'
    elseif lvar.env_tralign == 2 then
      am = '!'
    end
    
    local mode_offset = 4
    local mstr = 'Auto show envelopes: '..string.format('%i',lvar.env_autoshow_cnt)
                  ..'||Default lane height ('..string.format('%i',lvar.env_laneheight)..')'
                  ..'|Max lane height ('..string.format('%i',lvar.env_maxheight)..')'
                  ..'||Min track height ('..minth..')'
                  ..'|Max track height ('..maxth..')'
                  ..'||'..m0..'Default mode: Current View + Assigned Lanes|'..m1
                  ..'Mode 1: Assigned Lanes Only|'..m2
                  ..'Mode 2: Assigned Lanes + All Used Lanes|'..m3
                  ..'Mode 3: Current View + Touched Lanes||'..slip..'Shift automatable assignments'
                  ..'||'..spr..'Spread Envelope Mode|Spread Limit ('..sprl..')'
                  ..'||'..at..'Align track to top (when possible)|'..am..'Align track to middle (when possible)'
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
      if res == 1 then
        local ret, ve = reaper.GetUserInputs('Auto Envelopes',1,'Set number of visible envelopes:',tostring(lvar.env_autoshow_cnt))
        if ret == true and tonumber(ve) then
          lvar.env_autoshow_cnt = tonumber(ve)
        end
      elseif res == 2 then
        local ret, num = reaper.GetUserInputs('Envelope Lanes',1,'Enter lane height:','')
        if ret and tonumber(num) then
          lvar.env_laneheight = tonumber(num)
          if lvar.autoenv == true then
            lvar.update_envelopes = true
          end
        end
      elseif res == 3 then
        local ret, num = reaper.GetUserInputs('Envelope Lanes',1,'Enter maximum lane height:','')
        if ret and tonumber(num) then
          lvar.env_maxheight = tonumber(num)
          if lvar.autoenv == true then
            lvar.update_envelopes = true
          end
        end
      elseif res == 4 then
        local ret, num = reaper.GetUserInputs('Envelope Lanes',1,'Enter min track height (0 = off):','')
        if ret and tonumber(num) then
          lvar.env_mintrackheight = tonumber(num)
          if lvar.autoenv == true then
            lvar.update_envelopes = true
          end
        end
      
      elseif res == 5 then
        local ret, num = reaper.GetUserInputs('Envelope Lanes',1,'Enter max track height (0 = off):','')
        if ret and tonumber(num) then
          lvar.env_maxtrackheight = tonumber(num)
          if lvar.autoenv == true then
            lvar.update_envelopes = true
          end
        end
        
      elseif res >= 2+mode_offset and res <= 5+mode_offset then
        lvar.autoenv_mode = res-2-mode_offset
      elseif res == 6+mode_offset then
        lvar.autoenv_assslip = not lvar.autoenv_assslip
      elseif res == 7+mode_offset then
        lvar.env_spread = 1-lvar.env_spread
      elseif res == 8+mode_offset then
        local ret, lim = reaper.GetUserInputs('Envelope Spread Limit',1,'Max envelopes (0 = Off):',tostring(string.format('%i',lvar.env_spread_limit)))
        if ret == true and tonumber(lim) then
          lvar.env_spread_limit = tonumber(lim)
        end
      elseif res == 9+mode_offset then
        if lvar.env_tralign == 1 then
          lvar.env_tralign = 0
        else
          lvar.env_tralign = 1
        end
      elseif res == 10+mode_offset then
        if lvar.env_tralign == 2 then
          lvar.env_tralign = 0
        else
          lvar.env_tralign = 2
        end
      end
    end    
  
  end
  
  function SettingsMenu()
  
    local tick = ''
    if settings.floatfxgui ~= 0 then
      tick = '!'
    end
    --[[local skcc = ''
    if settings.skccdirect == true then
      skcc = '!'
    end]]
    --[[local skrr = ''
    if settings.rrmode == true then
      skrr = '!'
    end
    ccft = ''
    if settings.ccsend == true then
      ccft = '!'
    end
    
    local mapstab, mapsstr, mapcnt = GetCtlMaps(true)]]
    
    local m1tick = ''
    local m2tick = ''
    local m3tick = ''
    if lvar.mode == 1 then
      m1tick = '!'
    elseif lvar.mode == 2 then
      m2tick = '!'
    elseif lvar.mode == 3 then
      m3tick = '!'
    end
    
    local m3 = ''
    if lvar.mode ~= 3 then
      m3 = '#'
    end
    
    local ccdef = '#'
    if lvar.mode == 3 then
      ccdef = ''
    end
    local cm = ''
    if lvar.display_mini then
      cm = '!'
    end
    
    local sttick = ''
    if lvar.ccstamp_active == 1 then
      sttick = '!'
    end
  
    local af, af2 = '', ''
    if lvar.js_avail == true then
      if lvar.automodeswitch == 1 then
        af = '!'
      end
    else
      af = '#'
    end
    if lvar.automodeswitch == 2 then
      af2 = '!'
    end
    local gtk = ''
    if #lvar.groupidx == 0 then
      gtk = '#'
    end
    local rfptpcc = ''
    if lvar.resetfaderpostoprintccvalue == true then
      rfptpcc = '!'
    end
    local las = ''
    if lvar.loadalltemplates == true then
      las = '!'
    end
    local tom = ''
    if lvar.trackoffsetfollowsselected then
      tom = '!'
    end
    
    local dl = ''
    if lvar.defaulttemplate_active then
      dl = '!'
    end
    
    --[[local fn = paths.deftemplate_path..lvar.defaulttemplate_fn
    local gm = ''
    if not reaper.file_exists(fn) and then
      
    end]]
    local fsm = ''
    if lvar.selectfadermode ~= 0 then
      fsm = '!'
    end
    
    local tm_tcp, tm_mcp = '', ''
    if lvar.trackoffset_visibleonly == 1 then
      tm_tcp = '!'
    elseif lvar.trackoffset_visibleonly == 2 then
      tm_mcp = '!'
    end
    
    local stp = ''
    if lvar.stripperlink then
      stp = '!'
    end
    local dly = ''
    if lvar.sk2data_setdata_delayaffectsfeedback then
      dly = '!'
    end
    local aot = ''
    if lvar.propaot then
      aot = '!'
    end
    local rm = ''
    if not lvar.remap.data then
      rm = '#'
    elseif lvar.remap_active then
      rm = '!'
    end
    local dp = ''
    if lvar.fdata_removedups == 1 then
      dp = '!'
    end
    
    local cols = '|Save Color Preset|>Load Color Preset|Default|'
    local colpretab = {}
    local cpidx = 0
    local cp = reaper.EnumerateFiles(paths.colorpreset_path, cpidx)
    if cp then
      while cp do
        local cp2 = cp
        colpretab[cpidx] = cp
        cpidx = cpidx + 1
        cp = reaper.EnumerateFiles(paths.colorpreset_path, cpidx)
        local cpx = ''
        if not cp then
          cpx = '<'
        end
        cols = cols .. '|' .. cpx .. cp2
      end
      cpidx = cpidx + 1
    else
      cols = '|Save Color Preset|>Load Color Preset|Default||#<No Presets'
      cpidx = 2
    end
    
    local mir = ''
    local m12, m34, m1A = '', '', ''
    if lvar.mirrordevices then
      mir = '!'
      if lvar.mirrordev_1toAll then
        m1A = '!'
      else
        if lvar.mirrordev_1to2 then
          m12 = '!'
        end
        if lvar.mirrordev_3to4 then
          m34 = '!'
        end
      end
    end
    
    local ct = ''
    if lvar.checktracks then
      ct = '!'
    end
    
    local vs = ''
    if lvar.virtualss_active then
      vs = '!'
    end
    local mstr = m1tick..'Plugin Mode|'..m2tick..'Instance Mode|'..m3tick..'Track Mode||'..cm..'Compact Mode||Customize Colors'..cols..'||'..
                 tick..'#Float FX GUI||#Float time ('.. settings.floatfxgui..' secs)||'..sttick..
                 'Print Default CC Values to New Items|'..rfptpcc..'Reset Fader Position to Print CC Value||'..af..'Auto Mode Switch (Experimental)|'..af2..'Use Stripper DM Touched (Experimental)||'..gtk..'Group Options'..
                 '||'..las..'Load All Maps At Startup||'..tom..'Track Mode: offset follows selected track'..
                 '|'..tm_tcp..'Track Mode: Ignore hidden tracks in TCP'..
                 '|'..tm_mcp..'Track Mode: Ignore hidden tracks in MCP'..
                 '||'..m3..'Set Current Track Map As Default|Set Current Global Map As Default|'..dl..'Use Default Map||'..fsm..
                 'Use Alternate Fader Select Mode|'..aot..'Properties Window On Top||Refresh All Device Handshakes'..
                 '||>Advanced Options|'..stp..'Send Data To Stripper|Track Selection Delay: '.. lvar.sk2data_setdata_delaytime ..'s'..
                 '|'..dly..'Delay affects fader feedback|Stripper Data: Send Slots Per Defer Cycle: '..string.format('%i',lvar.sk2setdata_num)..
                 '||'..dp..'Prevent duplicate CCs||'..ct..'Monitor Tracks (Visibility and Name)|<Monitor Tracks Per Defer Cycle: '..lvar.checktracks_rrobin..
                 '||'..mir..'>Mirror controller devices|'..m12..'Mirror device 1 to device 2|'..m34..'Mirror device 3 to device 4|<'..m1A..'Mirror device 1 to devices 2, 3 && 4'..
                 '||'..rm..'Enable Remapped Controls||Reset Devices'
                 
                 --..ccstr
    mstr = mstr ..'||Open Manual (PDF)||'..vs..'Show Virtual Scribble Strips||#Version: '..lvar.version
    
    --'..skrr..'Retro record mode'
    --              ..'||'..ccft..'Send CCs to selected track|'..mapsstr..'||Create sends for selected tracks|Create all sends||Save CC map as default'
    
    gfx.x = mouse.mx
    gfx.y = mouse.my
    local res = gfx.showmenu(mstr)
    if res > 0 then
    --DBG(res)
      if res == 1 then
        
        SetMode(1)
        
      elseif res == 2 then
        
        SetMode(2)
        
      elseif res == 3 then

        SetMode(3)

      elseif res == 4 then

        lvar.display_mini = not lvar.display_mini
        obj = GetObjects()
        lupd.update_gfx = true

      elseif res == 5 then
        lvar.livemode = 2
        lupd.update_dialog = true

      elseif res == 6 then
        --Save Color Preset
        local ret, val = reaper.GetUserInputs('Save Color Preset',1,'Preset Name:,extrawidth=100','')
        if ret then
          local savefn = paths.colorpreset_path..val
          local saveflag = 6
          if reaper.file_exists(savefn) then
            saveflag = reaper.MB('File exists - overwrite?','Save Preset',4)
          end
          if saveflag == 6 then
            SaveColors(savefn)
          end
        end
        
      elseif res >= 7 and res <= 7 + cpidx then
        --Load Color Preset
        local idx = res - 8
        if colpretab[idx] then
          local sfn = paths.colorpreset_path..colpretab[idx]
          local dfn = paths.resource_path..'colors.txt'
          copyfile(sfn, dfn)
          LoadColors()
          lupd.update_gfx = true
        else
          local dfn = paths.resource_path..'colors.txt'
          os.remove(dfn)
          colours = InitColours()
          lupd.update_gfx = true
        end
        
      elseif res == 7 + cpidx then
        if settings.floatfxgui == 0 then
          settings.floatfxgui = lvar.deffloattime
        else
          settings.floatfxgui = 0
        end
        
      elseif res == 8 + cpidx then
        local ret, tm = reaper.GetUserInputs('Set float time (secs)',1,'Time (secs):',tostring(settings.floatfxgui))
        if ret == true then
          settings.floatfxgui = tonumber(tm)
          lvar.deffloattime = settings.floatfxgui
        end

      elseif res == 9 + cpidx then
        lvar.ccstamp_active = 1-lvar.ccstamp_active
        SetUpCCStampData()
        lupd.update_gfx = true
      
      elseif res == 10 + cpidx then
        lvar.resetfaderpostoprintccvalue = not lvar.resetfaderpostoprintccvalue
        if lvar.autochase then
          TriggerCCChase()
        end
        
      elseif res == 11 + cpidx then
      
        if lvar.automodeswitch ~= 1 then
          lvar.automodeswitch = 1
        else
          lvar.automodeswitch = 0
        end

      elseif res == 12 + cpidx then
      
        if lvar.automodeswitch ~= 2 then
          lvar.automodeswitch = 2
        else
          lvar.automodeswitch = 0
        end
        
      elseif res == 13 + cpidx then
        lvar.livemode = 3
        lupd.update_dialog = true

      elseif res == 14 + cpidx then
        lvar.loadalltemplates = not lvar.loadalltemplates
        if lvar.loadalltemplates == true then
          LoadAllTemplates()
        else
          lvar.templates = nil
        end

      elseif res == 15 + cpidx then
        lvar.trackoffsetfollowsselected = not lvar.trackoffsetfollowsselected
        
        --lvar.readparams = nil
        if lvar.trackoffsetfollowsselected then
          local track = reaper.GetSelectedTrack2(0,0,true)
          if track then
            trn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
            if trn then --and (not found[trn] or trn == -1) and recmode == 0 then
              --if trn == -1 then trn = 0 end
              if lvar.trackoffsetfollowsselected then
                lvar.track_ofs = math.max(trn,0)
              end
            end
          end
        end
        
        if lvar.trackoffset_visibleonly > 0 then
          lvar.tracks_vis = Internal_VisibleTracks()
        end
        TemplateChanged()

      elseif res == 16 + cpidx then
        if lvar.trackoffset_visibleonly ~= 1 then
          lvar.trackoffset_visibleonly = 1
        else
          lvar.trackoffset_visibleonly = 0
        end
        if lvar.trackoffset_visibleonly > 0 then
          lvar.tracks_vis = Internal_VisibleTracks()
        end
      
      elseif res == 17 + cpidx then
        if lvar.trackoffset_visibleonly ~= 2 then
          lvar.trackoffset_visibleonly = 2
        else
          lvar.trackoffset_visibleonly = 0
        end
        if lvar.trackoffset_visibleonly > 0 then
          lvar.tracks_vis = Internal_VisibleTracks()
        end
        TemplateChanged()
        
      elseif res == 18 + cpidx then
      
        lvar.defaulttemplate_type = 0
        lvar.defaulttemplate_active = true
        
        local fn = paths.deftemplate_path..lvar.defaulttemplate_fn
        SaveFXParamTemplate(FFX, template, fn, nil, false)

        template = LoadFXParamTemplate(FFX)
        TemplateChanged()
        lupd.update_gfx = true
        
      elseif res == 19 + cpidx then
      
        lvar.defaulttemplate_type = 0
        lvar.defaulttemplate_active = true
        
        local fn = paths.deftemplate_path..lvar.defaulttemplate_fn
        SaveFXParamTemplate(FFX, globtemplate, fn, nil, false)

        template = LoadFXParamTemplate(FFX)
        TemplateChanged()
        lupd.update_gfx = true
      
      elseif res == 20 + cpidx then
        
        lvar.defaulttemplate_active = not lvar.defaulttemplate_active
        template = LoadFXParamTemplate(FFX)
        TemplateChanged()
        lupd.update_gfx = true
      elseif res == 21 + cpidx then
        lvar.selectfadermode = 1 - lvar.selectfadermode
        reaper.SetExtState(SCRIPT,'selectfadermode',nz(lvar.selectfadermode,0),true)
      elseif res == 22 + cpidx then
        lvar.propaot = not lvar.propaot
        reaper.SetExtState(PUSCRIPT,'aot',tostring(lvar.propaot),true)
        
      elseif res == 23 + cpidx then
        ResendHandshake()
      elseif res == 24 + cpidx then
        lvar.stripperlink = not lvar.stripperlink
        
      elseif res == 25 + cpidx then
        local retval, val = reaper.GetUserInputs('Track selection delay time', 1, 'Delay time (s):', lvar.sk2data_setdata_delaytime) 
        if retval and tonumber(val) then
          lvar.sk2data_setdata_delaytime = F_limit(tonumber(val),0,1)
        end

      elseif res == 26 + cpidx then
        lvar.sk2data_setdata_delayaffectsfeedback = not lvar.sk2data_setdata_delayaffectsfeedback
      
      elseif res == 27 + cpidx then
        local retval, val = reaper.GetUserInputs('Stripper send - slots per defer cycle', 1, 'Slots:', lvar.sk2setdata_num) 
        if retval and tonumber(val) then
          lvar.sk2setdata_num = math.floor(math.max(tonumber(val),8))
        end
        
      elseif res == 28 + cpidx then
        lvar.fdata_removedups = 1-lvar.fdata_removedups
        reaper.gmem_write(lvar.gm_cc.fdata_removedups, lvar.fdata_removedups)
        
      elseif res == 29 + cpidx then
        if lvar.checktracks then
          lvar.checktracks = nil
        else
          lvar.checktracks = 0
        end
      
      elseif res == 30 + cpidx then
      
        local ret, num = reaper.GetUserInputs('Tracks per cycle',1,'Enter number of tracks to monitor per defer cycle (8-100):',lvar.checktracks_rrobin)
        if ret and tonumber(num) then
          lvar.checktracks_rrobin = F_limit(tonumber(math.floor(num)),8,100)
        end
      
      elseif res == 31 + cpidx then
      
        lvar.mirrordev_1to2 = not lvar.mirrordev_1to2
        if lvar.mirrordev_1to2 then
          lvar.mirrordevices = true
          lvar.mirrordev_1toAll = false
        else
          if not lvar.mirrordev_3to4 then
            lvar.mirrordevices = false
          end
        end
        if not mididevices then
          mididevices = GetMIDIDevices()
        end
        CreateSetUp()
        lvar.initstage = 1
        lupd.update_gfx = true
        --TemplateChanged()

      elseif res == 32 + cpidx then
      
        lvar.mirrordev_3to4 = not lvar.mirrordev_3to4
        if lvar.mirrordev_3to4 then
          lvar.mirrordevices = true
          lvar.mirrordev_1toAll = false
        else
          if not lvar.mirrordev_1to2 then
            lvar.mirrordevices = false
          end
        end
        if not mididevices then
          mididevices = GetMIDIDevices()
        end
        CreateSetUp()
        lvar.initstage = 1
        lupd.update_gfx = true
        --TemplateChanged()

      elseif res == 33 + cpidx then
      
        lvar.mirrordev_1toAll = not lvar.mirrordev_1toAll
        if lvar.mirrordev_1toAll then
          lvar.mirrordevices = true
          lvar.mirrordev_1to2 = false
          lvar.mirrordev_3to4 = false
        else
          --if not lvar.mirrordev_1to2 then
          lvar.mirrordevices = false
          --end
        end
        if not mididevices then
          mididevices = GetMIDIDevices()
        end
        CreateSetUp()
        lvar.initstage = 1
        lupd.update_gfx = true
        --TemplateChanged()
      
      elseif res == 34 + cpidx then
        lvar.remap_active = not lvar.remap_active
        RemapCtls(lvar.remap_active)

      elseif res == 35 + cpidx then
        ResetDevices()
      elseif res == 36 + cpidx then
        OpenManual()
      elseif res == 37 + cpidx then
        lvar.virtualss_active = not lvar.virtualss_active
        ShowVSS()
      --end        
      --[[elseif res == 3 then
        settings.skccdirect = not nz(settings.skccdirect,false)
      elseif res < 4+16 then
        SetCCInputData(res-4)
      elseif res < 4+113 then
        SetCCInputData(nil, res-20)]]
      --[[elseif res == 7 then
        settings.rrmode = not nz(settings.rrmode,false)
      elseif res == 8 then
        settings.ccsend = not nz(settings.ccsend,false)
      elseif res >= 9 and res < 9+mapcnt then
        local i = res-9+1
        local fn = paths.ctemplate_path..mapstab[i]..'.'..'skctlmap'
        LoadCtlMap(fn)
      elseif res == 4 then
        lvar.livemode = 1
        lvar.showsetup = true
        lupd.update_gfx = true
      elseif res == 9+mapcnt then
        SetSendsAuto()
      elseif res == 10+mapcnt then
        SetSendsAuto(true)
      elseif res == 11+mapcnt then
        SaveCCMapAsDef()]]
      end
    
    end
    
  end
  
  function SaveSetUp(fn)
  
    local ffn=paths.setups_path..fn..'.sksetup'
    file=io.open(ffn,"w")
    
    local i = 1
    for a, b in pairs(lvar.midiinput_gen) do
      file:write('[indev_'..i..']'..a..'\n')
      i=i+1
    end
    local i = 1
    for a, b in pairs(lvar.midiinput_ctl) do
      file:write('[ctlindev_'..i..']'..a..'\n')
      file:write('[ctlinbus_'..i..']'..b.bus..'\n')
      i=i+1
    end
    local i = 1
    for a, b in pairs(lvar.midioutput_ctl) do
      file:write('[ctloutdev_'..i..']'..a..'\n')
      file:write('[ctloutbus_'..i..']'..b.bus..'\n')
      i=i+1
    end
    for i = 1, 4 do
      if lvar.midimap[i] then
        file:write('[map'..string.format('%i',i)..']'..lvar.midimap[i]..'\n')
      end
    end
    file:write('[fcount]'..lvar.fcount..'\n')
    file:write('[createsends]'..tostring(lvar.createsends)..'\n')
    file:write('[loopback]'..(lvar.midiloopbackdev or '')..'\n')
    
    if lvar.midiinput_filt then
      for a, b in pairs(lvar.midiinput_filt) do
        file:write('['..a..'_f_active]'..tostring(b.active)..'\n')
        file:write('['..a..'_f_all_cc]'..tostring(b.all_cc)..'\n')
        file:write('['..a..'_f_pb]'..tostring(b.pb)..'\n')
        file:write('['..a..'_f_pc]'..tostring(b.pc)..'\n')
        file:write('['..a..'_f_sysx]'..tostring(b.sysx)..'\n')
        file:write('['..a..'_f_at_poly]'..tostring(b.at_poly)..'\n')
        file:write('['..a..'_f_at_chan]'..tostring(b.at_chan)..'\n')
        for i = 0, 127 do
          if b.ccs[i] == 1 then
            file:write('['..a..'_f_cc'..string.format('%i',i)..']1\n')          
          end
        end
      end
      local a = 'GLOBAL FILTER'
      local b = lvar.midiinput_filt[a]
      if b then
        file:write('['..a..'_f_active]'..tostring(b.active)..'\n')
        file:write('['..a..'_f_all_cc]'..tostring(b.all_cc)..'\n')
        file:write('['..a..'_f_pb]'..tostring(b.pb)..'\n')
        file:write('['..a..'_f_pc]'..tostring(b.pc)..'\n')
        file:write('['..a..'_f_sysx]'..tostring(b.sysx)..'\n')
        file:write('['..a..'_f_at_poly]'..tostring(b.at_poly)..'\n')
        file:write('['..a..'_f_at_chan]'..tostring(b.at_chan)..'\n')
        for i = 0, 127 do
          if b.ccs[i] == 1 then
            file:write('['..a..'_f_cc'..string.format('%i',i)..']1\n')          
          end
        end
      end
    end
    
    --save also with project - loopback must be remembered correctly for the project
    reaper.SetProjExtState(0, SCRIPT, 'loopback', (lvar.midiloopbackdev or '[none]'))
    reaper.SetProjExtState(0, SCRIPT, 'createsends', tostring(lvar.createsends))
    
    file:close()
          
  end

  function DefFilter()
    return {active = false,
            all_cc = 0,
            pb = 0,
            pc = 0,
            at_poly = 0,
            at_chan = 0,
            sysx = 0,
            ccs = {}}
  end
  
  function LoadFilter(data, dkey)
  
    if data[dkey..'_f_active'] ~= nil then
      local filttab = {}
      local key = dkey..'_f_'
      filttab.active = tobool(data[key..'active']) or false
      filttab.all_cc = tonumber(data[key..'all_cc']) or 0
      filttab.pb = tonumber(data[key..'pb']) or 0
      filttab.pc = tonumber(data[key..'pc']) or 0
      filttab.sysx = tonumber(data[key..'sysx']) or 0
      filttab.at_poly = tonumber(data[key..'at_poly']) or 0
      filttab.at_chan = tonumber(data[key..'at_chan']) or 0
      filttab.ccs = {}
      for i = 0, 127 do
        filttab.ccs[i] = tonumber(data[key..'cc'..string.format('%i',i)])
      end
      return filttab
    else
      return {active = false,
              all_cc = 0,
              pb = 0,
              pc = 0,
              at_poly = 0,
              at_chan = 0,
              sysx = 0,
              ccs = {}}
    end
  end
  
  function LoadSetUp(fn)

    local ffn=paths.setups_path..fn..'.sksetup'    
    if reaper.file_exists(ffn) then
      data = {}
      for line in io.lines(ffn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          val = string.gsub(val, '[\r]', '') --Remove \r for Mac use
          data[idx] = val
        end
      end  

      lvar.midiinput_filt = {}
      lvar.midiinput_gen = {}
      lvar.midiinput_ctl = {}
      lvar.midioutput_ctl = {}
      lvar.midimap = {}
      lvar.fcount = 32
      
      local devices = GetMIDIDevices()
      
      local d = 1
      local key = 'indev_'..string.format('%i',d)
      while data[key] do
        lvar.midiinput_gen[data[key]] = devices.inidx[data[key]]
        lvar.midiinput_filt[data[key]] = LoadFilter(data, data[key])
        d=d+1
        key = 'indev_'..string.format('%i',d)
      end

      local d = 1
      local key = 'ctlindev_'..string.format('%i',d)
      while data[key] do
        local idx = devices.inidx2[data[key]]
        if devices.input[idx] then
          local key2 = 'ctlinbus_'..string.format('%i',d)
          lvar.midiinput_ctl[data[key]] = {dev = devices.input[idx].dev, bus = data[key2] or 0}
          lvar.midiinput_filt[data[key]] = LoadFilter(data, data[key])
        end
        d=d+1
        key = 'ctlindev_'..string.format('%i',d)
      end

      lvar.midiinput_filt['GLOBAL FILTER'] = LoadFilter(data, 'GLOBAL FILTER')

      local d = 1
      local key = 'ctloutdev_'..string.format('%i',d)
      while data[key] do
        local idx = devices.outidx2[data[key]]
        if devices.output[idx] then
          local key2 = 'ctloutbus_'..string.format('%i',d)        
          lvar.midioutput_ctl[data[key]] = {dev = devices.output[idx].dev, bus = data[key2] or 0}
        end
        d=d+1
        key = 'ctloutdev_'..string.format('%i',d)
      end

      lvar.midimap[1] = data['map1']
      lvar.midimap[2] = data['map2']
      lvar.midimap[3] = data['map3']
      lvar.midimap[4] = data['map4']
      
      lvar.fcount = data['fcount']+lvar.dummyfaders
      lvar.createsends = true --tobool(nz(data['createsends'],true))
      lvar.midiloopbackdev = zn(data['loopback'])
    
      LoadSetUp_Proj()
      
    else
    
      lvar.midiinput_filt = {}
      lvar.midiinput_gen = {}
      lvar.midiinput_ctl = {}
      lvar.midioutput_ctl = {}
      lvar.midimap = {}
      lvar.fcount = 32
      
    end
  end
  
  function LoadSetUp_Proj()
    local ret, proj_lb = reaper.GetProjExtState(0, SCRIPT, 'loopback')
    if ret == 1 then
      if proj_lb == '[none]' then
        lvar.midiloopbackdev = nil
      else
        lvar.midiloopbackdev = proj_lb 
      end
      local ret, proj_cs = reaper.GetProjExtState(0, SCRIPT, 'createsends')
      if ret == 1 then lvar.createsends = tobool(proj_cs) end  
    else
      --Check CC lane for loopback device
      local tr = GetCCTrack()
      if tr then
        local dev = reaper.GetMediaTrackInfo_Value(tr, 'I_MIDIHWOUT')
        if dev ~= -1 then
          dev = dev >> 5
          local present, name = reaper.GetMIDIOutputName(dev, '')
          if name then
            lvar.midiloopbackdev = name
          end
        else
          -- no loopback - assume use sends
          lvar.midiloopbackdev = nil
        end
      end
    end
    LoadProjectCtlTrackInfo()
  end
  
  function SaveSettings()
  
    a,x,y,w,h = gfx.dock(-1,1,1,1,1)
    if gfx1 then
      reaper.SetExtState(SCRIPT,'dock',nz(a,0),true)
      reaper.SetExtState(SCRIPT,'win_x',nz(x,0),true)
      reaper.SetExtState(SCRIPT,'win_y',nz(y,0),true)    
      reaper.SetExtState(SCRIPT,'win_w',nz(gfx1.main_w,400),true)
      reaper.SetExtState(SCRIPT,'win_h',nz(gfx1.main_h,450),true)    
      reaper.SetExtState(SCRIPT,'skccdirect',tostring(nz(settings.skccdirect,false)),true)    
      reaper.SetExtState(SCRIPT,'rrmode',tostring(nz(settings.rrmode,false)),true)    
      reaper.SetExtState(SCRIPT,'groupinputs',tostring(nz(settings.groupinputs,false)),true)    
      --reaper.SetExtState(SCRIPT,'ccsend',tostring(nz(settings.ccsend,false)),true)    
      reaper.SetExtState(SCRIPT,'sort',tostring(nz(settings.sort,false)),true)    
      reaper.SetExtState(SCRIPT,'touchenabled',tostring(nz(lvar.touchenabled,false)),true)    
      
      reaper.SetExtState(SCRIPT,'hidetracks',tostring(nz(settings.hidectltrack,true)),true)    
      reaper.SetExtState(SCRIPT,'liveccfb',tostring(nz(settings.liveccfb,false)),true)
      reaper.SetExtState(SCRIPT,'dv_filter_enabled',tostring(lvar.dv_filter_enabled),true)
      reaper.SetExtState(SCRIPT,'checktracks',tostring(nz(lvar.checktracks,'')),true)
      reaper.SetExtState(SCRIPT,'checktracks_rrobin',tostring(lvar.checktracks_rrobin),true)

      reaper.SetExtState(SCRIPT,'guizoom',tostring(nz(lvar.guizoom,1)),true)
      reaper.SetExtState(SCRIPT,'guizoom2',tostring(nz(lvar.guizoom2,1)),true)
      reaper.SetExtState(SCRIPT,'fontzoom',tostring(nz(lvar.fontzoom,1)),true)
      reaper.SetExtState(SCRIPT,'fontzoom2',tostring(nz(lvar.fontzoom2,1)),true)
      reaper.SetExtState(SCRIPT,'fontoffset',tostring(nz(lvar.fontoffset,0)),true)
          
      reaper.SetExtState(SCRIPT,'mode',tostring(nz(lvar.mode,true)),true)
      reaper.SetExtState(SCRIPT,'fbcconseek',tostring(nz(lvar.fbcconseek,true)),true)
      reaper.SetExtState(SCRIPT,'disableSSplayback',tostring(nz(lvar.disableSSplayback,false)),true)
      reaper.SetExtState(SCRIPT,'autochase',tostring(nz(lvar.autochase,true)),true)
      reaper.SetExtState(SCRIPT,'maxchasetime',tostring(nz(lvar.maxchasetime,500)),true)
      reaper.SetExtState(SCRIPT,'showglobalmap',tostring(nz(lvar.showglobalmap,true)),true)
      reaper.SetExtState(SCRIPT,'currentglobalmap',tostring(nz(lvar.currentglobalmap,true)),true)            

      reaper.SetExtState(SCRIPT,'mirrordevices',tostring(nz(lvar.mirrordevices,false)),true)
      reaper.SetExtState(SCRIPT,'mirrordev12',tostring(nz(lvar.mirrordev_1to2,false)),true)
      reaper.SetExtState(SCRIPT,'mirrordev34',tostring(nz(lvar.mirrordev_3to4,false)),true)
      reaper.SetExtState(SCRIPT,'mirrordev1All',tostring(nz(lvar.mirrordev_1toAll,false)),true)
      
      reaper.SetExtState(SCRIPT,'fdata_sendcconrel',tostring(nz(lvar.fdata_sendcconrel,0)),true)
      reaper.SetExtState(SCRIPT,'fdata_removedups',tostring(nz(lvar.fdata_removedups,1)),true)
      
      reaper.SetExtState(SCRIPT,'compactmode',tostring(nz(lvar.display_mini,false)),true)
      reaper.SetExtState(SCRIPT,'includetracknameinss',tostring(nz(settings.includetracknameinss,true)),true)    
      reaper.SetExtState(SCRIPT,'timecodedisplayformat',tostring(nz(lvar.timecodedisplayformat,0)),true)    
      reaper.SetExtState(SCRIPT,'ccstamp_active',tostring(nz(lvar.ccstamp_active,0)),true)    
      reaper.SetExtState(SCRIPT,'automodeswitch',tostring(nz(lvar.automodeswitch,0)),true)    
      reaper.SetExtState(SCRIPT,'displayoverlay',tostring(nz(lvar.display_overlay_active,false)),true)    
      reaper.SetExtState(SCRIPT,'displayoverlay_io',tostring(nz(lvar.display_overlay_inputonly,false)),true)    
      reaper.SetExtState(SCRIPT,'resetfaderpostoprintccvalue',tostring(nz(lvar.resetfaderpostoprintccvalue,false)),true)    
      reaper.SetExtState(SCRIPT,'dummyfaders',tostring(nz(lvar.dummyfaders,0)),true)    
      reaper.SetExtState(SCRIPT,'autoglob_plug',tostring(nz(lvar.autoglob_plug,'')),true)    
      reaper.SetExtState(SCRIPT,'autoglob_track',tostring(nz(lvar.autoglob_track,'')),true)          
      reaper.SetExtState(SCRIPT,'loadalltemplates',tostring(nz(lvar.loadalltemplates,false)),true)
      reaper.SetExtState(SCRIPT,'restorelastfilter',tostring(nz(lvar.restorelastfilter,false)),true)          
      reaper.SetExtState(SCRIPT,'trackoffsetfollowsselected',tostring(nz(lvar.trackoffsetfollowsselected,false)),true)                
      reaper.SetExtState(SCRIPT,'trackoffset_visibleonly',tostring(nz(lvar.trackoffset_visibleonly,0)),true)                
      reaper.SetExtState(SCRIPT,'trackselectmode',tostring(nz(lvar.trackselectmode,false)),true)

      reaper.SetExtState(SCRIPT,'ss_color_override_enabled',tostring(nz(lvar.ss_color_override_enabled,false)),true)                
      reaper.SetExtState(SCRIPT,'ss_color_override_color',tostring(nz(lvar.ss_color_override_color,1)),true)                
      reaper.SetExtState(SCRIPT,'ss_color_override_nonautomatable',tostring(nz(lvar.ss_color_override_nonautomatable,false)),true)                
      reaper.SetExtState(SCRIPT,'ss_color_override_nonautomatable_color',tostring(nz(lvar.ss_color_override_nonautomatable_color,0)),true)                

      reaper.SetExtState(SCRIPT,'ss_alwaysshowdispval',tostring(nz(lvar.ss_alwaysshowdispval,false)),true)
      
      reaper.SetExtState(SCRIPT,'rec_mapactiveenvstofaders2',tostring(nz(lvar.rec_mapactiveenvstofaders2,false)),true)                
      reaper.SetExtState(SCRIPT,'rec_automap_solo',tostring(nz(lvar.rec_automap_solo,false)),true)                
      reaper.SetExtState(SCRIPT,'rec_automap_device',tostring(lvar.rec_automap_device or -1),true)                
      reaper.SetExtState(SCRIPT,'rec_automap_color_vol',tostring(lvar.rec_automap_color_vol or 2),true)                
      reaper.SetExtState(SCRIPT,'rec_automap_color_pan',tostring(lvar.rec_automap_color_pan or 3),true)                
      reaper.SetExtState(SCRIPT,'rec_automap_color_mute',tostring(lvar.rec_automap_color_mute or 1),true)                
      reaper.SetExtState(SCRIPT,'rec_automap_color_plug',tostring(lvar.rec_automap_color_plug or 4),true)                
      
      reaper.SetExtState(SCRIPT,'virtualss_active',tostring(lvar.virtualss_active),true)                
      
      if lvar.restorelastfilter then
        reaper.SetExtState(SCRIPT,'defaultfilter',tostring(nz(lvar.userfilter.select,'1')),true)
        if lvar.filtidx then          
          reaper.SetExtState(SCRIPT,'defaultfilter_on',tostring(true),true)                    
        else
          reaper.SetExtState(SCRIPT,'defaultfilter_on',tostring(false),true)                    
        end
      else          
        reaper.SetExtState(SCRIPT,'defaultfilter',tostring(nz(lvar.userfilter.select,'1')),true)          
        reaper.SetExtState(SCRIPT,'defaultfilter_on',tostring(false),true)                    
      end
      
      reaper.SetExtState(SCRIPT,'ME_cclanes',tostring(nz(lvar.midieditor_cclanes,'')),true)          
      reaper.SetExtState(SCRIPT,'ME_lanepresetenable',tostring(nz(lvar.lanes_ov_enable,'')),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanesmax',tostring(nz(lvar.midieditor_cclanes_max,'')),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanesh',tostring(nz(lvar.midieditor_cclanes_h,'')),true)          
      
      reaper.SetExtState(SCRIPT,'env_autoshow_cnt',tostring(lvar.env_autoshow_cnt),true)
      reaper.SetExtState(SCRIPT,'autoenv',tostring(lvar.autoenv),true)
      reaper.SetExtState(SCRIPT,'autoenv_mode',tostring(lvar.autoenv_mode),true)
      reaper.SetExtState(SCRIPT,'autoenv_assslip',tostring(lvar.autoenv_assslip),true)
      reaper.SetExtState(SCRIPT,'env_laneheight',tostring(lvar.env_laneheight),true)
      reaper.SetExtState(SCRIPT,'env_spread',tostring(lvar.env_spread),true)
      reaper.SetExtState(SCRIPT,'env_spread_limit',tostring(lvar.env_spread_limit),true)
      reaper.SetExtState(SCRIPT,'env_maxheight',tostring(lvar.env_maxheight),true)
      reaper.SetExtState(SCRIPT,'env_tralign',tostring(lvar.env_tralign),true)

      reaper.SetExtState(SCRIPT,'fxlearnmode',lvar.fxlearnmode,true)
      
      reaper.SetExtState(SCRIPT,'fxsel_mode',lvar.fxsel_mode,true)
      reaper.SetExtState(SCRIPT,'fxsel_plugtype',lvar.fxsel_plugtype,true)

      reaper.SetExtState(RRSCRIPT,'quantize_strength',lvar.rrsettings.quantize_strength,true)

      --[[reaper.SetExtState(SCRIPT,'ME_cclanes_xtra1_tabidx',tostring(nz(lvar.lanes_xtra[1].tabidx,'')),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanes_xtra1_show',tostring(nz(lvar.lanes_xtra[1].show,false)),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanes_xtra1_bottom',tostring(nz(lvar.lanes_xtra[1].bottom,false)),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanes_xtra2_tabidx',tostring(nz(lvar.lanes_xtra[2].tabidx,'')),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanes_xtra2_show',tostring(nz(lvar.lanes_xtra[2].show,false)),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanes_xtra2_bottom',tostring(nz(lvar.lanes_xtra[2].bottom,false)),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanes_xtra3_tabidx',tostring(nz(lvar.lanes_xtra[3].tabidx,'')),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanes_xtra3_show',tostring(nz(lvar.lanes_xtra[3].show,false)),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanes_xtra3_bottom',tostring(nz(lvar.lanes_xtra[3].bottom,false)),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanes_xtra4_tabidx',tostring(nz(lvar.lanes_xtra[4].tabidx,'')),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanes_xtra4_show',tostring(nz(lvar.lanes_xtra[4].show,false)),true)          
      reaper.SetExtState(SCRIPT,'ME_cclanes_xtra4_bottom',tostring(nz(lvar.lanes_xtra[4].bottom,false)),true)]]          

      reaper.SetExtState(SCRIPT,'TO_Active',tostring(nz(lvar.takeover.active,-1)),true)          
      reaper.SetExtState(SCRIPT,'TO_Device',tostring(nz(lvar.takeover.bus,0)),true)          
      reaper.SetExtState(SCRIPT,'TO_Channel',tostring(nz(lvar.takeover.channel,1)),true)          
      reaper.SetExtState(SCRIPT,'TO_1_F',tostring(nz(lvar.takeover.fader_to[1],'')),true)          
      reaper.SetExtState(SCRIPT,'TO_2_F',tostring(nz(lvar.takeover.fader_to[2],'')),true)          
      reaper.SetExtState(SCRIPT,'TO_3_F',tostring(nz(lvar.takeover.fader_to[3],'')),true)          
      reaper.SetExtState(SCRIPT,'TO_4_F',tostring(nz(lvar.takeover.fader_to[4],'')),true)          
      reaper.SetExtState(SCRIPT,'TO_1_E',tostring(nz(lvar.takeover.encoder_to[1],'')),true)          
      reaper.SetExtState(SCRIPT,'TO_2_E',tostring(nz(lvar.takeover.encoder_to[2],'')),true)          
      reaper.SetExtState(SCRIPT,'TO_3_E',tostring(nz(lvar.takeover.encoder_to[3],'')),true)          
      reaper.SetExtState(SCRIPT,'TO_4_E',tostring(nz(lvar.takeover.encoder_to[4],'')),true)          
      
      reaper.SetExtState(SCRIPT,'LBX_CTL_TRACK_AM',tostring(LBX_CTL_TRACK_AM),true)          
      reaper.SetExtState(SCRIPT,'recoffmode',tostring(lvar.recoffmode),true)          
      reaper.SetExtState(SCRIPT,'rec_starttransportonfadertouch',tostring(lvar.rec_starttransportonfadertouch),true)

      reaper.SetExtState(SCRIPT,'defaulttemplate_active',tostring(lvar.defaulttemplate_active),true)
      reaper.SetExtState(SCRIPT,'defaulttemplate_type',tostring(lvar.defaulttemplate_type),true)
      
      reaper.SetExtState(SCRIPT,'selectfadermode',nz(lvar.selectfadermode,0),true)
      reaper.SetExtState(SCRIPT,'fineamt',nz(lvar.fineamt,1024),true)
      
      reaper.SetExtState(SCRIPT,'stripperlink',tostring(lvar.stripperlink),true)
      reaper.SetExtState(SCRIPT,'sk2data_setdata_delaytime',lvar.sk2data_setdata_delaytime,true)
      reaper.SetExtState(SCRIPT,'sk2data_setdata_delayaffectsfeedback',tostring(lvar.sk2data_setdata_delayaffectsfeedback),true)
      reaper.SetExtState(SCRIPT,'sk2setdata_num',lvar.sk2setdata_num,true)
      
      reaper.SetExtState(SCRIPT,'AKLayerMode',lvar.AKLayerMode,true)
      reaper.SetExtState(SCRIPT,'assignmentdisplay_active',tostring(lvar.assignmentdisplay_active),true)
      
      reaper.SetExtState(SCRIPT,'rr_defeat_active',tostring(lvar.rr_defeat_active),true)
      
      --local fn = paths.globtemplate_path..LBX_PERMATMP
      --SaveFXParamTemplate(nil, permatemplate, fn, true, true)
      
      SaveDefCCs()
      SaveUserFilters()
      SaveLaneOverrideData()
      SaveLanePresets()
      SaveLanesXtra()
      
      SaveQFX()
    end
  
  end
  
  function SaveQFX(idx)
    --local t = reaper.time_precise()
    if idx then
      local i = lvar.qfx_bank*lvar.qfx_faders + idx
      local data = ''
      if lvar.qfx_data[i] then
        data = pickle(lvar.qfx_data[i])
      end
      reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i), data)
      --[[if lvar.qfx_data[i] then
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_enabled", lvar.qfx_data[i].enabled)
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_tracknum", lvar.qfx_data[i].trnum)
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_trackguid", lvar.qfx_data[i].trguid)
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_fxnum", lvar.qfx_data[i].fxnum)
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_fxguid", tostring(lvar.qfx_data[i].fxguid))
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_pnum", lvar.qfx_data[i].pnum)
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_pname", lvar.qfx_data[i].pname)
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_mode", lvar.qfx_data[i].mode)
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_module", lvar.qfx_data[i].module)
      else
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_enabled", '')
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_tracknum", '')
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_trackguid", '')
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_fxnum", '')
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_fxguid", '')
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_pnum", '')
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_pname", '')
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_mode", '')
        reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_module", '')
      end]]
    
    else
      for b = 0, lvar.qfx_banks-1 do
        for ii = 1, lvar.qfx_faders do
        
          local i = b*lvar.qfx_faders + ii
          local data = ''
          if lvar.qfx_data[i] then
            data = pickle(lvar.qfx_data[i])
          end
          reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i), data)
          
          --[[if lvar.qfx_data[i] then
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_enabled", lvar.qfx_data[i].enabled)
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_tracknum", lvar.qfx_data[i].trnum)
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_trackguid", lvar.qfx_data[i].trguid)
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_fxnum", lvar.qfx_data[i].fxnum)
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_fxguid", tostring(lvar.qfx_data[i].fxguid))
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_pnum", lvar.qfx_data[i].pnum)
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_pname", lvar.qfx_data[i].pname)
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_mode", lvar.qfx_data[i].mode)
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_module", lvar.qfx_data[i].module)
          else
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_enabled", '')
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_tracknum", '')
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_trackguid", '')
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_fxnum", '')
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_fxguid", '')
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_pnum", '')
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_pname", '')
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_mode", '')
            reaper.SetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_module", '')
          end]]
        
        end
      end
    end
    --DBG(reaper.time_precise()-t)
  end

  function LoadQFX()
  --local t = reaper.time_precise()
    lvar.qfx_update = true
    lvar.qfx_data = {}
    
    for b = 0, lvar.qfx_banks-1 do
      for ii = 1, lvar.qfx_faders do
        
        local i = b*lvar.qfx_faders + ii
        local ret, v = reaper.GetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i))
        if ret and (v or '') ~= '' then
          lvar.qfx_data[i] = unpickle(v)
        end
        --[[local ret, v = reaper.GetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_tracknum")
        if ret and (v or '') ~= '' then
          lvar.qfx_data[i] = {}
          lvar.qfx_data[i].trnum = tonumber(v)
          _, lvar.qfx_data[i].enabled = reaper.GetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_enabled")
          _, lvar.qfx_data[i].trguid = reaper.GetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_trackguid")
          _, lvar.qfx_data[i].fxguid = reaper.GetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_fxguid")
          _, lvar.qfx_data[i].fxnum = reaper.GetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_fxnum")
          _, lvar.qfx_data[i].pnum = reaper.GetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_pnum")
          _, lvar.qfx_data[i].pname = reaper.GetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_pname")
          _, lvar.qfx_data[i].mode = reaper.GetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_mode")
          _, lvar.qfx_data[i].module = reaper.GetProjExtState(0, "SK2_QFX_DATA", "f"..string.format('%i',i).."_module")
  
          lvar.qfx_data[i].enabled = tonumber(lvar.qfx_data[i].enabled)
          lvar.qfx_data[i].fxnum = tonumber(lvar.qfx_data[i].fxnum)
          lvar.qfx_data[i].pnum = tonumber(lvar.qfx_data[i].pnum)
          lvar.qfx_data[i].mode = tonumber(lvar.qfx_data[i].mode) or 0
  
          if (lvar.qfx_data[i].fxguid or '') == '' or lvar.qfx_data[i].fxguid == 'nil' then
            lvar.qfx_data[i] = nil
          end
        end]]
      end
    end
  --DBG(reaper.time_precise()-t)  
  end
  
  function LoadSettings()
  
    local x, y = GES('win_x',true), GES('win_y',true)
    local ww, wh = GES('win_w',true), GES('win_h',true)
    local d = GES('dock',true)
    if x == nil then x = 0 end
    if y == nil then y = 0 end
    if d == nil then d = gfx.dock(-1) end    
    if ww ~= nil and wh ~= nil then
      gfx1 = {main_w = tonumber(ww),
              main_h = tonumber(wh)}
      gfx.init(lvar.wintit, gfx1.main_w, gfx1.main_h, 0, x, y)
      if not LoadLocation() then gfx.dock(d) end
    else
      gfx1 = {main_w = 400, main_h = 450}
      Lokasenna_Window_At_Center(gfx1.main_w,gfx1.main_h)  
      if not LoadLocation() then gfx.dock(d) end
    end
    settings.skccdirect = tobool(GES('skccdirect',true))
    settings.rrmode = (tobool(GES('rrmode',true))) or false
    settings.groupinputs = (tobool(GES('groupinputs',true))) or false
    --settings.ccsend = (tobool(GES('ccsend',true))) or false
    settings.sort = (tobool(GES('sort',true))) or false
    lvar.touchenabled = (tobool(GES('touchenabled',true))) or false
    settings.hidectltrack = (tobool(GES('hidetracks',true)))
    settings.liveccfb = (tobool(GES('liveccfb',true)))
    lvar.dv_filter_enabled = tobool(GES('dv_filter_enabled',true) or lvar.dv_filter_enabled)
    lvar.checktracks = tonumber(GES('checktracks',true))
    lvar.checktracks_rrobin = tonumber(GES('checktracks_rrobin',true)) or lvar.checktracks_rrobin
    
    lvar.guizoom = tonumber(GES('guizoom',true)) or 1
    lvar.guizoom2 = tonumber(GES('guizoom2',true)) or 1
    lvar.fontzoom = tonumber(GES('fontzoom',true)) or 1
    lvar.fontzoom2 = tonumber(GES('fontzoom2',true)) or 1
    lvar.fontoffset = tonumber(GES('fontoffset',true)) or 0

    lvar.mode = tonumber(GES('mode',true)) or 3
    lvar.fbcconseek = tobool(GES('fbcconseek',true))
    lvar.disableSSplayback = tobool(zn(GES('disableSSplayback',true),lvar.disableSSplayback))
    lvar.autochase = tobool(nz(GES('autochase',true),true))
    lvar.maxchasetime = tonumber(GES('maxchasetime',true)) or 500
    lvar.showglobalmap = tobool(nz(GES('showglobalmap',true),true))
    lvar.currentglobalmap = tonumber(GES('currentglobalmap',true)) or 1
    lvar.display_mini = tobool(nz(GES('compactmode',true),false))
    settings.includetracknameinss = tobool(nz(GES('includetracknameinss',true),true))
    lvar.timecodedisplayformat = tonumber(nz(GES('timecodedisplayformat',true),0))
    lvar.ccstamp_active = tonumber(nz(GES('ccstamp_active',true),0))
    lvar.automodeswitch = tonumber(nz(GES('automodeswitch',true),0))
    
    lvar.mirrordevices = tobool(nz(GES('mirrordevices',true),false))
    lvar.mirrordev_1to2 = tobool(nz(GES('mirrordev12',true),false))
    lvar.mirrordev_3to4 = tobool(nz(GES('mirrordev34',true),false))
    lvar.mirrordev_1toAll = tobool(nz(GES('mirrordev1All',true),false))
    
    lvar.fdata_sendcconrel = tonumber(nz(GES('fdata_sendcconrel',true),lvar.fdata_sendcconrel))
    lvar.fdata_removedups = tonumber(nz(GES('fdata_removedups',true),lvar.fdata_removedups))
    reaper.gmem_write(lvar.gm_cc.fdata_removedups, lvar.fdata_removedups)
    
    lvar.display_overlay_active = tobool(nz(GES('displayoverlay',true),false))
    lvar.display_overlay_inputonly = tobool(nz(GES('displayoverlay_io',true),false))
    lvar.resetfaderpostoprintccvalue = tobool(nz(GES('resetfaderpostoprintccvalue',true),false))
    lvar.dummyfaders = tonumber(nz(GES('dummyfaders',true),lvar.dummyfaders))
    lvar.autoglob_plug = tonumber(zn(GES('autoglob_plug',true),lvar.autoglob_plug))
    lvar.autoglob_track = tonumber(zn(GES('autoglob_track',true),lvar.autoglob_track))
    lvar.loadalltemplates = tobool(nz(GES('loadalltemplates',true),false))    
    lvar.restorelastfilter = tobool(nz(GES('restorelastfilter',true),false))    
    lvar.trackoffsetfollowsselected = tobool(nz(GES('trackoffsetfollowsselected',true),false))    
    lvar.trackoffset_visibleonly = tonumber(zn(GES('trackoffset_visibleonly',true),lvar.trackoffset_visibleonly))
    lvar.trackselectmode = tobool(nz(GES('trackselectmode',true),lvar.trackselectmode))    
    
    lvar.ss_color_override_enabled = tobool(nz(GES('ss_color_override_enabled',true),lvar.ss_color_override_enabled))
    lvar.ss_color_override_color = tonumber(zn(GES('ss_color_override_color',true),lvar.ss_color_override_color))
    lvar.ss_color_override_nonautomatable = tobool(nz(GES('ss_color_override_nonautomatable',true),lvar.ss_color_override_nonautomatable))
    lvar.ss_color_override_nonautomatable_color = tonumber(zn(GES('ss_color_override_nonautomatable_color',true),lvar.ss_color_override_nonautomatable_color))    
    
    lvar.ss_alwaysshowdispval = tobool(nz(GES('ss_alwaysshowdispval',true),lvar.ss_alwaysshowdispval))
    
    lvar.rec_mapactiveenvstofaders2 = tobool(nz(GES('rec_mapactiveenvstofaders2',true),lvar.rec_mapactiveenvstofaders2))
    lvar.rec_automap_solo = tobool(nz(GES('rec_automap_solo',true),lvar.rec_automap_solo))
    lvar.rec_automap_device = tonumber(zn(GES('rec_automap_device',true),lvar.rec_automap_device))
    lvar.rec_automap_color_vol = tonumber(zn(GES('rec_automap_color_vol',true),lvar.rec_automap_color_vol))
    lvar.rec_automap_color_pan = tonumber(zn(GES('rec_automap_color_pan',true),lvar.rec_automap_color_pan))
    lvar.rec_automap_color_mute = tonumber(zn(GES('rec_automap_color_mute',true),lvar.rec_automap_color_mute))
    lvar.rec_automap_color_plug = tonumber(zn(GES('rec_automap_color_plug',true),lvar.rec_automap_color_plug))
    
    lvar.defaultfilter = tonumber(GES('defaultfilter',true))
    if tobool(GES('defaultfilter_on',true)) then
      lvar.defaultfilter_on = true
    end

    lvar.midieditor_cclanes = tobool(nz(GES('ME_cclanes',true),false))
    lvar.lanes_ov_enable = tobool(nz(GES('ME_lanepresetenable',true),true))
    lvar.midieditor_cclanes_max = tonumber(GES('ME_cclanesmax',true)) or 3
    lvar.midieditor_cclanes_h = tonumber(GES('ME_cclanesh',true)) or 50

    lvar.env_autoshow_cnt = tonumber(nz(GES('env_autoshow_cnt',true), lvar.env_autoshow_cnt))
    lvar.autoenv = tobool(nz(GES('autoenv',true), lvar.autoenv))    
    lvar.autoenv_mode = tonumber(nz(GES('autoenv_mode',true), lvar.autoenv_mode))
    lvar.autoenv_assslip = tobool(nz(GES('autoenv_assslip',true), lvar.autoenv_assslip))
    lvar.env_laneheight = tonumber(nz(GES('env_laneheight',true), lvar.env_laneheight))
    lvar.env_spread = tonumber(nz(GES('env_spread',true), lvar.env_spread))
    lvar.env_spread_limit = tonumber(nz(GES('env_spread_limit',true), lvar.env_spread_limit))
    lvar.env_maxheight = tonumber(nz(GES('env_maxheight',true), lvar.env_maxheight))
    lvar.env_tralign = tonumber(nz(GES('env_tralign',true), lvar.env_tralign))

    lvar.fxlearnmode = tonumber(nz(GES('fxlearnmode',true), lvar.fxlearnmode))
    
    lvar.takeover.active = tonumber(GES('TO_Active',true)) or -1
    lvar.takeover.bus = tonumber(GES('TO_Device',true)) or 0
    lvar.takeover.channel = tonumber(GES('TO_Channel',true)) or 1
    lvar.takeover.fader_to[1] = tonumber(GES('TO_1_F',true))
    lvar.takeover.fader_to[2] = tonumber(GES('TO_2_F',true))
    lvar.takeover.fader_to[3] = tonumber(GES('TO_3_F',true))
    lvar.takeover.fader_to[4] = tonumber(GES('TO_4_F',true))
    lvar.takeover.encoder_to[1] = tonumber(GES('TO_1_E',true))
    lvar.takeover.encoder_to[2] = tonumber(GES('TO_2_E',true))
    lvar.takeover.encoder_to[3] = tonumber(GES('TO_3_E',true))
    lvar.takeover.encoder_to[4] = tonumber(GES('TO_4_E',true))
    
    LBX_CTL_TRACK_AM = tonumber(GES('LBX_CTL_TRACK_AM',true)) or 4
    lvar.recoffmode = tonumber(GES('recoffmode',true)) or 0
    lvar.rec_starttransportonfadertouch = tobool(nz(GES('rec_starttransportonfadertouch',true), lvar.rec_starttransportonfadertouch))
    
    lvar.defaulttemplate_active = tobool(nz(GES('defaulttemplate_active',true), lvar.defaulttemplate_active))
    lvar.defaulttemplate_type = tonumber(nz(GES('defaulttemplate_type',true), lvar.defaulttemplate_type))
    
    lvar.selectfadermode = tonumber(nz(GES('selectfadermode',true), lvar.selectfadermode))

    lvar.fxsel_mode = tonumber(nz(GES('fxsel_mode',true), lvar.fxsel_mode))
    lvar.fxsel_plugtype = tonumber(nz(GES('fxsel_plugtype',true), lvar.fxsel_plugtype))
    
    --RR Settings
    lvar.rrsettings.autoquantize = tonumber(nz(reaper.GetExtState(RRSCRIPT, 'autoquantize'), lvar.rrsettings.autoquantize)) or 0
    lvar.rrsettings.quantize_strength = tonumber(nz(reaper.GetExtState(RRSCRIPT, 'quantize_strength'), lvar.rrsettings.quantize_strength)) or 100
    lvar.rrsettings.autorestore = tonumber(reaper.GetExtState(RRSCRIPT, 'autorestore')) or 0
    lvar.rrsettings.merge = tonumber(nz(reaper.GetExtState(RRSCRIPT, 'merge'), lvar.rrsettings.merge)) or 1
    lvar.rrsettings.extend = tonumber(nz(reaper.GetExtState(RRSCRIPT, 'extend'), lvar.rrsettings.extend)) or 1
    lvar.rrsettings.overdubnotes = tonumber(nz(reaper.GetExtState(RRSCRIPT, 'overdubnotes'), lvar.rrsettings.overdubnotes)) or 1
    lvar.rrsettings.timeselection = tonumber(nz(reaper.GetExtState(RRSCRIPT, 'timeselection'), lvar.rrsettings.timeselection)) or 0
    lvar.rrsettings.trackoffset = tonumber(nz(reaper.GetExtState(RRSCRIPT, 'trackoffset'), lvar.rrsettings.trackoffset)) or 0
    
    lvar.rr_defeat_active = tobool(nz(GES('rr_defeat_active',true),lvar.rr_defeat_active))
    
    lvar.virtualss_active = tobool(nz(GES('virtualss_active',true),lvar.virtualss_active))
    
    --stripperlink
    lvar.stripperlink = tobool(nz(GES('stripperlink',true), lvar.stripperlink))
    lvar.sk2data_setdata_delaytime = tonumber(GES('sk2data_setdata_delaytime',true)) or lvar.sk2data_setdata_delaytime
    lvar.sk2data_setdata_delayaffectsfeedback = tobool(nz(GES('sk2data_setdata_delayaffectsfeedback',true), lvar.sk2data_setdata_delayaffectsfeedback))
    lvar.sk2setdata_num = tonumber(GES('sk2setdata_num',true)) or lvar.sk2setdata_num
    lvar.AKLayerMode = tonumber(GES('AKLayerMode',true)) or lvar.AKLayerMode
    lvar.assignmentdisplay_active = tobool(nz(GES('assignmentdisplay_active',true), lvar.assignmentdisplay_active))

    --[[lvar.lanes_xtra[1].tabidx = tonumber(GES('ME_cclanes_xtra1_tabidx',true))
    lvar.lanes_xtra[1].show = tobool(GES('ME_cclanes_xtra1_show',true))
    lvar.lanes_xtra[1].bottom = tobool(GES('ME_cclanes_xtra1_bottom',true))
    lvar.lanes_xtra[2].tabidx = tonumber(GES('ME_cclanes_xtra2_tabidx',true))
    lvar.lanes_xtra[2].show = tobool(GES('ME_cclanes_xtra2_show',true))
    lvar.lanes_xtra[2].bottom = tobool(GES('ME_cclanes_xtra2_bottom',true))
    lvar.lanes_xtra[3].tabidx = tonumber(GES('ME_cclanes_xtra3_tabidx',true))
    lvar.lanes_xtra[3].show = tobool(GES('ME_cclanes_xtra3_show',true))
    lvar.lanes_xtra[3].bottom = tobool(GES('ME_cclanes_xtra3_bottom',true))
    lvar.lanes_xtra[4].tabidx = tonumber(GES('ME_cclanes_xtra4_tabidx',true))
    lvar.lanes_xtra[4].show = tobool(GES('ME_cclanes_xtra4_show',true))
    lvar.lanes_xtra[4].bottom = tobool(GES('ME_cclanes_xtra4_bottom',true))]]
    
    lvar.fineamt = tonumber(nz(GES('fineamt',true), lvar.fineamt))
    reaper.gmem_write(lvar.fineamt_idx, lvar.fineamt)
    
    reaper.SetExtState(PUSCRIPT, 'sk2mode', lvar.mode, false)
    lvar.propaot = tobool(zn(reaper.GetExtState(PUSCRIPT, 'aot'),lvar.propaot)) 
  end
  
  function SetUpCFuncs()
    tab_commonfuncs_f[1] = CF_Flip
    tab_commonfuncs_f[2] = CF_Mode
    tab_commonfuncs_f[3] = CF_Mode
    tab_commonfuncs_f[4] = CF_Mode
    tab_commonfuncs_f[5] = CF_Timecode
    tab_commonfuncs_f[6] = CF_StampCC        
    tab_commonfuncs_f[7] = CF_GrpOnOff
    tab_commonfuncs_f[8] = CF_Off        
    tab_commonfuncs_f[9] = CF_Off
    tab_commonfuncs_f[10] = CF_Off
    tab_commonfuncs_f[11] = CF_PlayOnTouchCC
    tab_commonfuncs_f[12] = CF_RemapControls
    tab_commonfuncs_f[13] = CF_Automap
    tab_commonfuncs_f[14] = CF_Off --Automap Bank L
    tab_commonfuncs_f[15] = CF_Off --Automap Bank R
    tab_commonfuncs_f[16] = CF_Automap_Flip --Automap Flip
    tab_commonfuncs_f[17] = CF_LearnFX --LearnFX
    tab_commonfuncs_f[18] = CF_REC 
    tab_commonfuncs_f[19] = CF_FB 
    tab_commonfuncs_f[20] = CF_SSVals --Keep vals on SS
    tab_commonfuncs_f[21] = CF_AssDispMode 
    tab_commonfuncs_f[22] = CF_TrackSelectMode 
    
  end
  ------------------------------------------------------------
  
  reaper.gmem_attach('LBX_SK2_SharedMem')
  
  PUSCRIPT='LBX_SK2_POPUP'
  PUSCRIPTDATA='LBX_SK2_POPUPDATA'
  SCRIPT='LBX_SK'
  REMSCRIPT='LBX_SK2_REMOTE'
  RRSCRIPT='LBX_SK_RRSETTINGS'
  
  LBX_FOL_TRNAME='LBX'
  LBX_CTL_TRNAME='__LBX_SKCTL'
  LBX_CC_TRNAME='__LBX_SKCC'
  LBX_IN_TRNAME = '__LBX_SKIN'
  --LBX_TOUCH_TRNAME='__LBX_SKTOUCH'
  LBX_RR_TRNAME='__LBX_RRMIDI'
  LBX_INPUT_TRNAME = 'SK_IN_'
  LBX_AI_TRNAME = '__LBX_AI_STORE'
  
  LBX_DEFTRACKCCTMP = 'SK_DEFTRACKCC_TEMPLATE.smtemp'
  LBX_DEFGLOBALTMP = 'SK_DEFGLOBAL_TEMPLATE.smtemp'
  LBX_DEFGLOBALTMP_NUM = 'SK_GLOBAL_TEMPLATE_'

  LBX_PERMATMP = 'SK_PERMATEMPLATE.smtemp'
  LBX_LANESOV = 'SK_lanes_override.sklov'
  LBX_LANESOVPRE = 'SK_lanes_presets.sklov'
  LBX_LANESXTRA = 'SK_lanes.sklov'
  
  LBX_FXEL = 'SK_FXExclusionList.sklst'
  
  LBX_CTL_TRACK_AM = 4
  --LBX_FX_TRACK_DEFAM = 0
  
  flashctl = {}
  fader_touch = {}
  fader_touch2 = {}
  
  settings.hidectltrack = true
  settings.floatfxgui = 0
  settings.rrmode = false
  settings.ccsend = true
  settings.touchctl = true
  settings.includetracknameinss = true
  settings.liveccfb = true
  
  lvar.js_avail = reaper.APIExists('JS_Window_Find')
  
  AddPopUp()

  local _, trackinfo = GetFOLTrack()
  lvar.trackinfo = trackinfo
  local track = GetCTLTrack()
  --[[GetCCTrack()
  GetINTrack()
  GetInputTracks()
  GetInputCCTracks()
  GetRRTrack()
  GetOUTTracks()]]

  ctltrchecktime = reaper.time_precise()
  
  --[[if setting_hidectltrack == true and track then
    reaper.SetMediaTrackInfo_Value(track, "B_SHOWINTCP", 0)
    reaper.SetMediaTrackInfo_Value(track, "B_SHOWINMIXER", 0)
    reaper.TrackList_AdjustWindows(false)
    reaper.UpdateArrange()
  end]]
    
  recmode = 0
  lrnmode = false
  
  paths.resource_path = reaper.GetResourcePath().."/Scripts/LBX/SmartKnobs2_DATA/"
  paths.template_path = paths.resource_path.."templates/plugin/"
  paths.tracktemplate_path = paths.resource_path.."templates/trackcc/"
  paths.savedtemplate_path = paths.resource_path.."templates/saved/"  
  paths.globtemplate_path = paths.resource_path.."templates/global/"  
  paths.tags_path = paths.resource_path.."templates/tags/"    
  paths.deftemplate_path = paths.resource_path.."templates/default/"    
  paths.ctemplate_path = paths.resource_path.."controller_maps/"
  paths.setups_path = paths.resource_path.."setups/"
  paths.colorpreset_path = paths.resource_path.."color_presets/"
  
  reaper.RecursiveCreateDirectory(paths.resource_path,1)
  reaper.RecursiveCreateDirectory(paths.template_path,1)
  reaper.RecursiveCreateDirectory(paths.tracktemplate_path,1)
  reaper.RecursiveCreateDirectory(paths.savedtemplate_path,1)
  reaper.RecursiveCreateDirectory(paths.globtemplate_path,1)
  reaper.RecursiveCreateDirectory(paths.ctemplate_path,1)
  reaper.RecursiveCreateDirectory(paths.setups_path,1)
  reaper.RecursiveCreateDirectory(paths.tags_path,1)
  reaper.RecursiveCreateDirectory(paths.colorpreset_path,1)
  reaper.RecursiveCreateDirectory(paths.deftemplate_path,1)

  reaper.gmem_write(lvar.props.visible,0)

  lvar.lbx_commid = ({reaper.get_action_context()})[4]
  reaper.SetToggleCommandState(0, lvar.lbx_commid, 1)
  reaper.RefreshToolbar2(0, lvar.lbx_commid)

  InitCCTable()

  LoadColors()
  SetUnlitFaderCols(0.4)  
  --PType_SetCols()

  LoadSettings()
  LBX_FX_TRACK_AM = lvar.recoffmode

  SetUpCFuncs()
  GMFB_ButStates_Reset()
  GMFB_FaderChange_Reset()
  
  LoadSetUp('lastused')
  GMCCSTAMP_SetCCs()
  LoadDefCCs()
  
  LoadUserFilters()
  LoadLaneOverrideData()
  LoadLanePresets()
  LoadLanesXtra()
  
  LoadQFX()
  
  LoadTagData()
  
  LoadRemap()
      
  ResetCtlMap()
  for i = 1, 4 do
    if lvar.midimap[i] then
      local fn = paths.ctemplate_path..lvar.midimap[i]..'.skctlmap'
      LoadCtlMap(fn,i)
    end
  end
  SortCtlMap()
  SetCtlMap()
                      
  GetCtlTrackFound()
  
  Blacklist_Load()

  --gfx1 = {main_w = 400, main_h = 450}  
  --Lokasenna_Window_At_Center(gfx1.main_w,gfx1.main_h)

  LoadGlobalMapNames()

  if lvar.loadalltemplates == true then
    DBGOut('Load All Maps')
    LoadAllTemplates()
    DBGOut('Load All Maps /end')
  --else
    --LoadGlobalMap(nil, nil, true)
  end
  
  --[[local gfn
  if lvar.currentglobalmap == 1 then
    gfn = paths.globtemplate_path..LBX_DEFGLOBALTMP
  else  
    gfn = paths.globtemplate_path..LBX_DEFGLOBALTMP_NUM.. string.format('%i',lvar.currentglobalmap) ..'.smtemp'
  end
  LoadGlobalMap(gfn, lvar.currentglobalmap)]]

  --LoadGlobalMap(nil, lvar.currentglobalmap)
  --LoadGlobalMap(paths.globtemplate_path..LBX_DEFGLOBALTMP)
  mouse = {}
  --FFX = GetFFX(force)
  --gui = GetGUI_vars()
  --obj = GetObjects()
  --GUI_DrawMsg(obj, gui, {'LBX SRD TJL','','Smart Knobs 2', '', 'Initializing', '', 'Please Wait...',''},{14,10,18,2}) 
  --time_delay = reaper.time_precise()+1

  LoadGroupSettings()
  reaper.gmem_write(lvar.gm_fb.fflash_cnt,0)
  --GMFB_FFlashData(2,0.025,0.025,4)
  --GMFB_FFlashData(1,0.01,0.01,-1)
  --GMFB_FFlashData(0,0.125,0.05,-1)

  --if lvar.defaultfilter then
    lvar.userfilter.select = lvar.defaultfilter or 1
    if lvar.userfilter[lvar.userfilter.select] then
      lvar.lstfilt = table.copy(lvar.userfilter[lvar.userfilter.select].filter)
      lvar.lstfiltsel = {}
      for i = 1, #lvar.lstfilt do
        lvar.lstfiltsel[lvar.lstfilt[i]] = true
      end
      if not lvar.restorelastfilter or not lvar.defaultfilter_on then
        lvar.filtidx = nil
        lvar.filtidx2 = nil
        lvar.fcountfilt = nil
      else
        UpdateFilter()        
      end
    else
      lvar.userfilter.select = nil
    end
  --else
 --   lvar.userfilter.select = 1
  --end
  RemoteSetUp()
  
  InitTakeoverTypes()
  InsertTakeoverAssignments()
  
  TemplateChanged()
  
  --test
  --[[lvar.takeover.fader_to[1] = 1
  lvar.takeover.encoder_to[1] = 2
  lvar.takeover.active = 1
  InsertTakeoverAssignments()]]
  --DBG(reaper.NamedCommandLookup("Script: LBX_CM_Creator.lua"))
  run()
  reaper.atexit(quit)
  
  ------------------------------------------------------------
