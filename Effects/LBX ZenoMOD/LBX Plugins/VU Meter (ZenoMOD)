//**************************************************************************************************
// Simple VU Meter - a fine freeware by chris-s
// V1.1; 10-Jan-2017
// Disclaimer: Use of this software is on your own risk


// Modified by Zeno
// V1.4; 16-Jan-2020
   - added four new Styles: Modern, Purple, Ugly Child and BLVCK
   - added simplified embedded UI in MCP & TCP (currently not working)
   - scale adjusted, fine tuning notch & value positions
   - added volume slider for gain adjustments (+-18dB)
   - added hidden sliders for peak LEDs left/mid and right/side
   - added hidden sliders for vu meter readout left/mid and right/side
   
   
   Hidden sliders can be used as triggers for scripts and parameter modulation !!
   Ex: Modulate slider7 with slider50 to get a simple compressor. Use slider5 to set time constants.
   
	 
   A BIG THANKS goes out to jreng & CrashAlpha !!!
//*************************************** END INFO **************************************************



desc:VU Meter (ZenoMOD) - [Click 'Edit...' to read info text & make 'Hidden Sliders' visible] 
//tags: analysis analyzer vu meter
//author: chris-s , Zeno

// hidden sliders: remove the "-" in front of the name to activate

// Sliders                                                        // Name          // Visibility

slider1:0<4,3,2,1,0{Modern,Purple,Ugly Child,Classic,BLVCK}>      Style
slider2:0<0,2,1{Stereo,Mono,Mid/Side}>                            Mode

slider3:-18<-20,0,0.5>                                            Ref Level
slider4:-6<-20,0,0.1>                                             Warn Level
slider5:50<0,100>                                                 -Response           // Hidden
slider6:0.0053<0,.01,0.0001>                                      -Damping           // Hidden
slider7:0<-18,18,0.1>                                             Volume (dB)

slider50: -20<-20,0,3>                                            -VU Left/Mid      // Hidden     
slider51: -20<-20,0,3>                                            -VU Right/Side   // Hidden
slider52: 0<0,1>                                                  -Peak LED L        // Hidden
slider53: 0<0,1>                                                  -Peak LED R        // Hidden



  
// Hide side meters
options:no_meter

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

 
/***************************************** END DESC *****************/



@init

//========================================= VOLUME ==================/
AMP_dB_i=1/8.68588963806504;

db=slider7; // initialize here but not in @slider for playback start


//======================================== VU METER =================/
// bg col
gfx_clear = 30 + 60 * 256 + 110 * 65536;

errcnt = 0;
tot_nbr_spl = 0;
scnt = 0;

fact_up = 0;

offset = 0.0074;

nd_posL = nd_posR = 0;
nd_speedL = nd_speedR = 0;

dt = 10 / srate;

mom = 0.00042;
damp = 1 - 0.0053 * (48000 / srate);

dbL = dbR = 0;
overL = overR = 0;


print = 10;
print[0] = -20;
print[1] = -10;
print[2] = -7;
print[3] = -5;
print[4] = -3;
print[5] = -2;
print[6] = -1;
print[7] = 0;
print[8] = 1;
print[9] = 2;
print[10] = 3;


pos = 30;
pos[0] = 0;
pos[1] = .1650;
pos[2] = .2641;
pos[3] = .3519;
pos[4] = .4626;
pos[5] = .5284;
pos[6] = .6022;
pos[7]  = .6849;
pos[8]  = .7779;
pos[9] = .8822;
pos[10] = 1;

/**************************************** END @INIT *****************/



@slider

//======================================== VOLUME ===================/
ddb=0.0;


//======================================== VU METER =================/
fact_up = 10 ^ (( -slider3 - 10)/20) * 0.3785 ;

wl   = slider4;
mode = slider2;
lim = 10 ^ (wl / 20);

mom = 0.00010 + 0.00032 *  slider5^3 / 125000;   

damp = 1 - slider6 * (48000 / srate);

/**************************************** END @SLIDER ***************/



@block

//========================================= VOLUME ==================/
cnt=0;
ddb=0.0;

db_chg_splpos=slider_next_chg(1, tgtdb);
db_chg_splpos > 0 ? 
(
  db=slider7;
) : (
  tgtdb = slider7;
  db_chg_splpos = samplesblock;
);

ddb=(tgtdb-db)/db_chg_splpos;

/**************************************** END @BLOCK ****************/



@sample

//========================================= VOLUME ==================/
cnt == db_chg_splpos ? (
  ddb=0.0;
  db_chg_splpos=slider_next_chg(1, tgtdb);
  db_chg_splpos > cnt ? (
    ddb=(tgtdb-db)/(db_chg_splpos-cnt);
  );
);


adj=exp(db*AMP_DB_i);

spl0 *= adj;
spl1 *= adj;

db += ddb;
cnt += 1;


//======================================== VU METER =================/
tot_nbr_spl += 1;

smpL = spl0; 
smpR = spl1;

mode == 1 ? ( 
  smpL = (spl0 + spl1) * 0.5;
  smpR = smpL;  
);

mode >= 2 ? ( 
  smpL = (spl0 + spl1) * 0.5;
  smpR = (spl0 - spl1) * 0.5;  
);

smpL = abs(smpL);
smpR = abs(smpR);

scnt += 1;

scnt === 10 ? (
    
    // move left needle
  
    force = smpL * fact_up  -  (nd_posL * .1 + offset);
    
    nd_speedL += force * dt / mom;  
    nd_speedL = nd_speedL * damp;
    nd_posL += nd_speedL * dt;
    nd_posL < 0 || nd_posL > 1 ? nd_speedL = 0;
  
    nd_posL = min(max(nd_posL,0),1);
  
    // move right needle

    force = smpR * fact_up  - (nd_posR * .1 + offset);
    
    nd_speedR += force * dt / mom;  
    nd_speedR = nd_speedR * damp;
    nd_posR += nd_speedR * dt;
    nd_posR < 0 || nd_posR > 1 ? nd_speedR = 0;
  
    nd_posR = min(max(nd_posR,0),1);
     
    overL -= 10;
    overR -= 10;

    scnt = 0;  
);

smpL > lim ? overL = srate;
smpR > lim ? overR = srate;

tot_nbr_spl_g  = tot_nbr_spl;

overL_g = overL;
overR_g = overR;
nd_posL_g = nd_posL;
nd_posR_g = nd_posR;

tot_nbr_spl_g === tot_nbr_spl ? (
  dbL = (nd_posL_g * 23) - 20;
  dbR = (nd_posR_g * 23) - 20;
) : (
  errcnt += 1; // thread collision
);


slider50 = dbL;   
slider51 = dbR;   
slider52 = overL_g;
slider53 = overR_g;

/**************************************** END @SAMPLE ***************/



@gfx 480 236

// override drawing functions for graphical window scaling
gsc = min(gfx_w/480,gfx_h/236); igsc = 1.5/gsc;
gxo = max(0,  gfx_w/2 - gfx_h*480/236/2);

function gfx_lineto(x,y,aa) ( gfx_x*=gsc; gfx_y*=gsc; gfx_x+=gxo; 
	   gfx_lineto(x*gsc+gxo,y*gsc,aa); gfx_x-=gxo; gfx_x*=igsc; gfx_y*=igsc; );

function gfx_rectto(x,y)(gfx_x*=gsc; gfx_y*=gsc; gfx_x+=gxo; gsc>.5 ? 
	   gfx_rectto(x*gsc+gxo,y*gsc); gfx_x-=gxo;  gfx_x*=igsc; gfx_y*=igsc; );

function gfx_drawnumber(y,x) (
	gsc>.5 ? (
		gsc<.7 && x>1 ? x=1;
		gfx_x*=gsc; gfx_y*=gsc; gfx_x+=gxo; gfx_drawnumber(y,x); gfx_x-=gxo;  gfx_x*=igsc; gfx_y*=igsc; 
	);
);

function gfx_drawchar(x) (gsc>.5 ? gfx_drawchar(x););
function gfx_drawstr(x) (gsc>.5 ? gfx_drawstr(x););
function gfx_printf(x,y) ( gsc>.5 ? gfx_printf(x,y); );
function gfx_arc(x, y, r, a1, a2, aa) (gsc>.5 ? gfx_arc(x, y, r, a1, a2, aa) : gfx_arc(x, y, r, a1, a2, 0); );



// paint gfx 
fontinit != 1 ? (
  gfx_setfont(1, "Arial", 14, '');
  gfx_setfont(2, "Arial", 20, 'b');

  fontinit = 1;
);

//Style
style = slider1;

style == 0 ? (gfx_a = 1;);
style == 0 ? (gfx_clear = 0;);
style == 1 ? (gfx_clear = 0;);
style == 2 ? (gfx_a = 2;);
style == 2 ? (gfx_clear = 0;);
style == 3 ? (gfx_clear = 30 + 60 * 256 + 110 * 65536;);
style == 4 ? (gfx_a = 0;);
style == 4 ? (gfx_clear = 0;);


//
w1 = $pi * 16.5 / 180; 
w2 = $pi * 45 / 180;

xw = max(1,floor((gfx_w-30) / 2));
yw = floor(xw / 1.5);

r1 = floor(yw * 0.85);

chan = 0;

while (chan <= 1) (
  xd = 10 + chan*(xw+10);
  mode === 1 ? xd += floor(xw/2);
  
  yd = 10;

  xa = floor(xd + xw / 2);
  ya = floor(yd + yw * 1.1);

  //meter backgr   
  gfx_r=0;gfx_g=1;gfx_b=.9;     
  gfx_rect(xd,yd,xw,yw);
  // background style 1
  style == 1 ? (
	gfx_r=0.38;gfx_g=0.2;gfx_b=0.63; //purple
	gfx_rect(xd,yd,xw,yw);
	(gfx_a = 1;)
  );
  // background style 3
  style == 3 ? (
	  gfx_r=1;gfx_g=1;gfx_b=.7;  
	  gfx_rect(xd,yd,xw,yw);
  );
  // background style 4
    style == 4 ? (
	  gfx_r=gfx_g=gfx_b = 0; //black
	  gfx_rect(xd,yd,xw,yw);
	  (gfx_a = 1;)
  );
  
  
     
  // scale   
  gfx_r=gfx_g=gfx_b = 0; // black
  gfx_arc(xa, ya, r1, -45 * ($pi / 180), w2, 1);   
  gfx_r=.95; gfx_g=0; gfx_b = 0; // red 
  gfx_arc(xa, ya, r1 + 1, w1, w2, 1);
  gfx_arc(xa, ya, r1 + 2, w1, w2, 1);  
  gfx_arc(xa, ya, r1 + 3, w1, w2, 1);  
  gfx_arc(xa, ya, r1 + 4, w1, w2, 1);
  // scale style 1
  style == 1 ? (
    gfx_r=0.2;gfx_g=1;gfx_b= 1;
    gfx_arc(xa, ya, r1, -45 * ($pi / 180), w2, 1);   
    gfx_r= 1; gfx_g= 0; gfx_b= .5; // pink 
    gfx_arc(xa, ya, r1 + 1, w1, w2, 1);
    gfx_arc(xa, ya, r1 + 2, w1, w2, 1);  
    gfx_arc(xa, ya, r1 + 3, w1, w2, 1);  
    gfx_arc(xa, ya, r1 + 4, w1, w2, 1);
  );
  // scale style 4
  style == 4 ? (
    gfx_r=0.8;gfx_g=1;gfx_b= 1;
    gfx_arc(xa, ya, r1, -45 * ($pi / 180), w2, 1);   
    gfx_r= 1; gfx_g=.3; gfx_b =0.7; // pink 
    gfx_arc(xa, ya, r1 + 1, w1, w2, 1);
    gfx_arc(xa, ya, r1 + 2, w1, w2, 1);  
    gfx_arc(xa, ya, r1 + 3, w1, w2, 1);  
    gfx_arc(xa, ya, r1 + 4, w1, w2, 1);
  );
    
  gfx_setfont(1);
  
  gfx_r=gfx_g=gfx_b = 0.2; // black
  
  // font style 1
  style == 1 ? (
	gfx_setfont(1);
	gfx_r=0.2;gfx_g=1;gfx_b= 1;
  );
  // font style 4
  style == 4 ? (
	gfx_setfont(1);
	gfx_r=gfx_g=gfx_b= 1; // white
  );  
  
  
  // Draw scale notches and values if scaling allows
  gsc >.5 ? (
  
	jj = 0;
	while ( jj <= 10 ) (
		ii = print[jj];
    
		ph =  pos[jj];
		ph = (45 + ph*90) * $pi / 180; 
    
		cosp = cos(ph) * r1;
		sinp = sin(ph) * r1;
    
		x1 = xa - cosp ;
		y1 = ya - sinp ;

		x2 = xa - cosp * 1.1;
		y2 = ya - sinp * 1.1;
		
		x3 = xa - cosp * 1.15;
		y3 = ya - sinp * 1.11;
		
		gfx_x = x1;
		gfx_y = y1; 
		gfx_lineto(x2, y2);
			
		gfx_x = x3 - 8;   
		gfx_y = y3 - gfx_texth;
		   
		gfx_printf("%3d", ii);
		   
		jj += 1;
		   
		jj == 8 ? ( gfx_r = 1; gfx_g = gfx_b = 0 );
		
		// font style 1
		  style == 1 ? ( 
		  jj == 8 ? ( gfx_r= 0; gfx_g=.9; gfx_b =0.8; ); // turquoise
		  );
		  // font style 3
		  style == 3 ? (
		  gfx_x = x3 - 7;   
		  gfx_y = y3 - gfx_texth;
		    
		  gfx_printf("%3d", ii);
		  );
		  // font style 4
		  style == 4 ? ( 
		  jj == 8 ? ( gfx_r= 1; gfx_g=.3; gfx_b =0.7; ); // pink
		  );  
	); 
  );
  
  
  // Peak  
  gfx_r=gfx_g=gfx_b = 0.0; // black 
    
  gfx_x = xd + xw * .9 - 30;
  gfx_y = yd + yw * .9 - 10;
  gfx_drawstr("PEAK");
  // Peak style 1
  style == 1 ? (
  gfx_r= 0; gfx_g=.9; gfx_b =0.8; // turquoise 
	
    gfx_x = xd + xw * .9 - 30;
    gfx_y = yd + yw * .9 - 10;
    gfx_drawstr("PEAK");
  );
  // Peak style 4
  style == 4 ? (
  gfx_r= 0; gfx_g=.8; gfx_b =0.9; // turquoise 
	  
	gfx_x = xd + xw * .9 - 30;
	gfx_y = yd + yw * .9 - 10;
	gfx_drawstr("PEAK");
  );
  
  // VU
  gfx_setfont(2); // large
  gfx_r=gfx_g=gfx_b = 0.0; // black 
  
  gfx_x = xa - 10;
  gfx_y = yd + yw * .6;
  gfx_drawstr("VU");
  // VU style 1
    style == 1 ? (
    gfx_setfont(2); // large
	gfx_r= 0; gfx_g=.9; gfx_b =0.8; // turquoise 
	
	gfx_x = xa - 10;
	gfx_y = yd + yw * .6;
	gfx_drawstr("VU");
   );
   // VU style 4
   style == 4 ? (
   gfx_setfont(2); // large
	   gfx_r= 1; gfx_g=.3; gfx_b =0.7; // pink 
	   
	   gfx_x = xa - 10;
	   gfx_y = yd + yw * .6;
	   gfx_drawstr("VU");
   );
  
  
  // draw LEDs
  gfx_r = .95; gfx_g = gfx_b = 0.1; // red 
    
  (chan == 0 && overL_g > 0) || (chan == 1 && overR_g > 0)  ? (   
     gfx_circle(xd + xw*0.9 + 6, yd + yw * 0.9 - 4, 4, 1, 1);
  );
  // LEDs style 1
    style == 1 ? (
    gfx_r= 1; gfx_g= 0; gfx_b= .5; // pink 
	  
	(chan == 0 && overL_g > 0) || (chan == 1 && overR_g > 0)  ? (   
	   gfx_circle(xd + xw*0.9 + 6, yd + yw * 0.9 - 4, 4, 1, 1);
	);
   );
   // LEDs style 4
	style == 4 ? (
	gfx_r= 1; gfx_g=.3; gfx_b =0.7; // pink 
		  
		(chan == 0 && overL_g > 0) || (chan == 1 && overR_g > 0)  ? (   
		   gfx_circle(xd + xw*0.9 + 6, yd + yw * 0.9 - 4, 4, 1, 1);
		);
   );  
  
 
  
  // draw needle
  chan == 0 ? ph = dbL : ph = dbR;

  ph = 45 + (ph+20)/23*90; 
  ph = ph * ($pi / 180);
  
  cosp = cos(ph);
  sinp = sin(ph);
    
  x1 = xa - cosp * r1 * 0.15;
    y1 = ya - sinp * r1 * 0.15;
  
    x2 = xa - cosp * r1 * 1.1;
    y2 = ya - sinp * r1 * 1.1;
  
    gfx_r=gfx_g=gfx_b = 0.0; // black                   
  
    gfx_x = x1;
    gfx_y = y1; 
    gfx_lineto(x2, y2);
    // needle style 1
	  style == 1 ? (
	  gfx_r= 5; gfx_g= 0; gfx_b= 0.6;  // pink                 
	    
		gfx_x = x1;
		gfx_y = y1; 
		gfx_lineto(x2, y2);
    );
    // needle style style 4
	  style == 4 ? (
	  gfx_r= 0; gfx_g= 0.8; gfx_b= 1;  // turquoise                 
			
		gfx_x = x1;
		gfx_y = y1; 
		gfx_lineto(x2, y2);
    );

    // draw thick needle lines and shadows if scaling allows
    gsc >.5 ? (
	gfx_x = x1+1;
	gfx_y = y1;
	gfx_lineto(x2+1, y2);
  
	//needle shadow
	gfx_r=gfx_g=gfx_b = 0.6; // gray
	// needle shadow style 4
	style == 4 ? (
	gfx_r=0.1; gfx_g=0.2; gfx_b = 0.7; // gray
	);
	
	gfx_x = x1+4;
	gfx_y = y1; 
	gfx_lineto(x2+4, y2);
    );
    
    //needle circle
    gfx_r=gfx_g=gfx_b = 0; // black
    gfx_circle(xa,ya,r1*0.16,1,0);
    // needle circle style 3
	 style == 3 ? (
		gfx_r=.12; gfx_g=.24; gfx_b = 0.43; // blue
		gfx_circle(xa,ya,r1*0.16,1,0);
	 );     
    
    //channel labeling 
    gfx_r=gfx_g=gfx_b = 1; // white 
  
    gfx_x = xd;
    gfx_y = yd+yw+2;
    
    chan == 0 ?
	gfx_drawstr("LEFT / MID") :
	gfx_drawstr("RIGHT / SIDE") ;
  
    chan += 1;
    
    mode === 1 ? chan += 1;
  );
  
  
  
  /****************************** EOF *******************************/
 
  
  
   
